{
  "firecrawl": {
    "name": "firecrawl",
    "display_name": "Firecrawl",
    "description": "Advanced web scraping with JavaScript rendering, PDF support, and smart rate limiting",
    "repository": {
      "type": "git",
      "url": "https://github.com/mendableai/firecrawl-mcp-server"
    },
    "homepage": "https://github.com/mendableai/firecrawl-mcp-server",
    "author": {
      "name": "mendableai"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "firecrawl",
      "scraping",
      "web",
      "api",
      "automation"
    ],
    "examples": [
      {
        "title": "Basic Scraping Example",
        "description": "Scrape content from a single URL",
        "prompt": "firecrawl_scrape with url 'https://example.com'"
      },
      {
        "title": "Batch Scraping",
        "description": "Scrape multiple URLs",
        "prompt": "firecrawl_batch_scrape with urls ['https://example1.com', 'https://example2.com']"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "firecrawl-mcp"
        ],
        "env": {
          "FIRECRAWL_API_KEY": "${FIRECRAWL_API_KEY}"
        }
      }
    },
    "arguments": {
      "FIRECRAWL_API_KEY": {
        "description": "Your FireCrawl API key. Required for using the cloud API (default) and optional for self-hosted instances.",
        "required": true,
        "example": "fc-YOUR_API_KEY"
      }
    },
    "tools": [
      {
        "name": "firecrawl_scrape",
        "description": "Scrape a single webpage with advanced options for content extraction. Supports various formats including markdown, HTML, and screenshots. Can execute custom actions like clicking or scrolling before scraping.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to scrape"
            },
            "formats": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "markdown",
                  "html",
                  "rawHtml",
                  "screenshot",
                  "links",
                  "screenshot@fullPage",
                  "extract"
                ]
              },
              "description": "Content formats to extract (default: ['markdown'])"
            },
            "onlyMainContent": {
              "type": "boolean",
              "description": "Extract only the main content, filtering out navigation, footers, etc."
            },
            "includeTags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "HTML tags to specifically include in extraction"
            },
            "excludeTags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "HTML tags to exclude from extraction"
            },
            "waitFor": {
              "type": "number",
              "description": "Time in milliseconds to wait for dynamic content to load"
            },
            "timeout": {
              "type": "number",
              "description": "Maximum time in milliseconds to wait for the page to load"
            },
            "actions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "wait",
                      "click",
                      "screenshot",
                      "write",
                      "press",
                      "scroll",
                      "scrape",
                      "executeJavascript"
                    ],
                    "description": "Type of action to perform"
                  },
                  "selector": {
                    "type": "string",
                    "description": "CSS selector for the target element"
                  },
                  "milliseconds": {
                    "type": "number",
                    "description": "Time to wait in milliseconds (for wait action)"
                  },
                  "text": {
                    "type": "string",
                    "description": "Text to write (for write action)"
                  },
                  "key": {
                    "type": "string",
                    "description": "Key to press (for press action)"
                  },
                  "direction": {
                    "type": "string",
                    "enum": [
                      "up",
                      "down"
                    ],
                    "description": "Scroll direction"
                  },
                  "script": {
                    "type": "string",
                    "description": "JavaScript code to execute"
                  },
                  "fullPage": {
                    "type": "boolean",
                    "description": "Take full page screenshot"
                  }
                },
                "required": [
                  "type"
                ]
              },
              "description": "List of actions to perform before scraping"
            },
            "extract": {
              "type": "object",
              "properties": {
                "schema": {
                  "type": "object",
                  "description": "Schema for structured data extraction"
                },
                "systemPrompt": {
                  "type": "string",
                  "description": "System prompt for LLM extraction"
                },
                "prompt": {
                  "type": "string",
                  "description": "User prompt for LLM extraction"
                }
              },
              "description": "Configuration for structured data extraction"
            },
            "mobile": {
              "type": "boolean",
              "description": "Use mobile viewport"
            },
            "skipTlsVerification": {
              "type": "boolean",
              "description": "Skip TLS certificate verification"
            },
            "removeBase64Images": {
              "type": "boolean",
              "description": "Remove base64 encoded images from output"
            },
            "location": {
              "type": "object",
              "properties": {
                "country": {
                  "type": "string",
                  "description": "Country code for geolocation"
                },
                "languages": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Language codes for content"
                }
              },
              "description": "Location settings for scraping"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "firecrawl_map",
        "description": "Discover URLs from a starting point. Can use both sitemap.xml and HTML link discovery.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Starting URL for URL discovery"
            },
            "search": {
              "type": "string",
              "description": "Optional search term to filter URLs"
            },
            "ignoreSitemap": {
              "type": "boolean",
              "description": "Skip sitemap.xml discovery and only use HTML links"
            },
            "sitemapOnly": {
              "type": "boolean",
              "description": "Only use sitemap.xml for discovery, ignore HTML links"
            },
            "includeSubdomains": {
              "type": "boolean",
              "description": "Include URLs from subdomains in results"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of URLs to return"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "firecrawl_crawl",
        "description": "Start an asynchronous crawl of multiple pages from a starting URL. Supports depth control, path filtering, and webhook notifications.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Starting URL for the crawl"
            },
            "excludePaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "URL paths to exclude from crawling"
            },
            "includePaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Only crawl these URL paths"
            },
            "maxDepth": {
              "type": "number",
              "description": "Maximum link depth to crawl"
            },
            "ignoreSitemap": {
              "type": "boolean",
              "description": "Skip sitemap.xml discovery"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of pages to crawl"
            },
            "allowBackwardLinks": {
              "type": "boolean",
              "description": "Allow crawling links that point to parent directories"
            },
            "allowExternalLinks": {
              "type": "boolean",
              "description": "Allow crawling links to external domains"
            },
            "webhook": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "Webhook URL to notify when crawl is complete"
                },
                {
                  "type": "object",
                  "properties": {
                    "url": {
                      "type": "string",
                      "description": "Webhook URL"
                    },
                    "headers": {
                      "type": "object",
                      "description": "Custom headers for webhook requests"
                    }
                  },
                  "required": [
                    "url"
                  ]
                }
              ]
            },
            "deduplicateSimilarURLs": {
              "type": "boolean",
              "description": "Remove similar URLs during crawl"
            },
            "ignoreQueryParameters": {
              "type": "boolean",
              "description": "Ignore query parameters when comparing URLs"
            },
            "scrapeOptions": {
              "type": "object",
              "properties": {
                "formats": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "markdown",
                      "html",
                      "rawHtml",
                      "screenshot",
                      "links",
                      "screenshot@fullPage",
                      "extract"
                    ]
                  }
                },
                "onlyMainContent": {
                  "type": "boolean"
                },
                "includeTags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "excludeTags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "waitFor": {
                  "type": "number"
                }
              },
              "description": "Options for scraping each page"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "firecrawl_batch_scrape",
        "description": "Scrape multiple URLs in batch mode. Returns a job ID that can be used to check status.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of URLs to scrape"
            },
            "options": {
              "type": "object",
              "properties": {
                "formats": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "markdown",
                      "html",
                      "rawHtml",
                      "screenshot",
                      "links",
                      "screenshot@fullPage",
                      "extract"
                    ]
                  }
                },
                "onlyMainContent": {
                  "type": "boolean"
                },
                "includeTags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "excludeTags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "waitFor": {
                  "type": "number"
                }
              }
            }
          },
          "required": [
            "urls"
          ]
        }
      },
      {
        "name": "firecrawl_check_batch_status",
        "description": "Check the status of a batch scraping job.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Batch job ID to check"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "firecrawl_check_crawl_status",
        "description": "Check the status of a crawl job.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Crawl job ID to check"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "firecrawl_search",
        "description": "Search and retrieve content from web pages with optional scraping. Returns SERP results by default (url, title, description) or full page content when scrapeOptions are provided.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query string"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return (default: 5)"
            },
            "lang": {
              "type": "string",
              "description": "Language code for search results (default: en)"
            },
            "country": {
              "type": "string",
              "description": "Country code for search results (default: us)"
            },
            "tbs": {
              "type": "string",
              "description": "Time-based search filter"
            },
            "filter": {
              "type": "string",
              "description": "Search filter"
            },
            "location": {
              "type": "object",
              "properties": {
                "country": {
                  "type": "string",
                  "description": "Country code for geolocation"
                },
                "languages": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Language codes for content"
                }
              },
              "description": "Location settings for search"
            },
            "scrapeOptions": {
              "type": "object",
              "properties": {
                "formats": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "markdown",
                      "html",
                      "rawHtml"
                    ]
                  },
                  "description": "Content formats to extract from search results"
                },
                "onlyMainContent": {
                  "type": "boolean",
                  "description": "Extract only the main content from results"
                },
                "waitFor": {
                  "type": "number",
                  "description": "Time in milliseconds to wait for dynamic content"
                }
              },
              "description": "Options for scraping search results"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "firecrawl_extract",
        "description": "Extract structured information from web pages using LLM. Supports both cloud AI and self-hosted LLM extraction.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of URLs to extract information from"
            },
            "prompt": {
              "type": "string",
              "description": "Prompt for the LLM extraction"
            },
            "systemPrompt": {
              "type": "string",
              "description": "System prompt for LLM extraction"
            },
            "schema": {
              "type": "object",
              "description": "JSON schema for structured data extraction"
            },
            "allowExternalLinks": {
              "type": "boolean",
              "description": "Allow extraction from external links"
            },
            "enableWebSearch": {
              "type": "boolean",
              "description": "Enable web search for additional context"
            },
            "includeSubdomains": {
              "type": "boolean",
              "description": "Include subdomains in extraction"
            }
          },
          "required": [
            "urls"
          ]
        }
      },
      {
        "name": "firecrawl_deep_research",
        "description": "Conduct deep research on a query using web crawling, search, and AI analysis.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to research"
            },
            "maxDepth": {
              "type": "number",
              "description": "Maximum depth of research iterations (1-10)"
            },
            "timeLimit": {
              "type": "number",
              "description": "Time limit in seconds (30-300)"
            },
            "maxUrls": {
              "type": "number",
              "description": "Maximum number of URLs to analyze (1-1000)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "firecrawl_generate_llmstxt",
        "description": "Generate standardized LLMs.txt file for a given URL, which provides context about how LLMs should interact with the website.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to generate LLMs.txt from"
            },
            "maxUrls": {
              "type": "number",
              "description": "Maximum number of URLs to process (1-100, default: 10)"
            },
            "showFullText": {
              "type": "boolean",
              "description": "Whether to show the full LLMs-full.txt in the response"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ],
    "is_official": true
  },
  "rabbitmq": {
    "name": "rabbitmq",
    "display_name": "RabbitMQ",
    "description": "The MCP server that interacts with RabbitMQ to publish and consume messages.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kenliao94/mcp-server-rabbitmq"
    },
    "homepage": "https://github.com/kenliao94/mcp-server-rabbitmq",
    "author": {
      "name": "kenliao94"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "rabbitmq",
      "server",
      "messaging"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kenliao94/mcp-server-rabbitmq",
          "mcp-server-rabbitmq",
          "--rabbitmq-host",
          "${RABBITMQ_HOST}",
          "--port",
          "${RABBITMQ_PORT}",
          "--username",
          "${RABBITMQ_USERNAME}",
          "--password",
          "${RABBITMQ_PASSWORD}",
          "--use-tls",
          "${USE_TLS}"
        ]
      }
    },
    "examples": [
      {
        "title": "Publish Message",
        "description": "Ask Claude to publish a message to a queue.",
        "prompt": "Please publish a message to the queue."
      }
    ],
    "arguments": {
      "RABBITMQ_HOST": {
        "description": "The hostname of the RabbitMQ server (e.g., test.rabbit.com, localhost).",
        "required": true,
        "example": "test.rabbit.com"
      },
      "RABBITMQ_PORT": {
        "description": "The port number to connect to the RabbitMQ server (e.g., 5672).",
        "required": true,
        "example": "5672"
      },
      "RABBITMQ_USERNAME": {
        "description": "The username to authenticate with the RabbitMQ server.",
        "required": true,
        "example": "guest"
      },
      "RABBITMQ_PASSWORD": {
        "description": "The password for the RabbitMQ username provided.",
        "required": true,
        "example": "guest"
      },
      "USE_TLS": {
        "description": "Set to true if using TLS (AMQPS), otherwise false.",
        "required": false,
        "example": "true or false"
      }
    },
    "tools": [
      {
        "name": "enqueue",
        "description": "Enqueue a message to a queue hosted on RabbitMQ",
        "inputSchema": {
          "properties": {
            "message": {
              "description": "The message to publish",
              "title": "Message",
              "type": "string"
            },
            "queue": {
              "description": "The name of the queue",
              "title": "Queue",
              "type": "string"
            }
          },
          "required": [
            "message",
            "queue"
          ],
          "title": "Enqueue",
          "type": "object"
        }
      },
      {
        "name": "fanout",
        "description": "Publish a message to an exchange with fanout type",
        "inputSchema": {
          "properties": {
            "message": {
              "description": "The message to publish",
              "title": "Message",
              "type": "string"
            },
            "exchange": {
              "description": "The name of the exchange",
              "title": "Exchange",
              "type": "string"
            }
          },
          "required": [
            "message",
            "exchange"
          ],
          "title": "Fanout",
          "type": "object"
        }
      },
      {
        "name": "list_queues",
        "description": "List all the queues in the broker",
        "inputSchema": {
          "properties": {},
          "title": "ListQueues",
          "type": "object"
        }
      },
      {
        "name": "list_exchanges",
        "description": "List all the exchanges in the broker",
        "inputSchema": {
          "properties": {},
          "title": "ListExchanges",
          "type": "object"
        }
      },
      {
        "name": "get_queue_info",
        "description": "Get detailed information about a specific queue",
        "inputSchema": {
          "properties": {
            "queue": {
              "description": "The name of the queue to get info about",
              "title": "Queue",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the queue exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "queue"
          ],
          "title": "GetQueueInfo",
          "type": "object"
        }
      },
      {
        "name": "delete_queue",
        "description": "Delete a specific queue",
        "inputSchema": {
          "properties": {
            "queue": {
              "description": "The name of the queue to delete",
              "title": "Queue",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the queue exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "queue"
          ],
          "title": "DeleteQueue",
          "type": "object"
        }
      },
      {
        "name": "purge_queue",
        "description": "Remove all messages from a specific queue",
        "inputSchema": {
          "properties": {
            "queue": {
              "description": "The name of the queue to purge",
              "title": "Queue",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the queue exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "queue"
          ],
          "title": "PurgeQueue",
          "type": "object"
        }
      },
      {
        "name": "delete_exchange",
        "description": "Delete a specific exchange",
        "inputSchema": {
          "properties": {
            "exchange": {
              "description": "The name of the exchange to delete",
              "title": "Exchange",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the exchange exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "exchange"
          ],
          "title": "DeleteExchange",
          "type": "object"
        }
      },
      {
        "name": "get_exchange_info",
        "description": "Get detailed information about a specific exchange",
        "inputSchema": {
          "properties": {
            "exchange": {
              "description": "The name of the exchange to get info about",
              "title": "Exchange",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the exchange exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "exchange"
          ],
          "title": "GetExchangeInfo",
          "type": "object"
        }
      }
    ]
  },
  "mcp-server-axiom": {
    "display_name": "Axiom MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/axiomhq/mcp-server-axiom"
    },
    "homepage": "https://axiom.co",
    "author": {
      "name": "axiomhq"
    },
    "license": "MIT",
    "tags": [
      "axiom",
      "apl",
      "data",
      "query"
    ],
    "arguments": {
      "token": {
        "description": "Axiom API token",
        "required": true,
        "example": "xaat-your-token"
      },
      "url": {
        "description": "Axiom API URL",
        "required": true,
        "example": "https://api.axiom.co"
      },
      "query-rate": {
        "description": "Rate limit for queries",
        "required": false,
        "example": "1"
      },
      "query-burst": {
        "description": "Burst limit for queries",
        "required": false,
        "example": "1"
      },
      "datasets-rate": {
        "description": "Rate limit for dataset listing",
        "required": false,
        "example": "1"
      },
      "datasets-burst": {
        "description": "Burst limit for dataset listing",
        "required": false,
        "example": "1"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "axiom-mcp",
        "args": [
          "--config",
          "config.txt"
        ],
        "description": "Run using pre-built binary",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Basic Configuration",
        "description": "Configure the MCP server with a token",
        "prompt": "echo \"token xaat-your-token\" > config.txt"
      },
      {
        "title": "Claude Desktop Integration",
        "description": "Configure Claude desktop app to use the MCP server",
        "prompt": "code ~/Library/Application\\ Support/Claude/claude_desktop_config.json"
      }
    ],
    "name": "mcp-server-axiom",
    "description": "A [Model Context Protocol](https://modelcontextprotocol.io/) server implementation for [Axiom](https://axiom.co) that enables AI agents to query your data using Axiom Processing Language (APL).",
    "categories": [
      "Analytics"
    ],
    "is_official": true
  },
  "mcp-clickhouse": {
    "display_name": "ClickHouse MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/ClickHouse/mcp-clickhouse"
    },
    "homepage": "https://glama.ai/mcp/servers/yvjy4csvo1",
    "author": {
      "name": "ClickHouse"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "clickhouse",
      "database",
      "sql"
    ],
    "arguments": {
      "CLICKHOUSE_HOST": {
        "description": "The hostname of your ClickHouse server",
        "required": true,
        "example": "sql-clickhouse.clickhouse.com"
      },
      "CLICKHOUSE_USER": {
        "description": "The username for authentication",
        "required": true,
        "example": "demo"
      },
      "CLICKHOUSE_PASSWORD": {
        "description": "The password for authentication",
        "required": true,
        "example": ""
      },
      "CLICKHOUSE_PORT": {
        "description": "The port number of your ClickHouse server",
        "required": false,
        "example": "8443"
      },
      "CLICKHOUSE_SECURE": {
        "description": "Enable/disable HTTPS connection",
        "required": false,
        "example": "true"
      },
      "CLICKHOUSE_VERIFY": {
        "description": "Enable/disable SSL certificate verification",
        "required": false,
        "example": "true"
      },
      "CLICKHOUSE_CONNECT_TIMEOUT": {
        "description": "Connection timeout in seconds",
        "required": false,
        "example": "30"
      },
      "CLICKHOUSE_SEND_RECEIVE_TIMEOUT": {
        "description": "Send/receive timeout in seconds",
        "required": false,
        "example": "300"
      },
      "CLICKHOUSE_DATABASE": {
        "description": "Default database to use",
        "required": false,
        "example": "your_database"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uv",
        "args": [
          "run",
          "--with",
          "mcp-clickhouse",
          "--python",
          "3.13",
          "mcp-clickhouse"
        ],
        "package": "mcp-clickhouse",
        "env": {
          "CLICKHOUSE_HOST": "<clickhouse-host>",
          "CLICKHOUSE_PORT": "<clickhouse-port>",
          "CLICKHOUSE_USER": "<clickhouse-user>",
          "CLICKHOUSE_PASSWORD": "<clickhouse-password>",
          "CLICKHOUSE_SECURE": "true",
          "CLICKHOUSE_VERIFY": "true",
          "CLICKHOUSE_CONNECT_TIMEOUT": "30",
          "CLICKHOUSE_SEND_RECEIVE_TIMEOUT": "30"
        },
        "description": "Install and run using uv package manager",
        "recommended": true
      },
      "python": {
        "type": "python",
        "command": "pip",
        "args": [
          "install",
          "mcp-clickhouse"
        ],
        "package": "mcp-clickhouse",
        "description": "Install using pip",
        "recommended": false
      }
    },
    "examples": [
      {
        "title": "Run a SQL query",
        "description": "Execute a SQL query on your ClickHouse cluster",
        "prompt": "Run this SQL query: SELECT * FROM system.databases LIMIT 5"
      },
      {
        "title": "List databases",
        "description": "List all databases on your ClickHouse cluster",
        "prompt": "List all databases in my ClickHouse instance"
      },
      {
        "title": "List tables",
        "description": "List all tables in a specific database",
        "prompt": "Show me all tables in the system database"
      }
    ],
    "name": "mcp-clickhouse",
    "description": "An MCP server for ClickHouse.",
    "categories": [
      "Databases"
    ],
    "tools": [
      {
        "name": "list_databases",
        "description": "List available ClickHouse databases",
        "inputSchema": {
          "properties": {},
          "title": "list_databasesArguments",
          "type": "object"
        }
      },
      {
        "name": "list_tables",
        "description": "List available ClickHouse tables in a database",
        "inputSchema": {
          "properties": {
            "database": {
              "title": "Database",
              "type": "string"
            },
            "like": {
              "default": null,
              "title": "Like",
              "type": "string"
            }
          },
          "required": [
            "database"
          ],
          "title": "list_tablesArguments",
          "type": "object"
        }
      },
      {
        "name": "run_select_query",
        "description": "Run a SELECT query in a ClickHouse database",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "run_select_queryArguments",
          "type": "object"
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "aws-cost-explorer": {
    "name": "aws-cost-explorer",
    "display_name": "AWS Cost Explorer",
    "description": "Optimize your AWS spend (including Amazon Bedrock spend) with this MCP server by examining spend across regions, services, instance types and foundation models ([demo video](https://www.youtube.com/watch?v=WuVOmYLRFmI&feature=youtu.be)).",
    "repository": {
      "type": "git",
      "url": "https://github.com/aarora79/aws-cost-explorer-mcp-server"
    },
    "homepage": "https://github.com/aarora79/aws-cost-explorer-mcp-server",
    "author": {
      "name": "aarora79"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Cost Explorer",
      "Amazon Bedrock",
      "AWS"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--directory",
          "/path/to/aws-cost-explorer-mcp-server",
          "run",
          "server.py"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_REGION": "${AWS_REGION}",
          "BEDROCK_LOG_GROUP_NAME": "${BEDROCK_LOG_GROUP_NAME}",
          "MCP_TRANSPORT": "stdio"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "AWS_ACCESS_KEY_ID",
          "-e",
          "AWS_SECRET_ACCESS_KEY",
          "-e",
          "AWS_REGION",
          "-e",
          "BEDROCK_LOG_GROUP_NAME",
          "-e",
          "MCP_TRANSPORT",
          "aws-cost-explorer-mcp:latest"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_REGION": "${AWS_REGION}",
          "BEDROCK_LOG_GROUP_NAME": "${BEDROCK_LOG_GROUP_NAME}",
          "MCP_TRANSPORT": "stdio"
        }
      }
    },
    "examples": [
      {
        "title": "Get EC2 Spending",
        "description": "Retrieve the EC2 spending data for the previous day.",
        "prompt": "What was my EC2 spend yesterday?"
      },
      {
        "title": "Analyze Spending",
        "description": "Analyze spending by region for the past 14 days.",
        "prompt": "Analyze my spending by region for the past 14 days."
      },
      {
        "title": "Show Top Services",
        "description": "Show me my top 5 AWS services by cost for the last month.",
        "prompt": "Show me my top 5 AWS services by cost for the last month."
      }
    ],
    "arguments": {
      "AWS_ACCESS_KEY_ID": {
        "description": "Your AWS Access Key ID required for authenticating API calls to AWS services.",
        "required": true,
        "example": "AKIAIOSFODNN7EXAMPLE"
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "Your AWS Secret Access Key required alongside the Access Key ID for authentication.",
        "required": true,
        "example": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
      },
      "AWS_REGION": {
        "description": "The AWS region where your resources are located. Examples include 'us-east-1', 'eu-west-1'.",
        "required": true,
        "example": "us-east-1"
      },
      "BEDROCK_LOG_GROUP_NAME": {
        "description": "The name of the CloudWatch log group where Amazon Bedrock model invocation logs are stored.",
        "required": true,
        "example": "my-bedrock-log-group-name"
      }
    }
  },
  "meilisearch-mcp": {
    "display_name": "Meilisearch MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/meilisearch/meilisearch-mcp"
    },
    "homepage": "https://github.com/meilisearch/meilisearch-mcp",
    "author": {
      "name": "meilisearch"
    },
    "license": "MIT",
    "tags": [
      "search",
      "meilisearch",
      "indexing",
      "document management"
    ],
    "arguments": {
      "url": {
        "description": "Meilisearch instance URL",
        "required": false,
        "example": "http://localhost:7700"
      },
      "api_key": {
        "description": "Meilisearch API key",
        "required": false,
        "example": "your_master_key"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "-n",
          "meilisearch-mcp"
        ],
        "description": "Run the Meilisearch MCP server using uvx (for Claude Desktop)",
        "recommended": false
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "src.meilisearch_mcp"
        ],
        "env": {
          "MEILI_HTTP_ADDR": "http://localhost:7700",
          "MEILI_MASTER_KEY": "your_master_key"
        },
        "description": "Run the Meilisearch MCP server using Python",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Search in a specific index",
        "description": "Search for a term in a specific Meilisearch index",
        "prompt": "{\"name\": \"search\", \"arguments\": {\"query\": \"search term\", \"indexUid\": \"movies\", \"limit\": 10}}"
      },
      {
        "title": "Search across all indices",
        "description": "Search for a term across all Meilisearch indices",
        "prompt": "{\"name\": \"search\", \"arguments\": {\"query\": \"search term\", \"limit\": 5, \"sort\": [\"releaseDate:desc\"]}}"
      },
      {
        "title": "Update connection settings",
        "description": "Update the Meilisearch connection URL and API key",
        "prompt": "{\"name\": \"update-connection-settings\", \"arguments\": {\"url\": \"http://new-host:7700\", \"api_key\": \"new-api-key\"}}"
      }
    ],
    "name": "meilisearch-mcp",
    "description": "A Model Context Protocol (MCP) server for interacting with Meilisearch through LLM interfaces like Claude.",
    "categories": [
      "Databases"
    ],
    "tools": [
      {
        "name": "get-connection-settings",
        "description": "Get current Meilisearch connection settings",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "update-connection-settings",
        "description": "Update Meilisearch connection settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "optional": true
            },
            "api_key": {
              "type": "string",
              "optional": true
            }
          }
        }
      },
      {
        "name": "health-check",
        "description": "Check Meilisearch server health",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-version",
        "description": "Get Meilisearch version information",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-stats",
        "description": "Get database statistics",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create-index",
        "description": "Create a new Meilisearch index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "uid": {
              "type": "string"
            },
            "primaryKey": {
              "type": "string",
              "optional": true
            }
          },
          "required": [
            "uid"
          ]
        }
      },
      {
        "name": "list-indexes",
        "description": "List all Meilisearch indexes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-documents",
        "description": "Get documents from an index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "indexUid": {
              "type": "string"
            },
            "offset": {
              "type": "integer",
              "optional": true
            },
            "limit": {
              "type": "integer",
              "optional": true
            }
          },
          "required": [
            "indexUid"
          ]
        }
      },
      {
        "name": "add-documents",
        "description": "Add documents to an index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "indexUid": {
              "type": "string"
            },
            "documents": {
              "type": "array"
            },
            "primaryKey": {
              "type": "string",
              "optional": true
            }
          },
          "required": [
            "indexUid",
            "documents"
          ]
        }
      },
      {
        "name": "get-settings",
        "description": "Get current settings for an index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "indexUid": {
              "type": "string"
            }
          },
          "required": [
            "indexUid"
          ]
        }
      },
      {
        "name": "update-settings",
        "description": "Update settings for an index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "indexUid": {
              "type": "string"
            },
            "settings": {
              "type": "object"
            }
          },
          "required": [
            "indexUid",
            "settings"
          ]
        }
      },
      {
        "name": "search",
        "description": "Search through Meilisearch indices. If indexUid is not provided, it will search across all indices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            },
            "indexUid": {
              "type": "string",
              "optional": true
            },
            "limit": {
              "type": "integer",
              "optional": true
            },
            "offset": {
              "type": "integer",
              "optional": true
            },
            "filter": {
              "type": "string",
              "optional": true
            },
            "sort": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get-task",
        "description": "Get information about a specific task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskUid": {
              "type": "integer"
            }
          },
          "required": [
            "taskUid"
          ]
        }
      },
      {
        "name": "get-tasks",
        "description": "Get list of tasks with optional filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "optional": true
            },
            "from": {
              "type": "integer",
              "optional": true
            },
            "reverse": {
              "type": "boolean",
              "optional": true
            },
            "batchUids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "uids": {
              "type": "array",
              "items": {
                "type": "integer"
              },
              "optional": true
            },
            "canceledBy": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "types": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "statuses": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "indexUids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "afterEnqueuedAt": {
              "type": "string",
              "optional": true
            },
            "beforeEnqueuedAt": {
              "type": "string",
              "optional": true
            },
            "afterStartedAt": {
              "type": "string",
              "optional": true
            },
            "beforeStartedAt": {
              "type": "string",
              "optional": true
            },
            "afterFinishedAt": {
              "type": "string",
              "optional": true
            },
            "beforeFinishedAt": {
              "type": "string",
              "optional": true
            }
          }
        }
      },
      {
        "name": "cancel-tasks",
        "description": "Cancel tasks based on filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "uids": {
              "type": "string",
              "optional": true
            },
            "indexUids": {
              "type": "string",
              "optional": true
            },
            "types": {
              "type": "string",
              "optional": true
            },
            "statuses": {
              "type": "string",
              "optional": true
            }
          }
        }
      },
      {
        "name": "get-keys",
        "description": "Get list of API keys",
        "inputSchema": {
          "type": "object",
          "properties": {
            "offset": {
              "type": "integer",
              "optional": true
            },
            "limit": {
              "type": "integer",
              "optional": true
            }
          }
        }
      },
      {
        "name": "create-key",
        "description": "Create a new API key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "description": {
              "type": "string",
              "optional": true
            },
            "actions": {
              "type": "array"
            },
            "indexes": {
              "type": "array"
            },
            "expiresAt": {
              "type": "string",
              "optional": true
            }
          },
          "required": [
            "actions",
            "indexes"
          ]
        }
      },
      {
        "name": "delete-key",
        "description": "Delete an API key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string"
            }
          },
          "required": [
            "key"
          ]
        }
      },
      {
        "name": "get-health-status",
        "description": "Get comprehensive health status of Meilisearch",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-index-metrics",
        "description": "Get detailed metrics for an index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "indexUid": {
              "type": "string"
            }
          },
          "required": [
            "indexUid"
          ]
        }
      },
      {
        "name": "get-system-info",
        "description": "Get system-level information",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "actors-mcp-server": {
    "display_name": "Apify Model Context Protocol (MCP) Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/apify/actors-mcp-server"
    },
    "homepage": "https://apify.com/apify/actors-mcp-server",
    "author": {
      "name": "apify"
    },
    "license": "MIT",
    "tags": [
      "mcp",
      "model-context-protocol",
      "apify",
      "actors",
      "ai-agents"
    ],
    "arguments": {
      "APIFY_TOKEN": {
        "description": "Your Apify API token for authentication",
        "required": true,
        "example": "your-apify-token"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@apify/actors-mcp-server"
        ],
        "env": {
          "APIFY_TOKEN": "your-apify-token"
        },
        "description": "Install and run using NPM"
      }
    },
    "examples": [
      {
        "title": "Search for restaurants",
        "description": "Find top restaurants in San Francisco",
        "prompt": "Find top 10 best Italian restaurants in San Francisco."
      },
      {
        "title": "Instagram profile analysis",
        "description": "Analyze an Instagram profile",
        "prompt": "Find and analyze Instagram profile of The Rock."
      },
      {
        "title": "Web search and summarization",
        "description": "Search the web and summarize information",
        "prompt": "Search web and summarize recent trends about AI Agents."
      }
    ],
    "name": "actors-mcp-server",
    "description": "Implementation of an MCP server for all [Apify Actors](https://apify.com/store).",
    "categories": [
      "Web Services"
    ],
    "is_official": true
  },
  "cfbd-api": {
    "name": "cfbd-api",
    "display_name": "College Football Data API",
    "description": "An MCP server for the [College Football Data API](https://collegefootballdata.com/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/lenwood/cfbd-mcp-server"
    },
    "homepage": "https://github.com/lenwood/cfbd-mcp-server",
    "author": {
      "name": "lenwood"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "football",
      "college",
      "API",
      "statistics"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/lenwood/cfbd-mcp-server",
          "cfbd-mcp-server"
        ],
        "env": {
          "CFB_API_KEY": "${CFB_API_KEY}",
          "PATH": "${PATH}"
        }
      }
    },
    "examples": [
      {
        "title": "Get the largest upset among FCS games during the 2014 season",
        "description": "Query the server for significant game upsets in the 2014 college football season.",
        "prompt": "What was the largest upset among FCS games during the 2014 season?"
      }
    ],
    "arguments": {
      "CFB_API_KEY": {
        "description": "The API key required to authenticate requests to the College Football Data API.",
        "required": true,
        "example": "your_api_key_here"
      },
      "PATH": {
        "description": "Environment variable that specifies the path to the Python executable being used by the server.",
        "required": false,
        "example": "/full/path/to/python"
      }
    },
    "tools": [
      {
        "name": "get-games",
        "description": "Get college football game data. Required: year. Optional: week, season_type, team, conference, category, game_id.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the games"
            },
            "week": {
              "type": "integer",
              "description": "Week of the games"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            },
            "category": {
              "type": "string",
              "description": "Category of games"
            },
            "game_id": {
              "type": "integer",
              "description": "ID of the game"
            }
          },
          "required": [
            "year"
          ]
        }
      },
      {
        "name": "get-records",
        "description": "Get college football team record data. Optional: year, team, conference.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the records"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            }
          },
          "required": []
        }
      },
      {
        "name": "get-games-teams",
        "description": "Get college football team game data. Required: year plus at least one of: week, team or conference.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the games"
            },
            "week": {
              "type": "integer",
              "description": "Week of the games"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            }
          },
          "required": [
            "year"
          ]
        }
      },
      {
        "name": "get-plays",
        "description": "Get college football play-by-play data. Required: year AND week. Optional: season_type, team, offense, defense, conference, offense_conference, defense_conference, play_type, classification.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the plays"
            },
            "week": {
              "type": "integer",
              "description": "Week of the plays"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "offense": {
              "type": "string",
              "description": "Name of the offense team"
            },
            "defense": {
              "type": "string",
              "description": "Name of the defense team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            },
            "offense_conference": {
              "type": "string",
              "description": "Conference of the offense team"
            },
            "defense_conference": {
              "type": "string",
              "description": "Conference of the defense team"
            },
            "play_type": {
              "type": "string",
              "description": "Type of play"
            },
            "classification": {
              "type": "string",
              "description": "Classification of the play"
            }
          },
          "required": [
            "year",
            "week"
          ]
        }
      },
      {
        "name": "get-drives",
        "description": "Get college football drive data. Required: year. Optional: season_type, week, team, offense, defense, conference, offense_conference, defense_conference, classification.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the drives"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            },
            "week": {
              "type": "integer",
              "description": "Week of the drives"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "offense": {
              "type": "string",
              "description": "Name of the offense team"
            },
            "defense": {
              "type": "string",
              "description": "Name of the defense team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            },
            "offense_conference": {
              "type": "string",
              "description": "Conference of the offense team"
            },
            "defense_conference": {
              "type": "string",
              "description": "Conference of the defense team"
            },
            "classification": {
              "type": "string",
              "description": "Classification of the drive"
            }
          },
          "required": [
            "year"
          ]
        }
      },
      {
        "name": "get-play-stats",
        "description": "Get college football play statistic data. Optional: year, week, team, game_id, athlete_id, stat_type_id, season_type, conference. At least one parameter is required.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the statistics"
            },
            "week": {
              "type": "integer",
              "description": "Week of the statistics"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "game_id": {
              "type": "integer",
              "description": "ID of the game"
            },
            "athlete_id": {
              "type": "integer",
              "description": "ID of the athlete"
            },
            "stat_type_id": {
              "type": "integer",
              "description": "ID of the statistic type"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            }
          },
          "required": []
        }
      },
      {
        "name": "get-rankings",
        "description": "Get college football rankings data. Required: year. Optional: week, season_type.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the rankings"
            },
            "week": {
              "type": "integer",
              "description": "Week of the rankings"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            }
          },
          "required": [
            "year"
          ]
        }
      },
      {
        "name": "get-pregame-win-probability",
        "description": "Get college football pregame win probability data. Optional: year, week, team, season_type. At least one parameter is required.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the probabilities"
            },
            "week": {
              "type": "integer",
              "description": "Week of the probabilities"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            }
          },
          "required": []
        }
      },
      {
        "name": "get-advanced-box-score",
        "description": "Get advanced box score data for college football games. Required: gameId.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "gameId": {
              "type": "integer",
              "description": "ID of the game"
            }
          },
          "required": [
            "gameId"
          ]
        }
      }
    ]
  },
  "redis": {
    "name": "redis",
    "display_name": "Redis",
    "description": "MCP server to interact with Redis Server, AWS Memory DB, etc for caching or other use-cases where in-memory and key-value based storage is appropriate",
    "repository": {
      "type": "git",
      "url": "https://github.com/prajwalnayak7/mcp-server-redis"
    },
    "homepage": "https://github.com/prajwalnayak7/mcp-server-redis",
    "author": {
      "name": "prajwalnayak7"
    },
    "license": "MIT",
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/prajwalnayak7/mcp-server-redis",
          "src/server.py"
        ]
      }
    },
    "examples": [
      {
        "title": "Check Redis Connection Status",
        "description": "User requests the current Redis connection status.",
        "prompt": "What's the current Redis connection status?"
      },
      {
        "title": "Store Name in Redis",
        "description": "User wants to store their name in Redis.",
        "prompt": "Can you store my name \"Alice\" in Redis?"
      },
      {
        "title": "Verify Stored Name in Redis",
        "description": "User wants to verify the value stored in Redis.",
        "prompt": "Yes please verify it"
      }
    ],
    "categories": [
      "Databases"
    ]
  },
  "iterm-mcp": {
    "name": "iterm-mcp",
    "display_name": "iTerm",
    "description": "Integration with iTerm2 terminal emulator for macOS, enabling LLMs to execute and monitor terminal commands.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ferrislucas/iterm-mcp"
    },
    "homepage": "https://github.com/ferrislucas/iterm-mcp",
    "author": {
      "name": "ferrislucas"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "iTerm",
      "server",
      "automation"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "iterm-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "write_to_terminal",
        "description": "Writes text to the active iTerm terminal - often used to run a command in the terminal",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The command to run or text to write to the terminal"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "read_terminal_output",
        "description": "Reads the output from the active iTerm terminal",
        "inputSchema": {
          "type": "object",
          "properties": {
            "linesOfOutput": {
              "type": "number",
              "description": "The number of lines of output to read."
            }
          },
          "required": [
            "linesOfOutput"
          ]
        }
      },
      {
        "name": "send_control_character",
        "description": "Sends a control character to the active iTerm terminal (e.g., Control-C, or special sequences like ']' for telnet escape)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "letter": {
              "type": "string",
              "description": "The letter corresponding to the control character (e.g., 'C' for Control-C, ']' for telnet escape)"
            }
          },
          "required": [
            "letter"
          ]
        }
      }
    ]
  },
  "everything-search": {
    "name": "everything-search",
    "display_name": "Everything Search",
    "description": "Fast file searching capabilities across Windows (using [Everything SDK](https://www.voidtools.com/support/everything/sdk/)), macOS (using mdfind command), and Linux (using locate/plocate command).",
    "repository": {
      "type": "git",
      "url": "https://github.com/mamertofabian/mcp-everything-search"
    },
    "homepage": "https://github.com/mamertofabian/mcp-everything-search",
    "author": {
      "name": "mamertofabian"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "search",
      "everything"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-everything-search"
        ],
        "env": {
          "EVERYTHING_SDK_PATH": "${EVERYTHING_SDK_PATH}"
        }
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp_server_everything_search"
        ],
        "env": {
          "EVERYTHING_SDK_PATH": "${EVERYTHING_SDK_PATH}"
        }
      }
    },
    "examples": [
      {
        "title": "Search Python files",
        "description": "Search for all Python files in the system.",
        "prompt": "{\"query\": \"*.py\",\"max_results\": 50,\"sort_by\": 6}"
      },
      {
        "title": "Search files modified today",
        "description": "Find files with the .py extension that were modified today.",
        "prompt": "{\"query\": \"ext:py datemodified:today\",\"max_results\": 10}"
      }
    ],
    "arguments": {
      "EVERYTHING_SDK_PATH": {
        "description": "Environment variable that specifies the path to the Everything SDK DLL required for the server to function properly.",
        "required": true,
        "example": "path/to/Everything-SDK/dll/Everything64.dll"
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Universal file search tool for Darwin\n\nCurrent Implementation:\nUsing mdfind (Spotlight) with native macOS search capabilities\n\nSearch Syntax Guide:\nmacOS Spotlight (mdfind) Search Syntax:\n                \nBasic Usage:\n- Simple text search: Just type the words you're looking for\n- Phrase search: Use quotes (\"exact phrase\")\n- Filename search: -name \"filename\"\n- Directory scope: -onlyin /path/to/dir\n\nSpecial Parameters:\n- Live updates: -live\n- Literal search: -literal\n- Interpreted search: -interpret\n\nMetadata Attributes:\n- kMDItemDisplayName\n- kMDItemTextContent\n- kMDItemKind\n- kMDItemFSSize\n- And many more OS X metadata attributes\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base": {
              "description": "Base search parameters common to all platforms.",
              "properties": {
                "query": {
                  "description": "Search query string. See platform-specific documentation for syntax details.",
                  "title": "Query",
                  "type": "string"
                },
                "max_results": {
                  "default": 100,
                  "description": "Maximum number of results to return (1-1000)",
                  "maximum": 1000,
                  "minimum": 1,
                  "title": "Max Results",
                  "type": "integer"
                }
              },
              "required": [
                "query"
              ],
              "title": "BaseSearchQuery",
              "type": "object"
            },
            "mac_params": {
              "description": "macOS-specific search parameters for mdfind.",
              "properties": {
                "live_updates": {
                  "default": false,
                  "description": "Provide live updates to search results",
                  "title": "Live Updates",
                  "type": "boolean"
                },
                "search_directory": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Limit search to specific directory (-onlyin parameter)",
                  "title": "Search Directory"
                },
                "literal_query": {
                  "default": false,
                  "description": "Treat query as literal string without interpretation",
                  "title": "Literal Query",
                  "type": "boolean"
                },
                "interpret_query": {
                  "default": false,
                  "description": "Interpret query as if typed in Spotlight menu",
                  "title": "Interpret Query",
                  "type": "boolean"
                }
              },
              "title": "MacSpecificParams",
              "type": "object"
            }
          },
          "required": [
            "base"
          ]
        }
      }
    ]
  },
  "playwright-mcp": {
    "name": "mcp-playwright",
    "display_name": "Playwright",
    "description": "This MCP Server will help you run browser automation and webscraping using Playwright",
    "repository": {
      "type": "git",
      "url": "https://github.com/executeautomation/mcp-playwright"
    },
    "homepage": "https://github.com/executeautomation/mcp-playwright",
    "author": {
      "name": "executeautomation"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Playwright",
      "Browser Automation"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@executeautomation/playwright-mcp-server"
        ]
      }
    },
    "tools": [
      {
        "name": "start_codegen_session",
        "description": "Start a new code generation session to record Playwright actions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "options": {
              "type": "object",
              "description": "Code generation options",
              "properties": {
                "outputPath": {
                  "type": "string",
                  "description": "Directory path where generated tests will be saved (use absolute path)"
                },
                "testNamePrefix": {
                  "type": "string",
                  "description": "Prefix to use for generated test names (default: 'GeneratedTest')"
                },
                "includeComments": {
                  "type": "boolean",
                  "description": "Whether to include descriptive comments in generated tests"
                }
              },
              "required": [
                "outputPath"
              ]
            }
          },
          "required": [
            "options"
          ]
        }
      },
      {
        "name": "end_codegen_session",
        "description": "End a code generation session and generate the test file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "ID of the session to end"
            }
          },
          "required": [
            "sessionId"
          ]
        }
      },
      {
        "name": "get_codegen_session",
        "description": "Get information about a code generation session",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "ID of the session to retrieve"
            }
          },
          "required": [
            "sessionId"
          ]
        }
      },
      {
        "name": "clear_codegen_session",
        "description": "Clear a code generation session without generating a test",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "ID of the session to clear"
            }
          },
          "required": [
            "sessionId"
          ]
        }
      },
      {
        "name": "playwright_navigate",
        "description": "Navigate to a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to navigate to the website specified"
            },
            "browserType": {
              "type": "string",
              "description": "Browser type to use (chromium, firefox, webkit). Defaults to chromium",
              "enum": [
                "chromium",
                "firefox",
                "webkit"
              ]
            },
            "width": {
              "type": "number",
              "description": "Viewport width in pixels (default: 1280)"
            },
            "height": {
              "type": "number",
              "description": "Viewport height in pixels (default: 720)"
            },
            "timeout": {
              "type": "number",
              "description": "Navigation timeout in milliseconds"
            },
            "waitUntil": {
              "type": "string",
              "description": "Navigation wait condition"
            },
            "headless": {
              "type": "boolean",
              "description": "Run browser in headless mode (default: false)"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "playwright_screenshot",
        "description": "Take a screenshot of the current page or a specific element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the screenshot"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector for element to screenshot"
            },
            "width": {
              "type": "number",
              "description": "Width in pixels (default: 800)"
            },
            "height": {
              "type": "number",
              "description": "Height in pixels (default: 600)"
            },
            "storeBase64": {
              "type": "boolean",
              "description": "Store screenshot in base64 format (default: true)"
            },
            "fullPage": {
              "type": "boolean",
              "description": "Store screenshot of the entire page (default: false)"
            },
            "savePng": {
              "type": "boolean",
              "description": "Save screenshot as PNG file (default: false)"
            },
            "downloadsDir": {
              "type": "string",
              "description": "Custom downloads directory path (default: user's Downloads folder)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "playwright_click",
        "description": "Click an element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for the element to click"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "playwright_iframe_click",
        "description": "Click an element in an iframe on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "iframeSelector": {
              "type": "string",
              "description": "CSS selector for the iframe containing the element to click"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector for the element to click"
            }
          },
          "required": [
            "iframeSelector",
            "selector"
          ]
        }
      },
      {
        "name": "playwright_fill",
        "description": "fill out an input field",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for input field"
            },
            "value": {
              "type": "string",
              "description": "Value to fill"
            }
          },
          "required": [
            "selector",
            "value"
          ]
        }
      },
      {
        "name": "playwright_select",
        "description": "Select an element on the page with Select tag",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to select"
            },
            "value": {
              "type": "string",
              "description": "Value to select"
            }
          },
          "required": [
            "selector",
            "value"
          ]
        }
      },
      {
        "name": "playwright_hover",
        "description": "Hover an element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to hover"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "playwright_evaluate",
        "description": "Execute JavaScript in the browser console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "script": {
              "type": "string",
              "description": "JavaScript code to execute"
            }
          },
          "required": [
            "script"
          ]
        }
      },
      {
        "name": "playwright_console_logs",
        "description": "Retrieve console logs from the browser with filtering options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Type of logs to retrieve (all, error, warning, log, info, debug)",
              "enum": [
                "all",
                "error",
                "warning",
                "log",
                "info",
                "debug"
              ]
            },
            "search": {
              "type": "string",
              "description": "Text to search for in logs (handles text with square brackets)"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of logs to return"
            },
            "clear": {
              "type": "boolean",
              "description": "Whether to clear logs after retrieval (default: false)"
            }
          },
          "required": []
        }
      },
      {
        "name": "playwright_close",
        "description": "Close the browser and release all resources",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_get",
        "description": "Perform an HTTP GET request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform GET operation"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "playwright_post",
        "description": "Perform an HTTP POST request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform POST operation"
            },
            "value": {
              "type": "string",
              "description": "Data to post in the body"
            },
            "token": {
              "type": "string",
              "description": "Bearer token for authorization"
            },
            "headers": {
              "type": "object",
              "description": "Additional headers to include in the request",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "required": [
            "url",
            "value"
          ]
        }
      },
      {
        "name": "playwright_put",
        "description": "Perform an HTTP PUT request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform PUT operation"
            },
            "value": {
              "type": "string",
              "description": "Data to PUT in the body"
            }
          },
          "required": [
            "url",
            "value"
          ]
        }
      },
      {
        "name": "playwright_patch",
        "description": "Perform an HTTP PATCH request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform PUT operation"
            },
            "value": {
              "type": "string",
              "description": "Data to PATCH in the body"
            }
          },
          "required": [
            "url",
            "value"
          ]
        }
      },
      {
        "name": "playwright_delete",
        "description": "Perform an HTTP DELETE request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform DELETE operation"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "playwright_expect_response",
        "description": "Ask Playwright to start waiting for a HTTP response. This tool initiates the wait operation but does not wait for its completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique & arbitrary identifier to be used for retrieving this response later with `Playwright_assert_response`."
            },
            "url": {
              "type": "string",
              "description": "URL pattern to match in the response."
            }
          },
          "required": [
            "id",
            "url"
          ]
        }
      },
      {
        "name": "playwright_assert_response",
        "description": "Wait for and validate a previously initiated HTTP response wait operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Identifier of the HTTP response initially expected using `Playwright_expect_response`."
            },
            "value": {
              "type": "string",
              "description": "Data to expect in the body of the HTTP response. If provided, the assertion will fail if this value is not found in the response body."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "playwright_custom_user_agent",
        "description": "Set a custom User Agent for the browser",
        "inputSchema": {
          "type": "object",
          "properties": {
            "userAgent": {
              "type": "string",
              "description": "Custom User Agent for the Playwright browser instance"
            }
          },
          "required": [
            "userAgent"
          ]
        }
      },
      {
        "name": "playwright_get_visible_text",
        "description": "Get the visible text content of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_get_visible_html",
        "description": "Get the HTML content of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_go_back",
        "description": "Navigate back in browser history",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_go_forward",
        "description": "Navigate forward in browser history",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_drag",
        "description": "Drag an element to a target location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sourceSelector": {
              "type": "string",
              "description": "CSS selector for the element to drag"
            },
            "targetSelector": {
              "type": "string",
              "description": "CSS selector for the target location"
            }
          },
          "required": [
            "sourceSelector",
            "targetSelector"
          ]
        }
      },
      {
        "name": "playwright_press_key",
        "description": "Press a keyboard key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Key to press (e.g. 'Enter', 'ArrowDown', 'a')"
            },
            "selector": {
              "type": "string",
              "description": "Optional CSS selector to focus before pressing key"
            }
          },
          "required": [
            "key"
          ]
        }
      },
      {
        "name": "playwright_save_as_pdf",
        "description": "Save the current page as a PDF file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "outputPath": {
              "type": "string",
              "description": "Directory path where PDF will be saved"
            },
            "filename": {
              "type": "string",
              "description": "Name of the PDF file (default: page.pdf)"
            },
            "format": {
              "type": "string",
              "description": "Page format (e.g. 'A4', 'Letter')"
            },
            "printBackground": {
              "type": "boolean",
              "description": "Whether to print background graphics"
            },
            "margin": {
              "type": "object",
              "description": "Page margins",
              "properties": {
                "top": {
                  "type": "string"
                },
                "right": {
                  "type": "string"
                },
                "bottom": {
                  "type": "string"
                },
                "left": {
                  "type": "string"
                }
              }
            }
          },
          "required": [
            "outputPath"
          ]
        }
      }
    ]
  },
  "chroma": {
    "name": "chroma",
    "display_name": "Chroma",
    "description": "Vector database server for semantic document search and metadata filtering, built on Chroma",
    "repository": {
      "type": "git",
      "url": "https://github.com/privetin/chroma"
    },
    "homepage": "https://github.com/privetin/chroma",
    "author": {
      "name": "privetin"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "vector database",
      "semantic search"
    ],
    "examples": [
      {
        "title": "Create a document",
        "description": "Creates a new document with specified content and metadata.",
        "prompt": "create_document({\"document_id\": \"ml_paper1\", \"content\": \"Convolutional neural networks improve image recognition accuracy.\", \"metadata\": {\"year\": 2020, \"field\": \"computer vision\", \"complexity\": \"advanced\"}})"
      },
      {
        "title": "Search similar documents",
        "description": "Finds documents semantically similar to a given query.",
        "prompt": "search_similar({\"query\": \"machine learning models\", \"num_results\": 2, \"metadata_filter\": {\"year\": 2020, \"field\": \"computer vision\"}})"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/privetin/chroma",
          "chroma"
        ]
      }
    },
    "tools": [
      {
        "name": "create_document",
        "description": "Create a new document in the Chroma vector database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "document_id": {
              "type": "string"
            },
            "content": {
              "type": "string"
            },
            "metadata": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "required": [
            "document_id",
            "content"
          ]
        }
      },
      {
        "name": "read_document",
        "description": "Retrieve a document from the Chroma vector database by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "document_id": {
              "type": "string"
            }
          },
          "required": [
            "document_id"
          ]
        }
      },
      {
        "name": "update_document",
        "description": "Update an existing document in the Chroma vector database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "document_id": {
              "type": "string"
            },
            "content": {
              "type": "string"
            },
            "metadata": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "required": [
            "document_id",
            "content"
          ]
        }
      },
      {
        "name": "delete_document",
        "description": "Delete a document from the Chroma vector database by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "document_id": {
              "type": "string"
            }
          },
          "required": [
            "document_id"
          ]
        }
      },
      {
        "name": "list_documents",
        "description": "List all documents stored in the Chroma vector database with pagination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 10
            },
            "offset": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        }
      },
      {
        "name": "search_similar",
        "description": "Search for semantically similar documents in the Chroma vector database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            },
            "num_results": {
              "type": "integer",
              "minimum": 1,
              "default": 5
            },
            "metadata_filter": {
              "type": "object",
              "additionalProperties": true
            },
            "content_filter": {
              "type": "string"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "fetch-mcp": {
    "name": "fetch-mcp",
    "display_name": "Fetch",
    "description": "A server that flexibly fetches HTML, JSON, Markdown, or plaintext.",
    "repository": {
      "type": "git",
      "url": "https://github.com/zcaceres/fetch-mcp"
    },
    "homepage": "https://github.com/zcaceres/fetch-mcp",
    "author": {
      "name": "zcaceres"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "fetch",
      "web",
      "api",
      "html",
      "json",
      "markdown",
      "plain text"
    ],
    "examples": [
      {
        "title": "Fetch HTML",
        "description": "Fetch a website and return the content as HTML",
        "prompt": "fetch_html(url: string, headers?: object) -> string"
      },
      {
        "title": "Fetch JSON",
        "description": "Fetch a JSON file from a URL",
        "prompt": "fetch_json(url: string, headers?: object) -> object"
      },
      {
        "title": "Fetch Plain Text",
        "description": "Fetch a website and return the content as plain text",
        "prompt": "fetch_txt(url: string, headers?: object) -> string"
      },
      {
        "title": "Fetch Markdown",
        "description": "Fetch a website and return the content as Markdown",
        "prompt": "fetch_markdown(url: string, headers?: object) -> string"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/zcaceres/fetch-mcp"
        ]
      }
    },
    "arguments": {
      "url": {
        "description": "URL of the website to fetch",
        "required": true,
        "example": "https://example.com"
      },
      "headers": {
        "description": "Custom headers to include in the request",
        "required": false,
        "example": "{\"Authorization\": \"Bearer token\"}"
      }
    },
    "tools": [
      {
        "name": "fetch_html",
        "description": "Fetch a website and return the content as HTML",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the website to fetch"
            },
            "headers": {
              "type": "object",
              "description": "Optional headers to include in the request"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "fetch_markdown",
        "description": "Fetch a website and return the content as Markdown",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the website to fetch"
            },
            "headers": {
              "type": "object",
              "description": "Optional headers to include in the request"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "fetch_txt",
        "description": "Fetch a website, return the content as plain text (no HTML)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the website to fetch"
            },
            "headers": {
              "type": "object",
              "description": "Optional headers to include in the request"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "fetch_json",
        "description": "Fetch a JSON file from a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the JSON to fetch"
            },
            "headers": {
              "type": "object",
              "description": "Optional headers to include in the request"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  "kubernetes": {
    "name": "kubernetes",
    "display_name": "Kubernetes",
    "description": "Connect to Kubernetes cluster and manage pods, deployments, and services.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Flux159/mcp-server-kubernetes"
    },
    "homepage": "https://github.com/Flux159/mcp-server-kubernetes",
    "author": {
      "name": "Flux159"
    },
    "license": "[NOT FOUND]",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "kubernetes",
      "server",
      "management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-server-kubernetes"
        ]
      }
    },
    "tools": [
      {
        "name": "cleanup",
        "description": "Cleanup all managed resources",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_deployment",
        "description": "Create a new Kubernetes deployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "template": {
              "type": "string",
              "enum": [
                "ubuntu",
                "nginx",
                "busybox",
                "alpine",
                "custom"
              ]
            },
            "replicas": {
              "type": "number",
              "default": 1
            },
            "ports": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "optional": true
            },
            "customConfig": {
              "type": "object",
              "optional": true,
              "properties": {
                "image": {
                  "type": "string"
                },
                "command": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "args": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ports": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "containerPort": {
                        "type": "number"
                      },
                      "name": {
                        "type": "string"
                      },
                      "protocol": {
                        "type": "string"
                      }
                    }
                  }
                },
                "resources": {
                  "type": "object",
                  "properties": {
                    "limits": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "requests": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "env": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      },
                      "valueFrom": {
                        "type": "object"
                      }
                    }
                  }
                },
                "volumeMounts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "mountPath": {
                        "type": "string"
                      },
                      "readOnly": {
                        "type": "boolean"
                      }
                    }
                  }
                }
              }
            }
          },
          "required": [
            "name",
            "namespace",
            "template"
          ]
        }
      },
      {
        "name": "create_namespace",
        "description": "Create a new Kubernetes namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create_pod",
        "description": "Create a new Kubernetes pod",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "template": {
              "type": "string",
              "enum": [
                "ubuntu",
                "nginx",
                "busybox",
                "alpine",
                "custom"
              ]
            },
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "customConfig": {
              "type": "object",
              "optional": true,
              "properties": {
                "image": {
                  "type": "string"
                },
                "command": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "args": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ports": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "containerPort": {
                        "type": "number"
                      },
                      "name": {
                        "type": "string"
                      },
                      "protocol": {
                        "type": "string"
                      }
                    }
                  }
                },
                "resources": {
                  "type": "object",
                  "properties": {
                    "limits": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "requests": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "env": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      },
                      "valueFrom": {
                        "type": "object"
                      }
                    }
                  }
                },
                "volumeMounts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "mountPath": {
                        "type": "string"
                      },
                      "readOnly": {
                        "type": "boolean"
                      }
                    }
                  }
                }
              }
            }
          },
          "required": [
            "name",
            "namespace",
            "template"
          ]
        }
      },
      {
        "name": "create_cronjob",
        "description": "Create a new Kubernetes CronJob",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "schedule": {
              "type": "string"
            },
            "image": {
              "type": "string"
            },
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "suspend": {
              "type": "boolean",
              "optional": true
            }
          },
          "required": [
            "name",
            "namespace",
            "schedule",
            "image"
          ]
        }
      },
      {
        "name": "delete_pod",
        "description": "Delete a Kubernetes pod",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "ignoreNotFound": {
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "describe_cronjob",
        "description": "Get detailed information about a Kubernetes CronJob including recent job history",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "describe_pod",
        "description": "Describe a Kubernetes pod (read details like status, containers, etc.)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "describe_deployment",
        "description": "Get details about a Kubernetes deployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "explain_resource",
        "description": "Get documentation for a Kubernetes resource or field",
        "inputSchema": {
          "type": "object",
          "properties": {
            "resource": {
              "type": "string",
              "description": "Resource name or field path (e.g. 'pods' or 'pods.spec.containers')"
            },
            "apiVersion": {
              "type": "string",
              "description": "API version to use (e.g. 'apps/v1')"
            },
            "recursive": {
              "type": "boolean",
              "description": "Print the fields of fields recursively",
              "default": false
            },
            "output": {
              "type": "string",
              "description": "Output format (plaintext or plaintext-openapiv2)",
              "enum": [
                "plaintext",
                "plaintext-openapiv2"
              ],
              "default": "plaintext"
            }
          },
          "required": [
            "resource"
          ]
        }
      },
      {
        "name": "get_events",
        "description": "Get Kubernetes events from the cluster",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "description": "Namespace to get events from. If not specified, gets events from all namespaces"
            },
            "fieldSelector": {
              "type": "string",
              "description": "Field selector to filter events"
            }
          },
          "required": []
        }
      },
      {
        "name": "get_job_logs",
        "description": "Get logs from Pods created by a specific Job",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the Job to get logs from"
            },
            "namespace": {
              "type": "string",
              "default": "default"
            },
            "tail": {
              "type": "number",
              "description": "Number of lines to return from the end of the logs",
              "optional": true
            },
            "timestamps": {
              "type": "boolean",
              "description": "Include timestamps in the logs",
              "optional": true
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "get_logs",
        "description": "Get logs from pods, deployments, jobs, or resources matching a label selector",
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourceType": {
              "type": "string",
              "enum": [
                "pod",
                "deployment",
                "job"
              ],
              "description": "Type of resource to get logs from"
            },
            "name": {
              "type": "string",
              "description": "Name of the resource"
            },
            "namespace": {
              "type": "string",
              "description": "Namespace of the resource",
              "default": "default"
            },
            "labelSelector": {
              "type": "string",
              "description": "Label selector to filter resources",
              "optional": true
            },
            "container": {
              "type": "string",
              "description": "Container name (required when pod has multiple containers)",
              "optional": true
            },
            "tail": {
              "type": "number",
              "description": "Number of lines to show from end of logs",
              "optional": true
            },
            "since": {
              "type": "number",
              "description": "Get logs since relative time in seconds",
              "optional": true
            },
            "timestamps": {
              "type": "boolean",
              "description": "Include timestamps in logs",
              "default": false
            }
          },
          "required": [
            "resourceType"
          ]
        }
      },
      {
        "name": "install_helm_chart",
        "description": "Install a Helm chart",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Release name"
            },
            "chart": {
              "type": "string",
              "description": "Chart name"
            },
            "repo": {
              "type": "string",
              "description": "Chart repository URL"
            },
            "namespace": {
              "type": "string",
              "description": "Kubernetes namespace"
            },
            "values": {
              "type": "object",
              "description": "Chart values",
              "additionalProperties": true
            }
          },
          "required": [
            "name",
            "chart",
            "repo",
            "namespace"
          ]
        }
      },
      {
        "name": "list_api_resources",
        "description": "List the API resources available in the cluster",
        "inputSchema": {
          "type": "object",
          "properties": {
            "apiGroup": {
              "type": "string",
              "description": "API group to filter by"
            },
            "namespaced": {
              "type": "boolean",
              "description": "If true, only show namespaced resources"
            },
            "verbs": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of verbs to filter by"
            },
            "output": {
              "type": "string",
              "description": "Output format (wide, name, or no-headers)",
              "enum": [
                "wide",
                "name",
                "no-headers"
              ],
              "default": "wide"
            }
          }
        }
      },
      {
        "name": "list_cronjobs",
        "description": "List CronJobs in a namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "list_deployments",
        "description": "List deployments in a namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "list_jobs",
        "description": "List Jobs in a namespace, optionally filtered by a CronJob parent",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            },
            "cronJobName": {
              "type": "string",
              "description": "Optional: Filter jobs created by a specific CronJob",
              "optional": true
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "list_namespaces",
        "description": "List all namespaces",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_nodes",
        "description": "List all nodes in the cluster",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_pods",
        "description": "List pods in a namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "list_services",
        "description": "List services in a namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "uninstall_helm_chart",
        "description": "Uninstall a Helm release",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Release name"
            },
            "namespace": {
              "type": "string",
              "description": "Kubernetes namespace"
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "upgrade_helm_chart",
        "description": "Upgrade a Helm release",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Release name"
            },
            "chart": {
              "type": "string",
              "description": "Chart name"
            },
            "repo": {
              "type": "string",
              "description": "Chart repository URL"
            },
            "namespace": {
              "type": "string",
              "description": "Kubernetes namespace"
            },
            "values": {
              "type": "object",
              "description": "Chart values",
              "additionalProperties": true
            }
          },
          "required": [
            "name",
            "chart",
            "repo",
            "namespace"
          ]
        }
      },
      {
        "name": "port_forward",
        "description": "Forward a local port to a port on a Kubernetes resource",
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourceType": {
              "type": "string"
            },
            "resourceName": {
              "type": "string"
            },
            "localPort": {
              "type": "number"
            },
            "targetPort": {
              "type": "number"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "resourceType",
            "resourceName",
            "localPort",
            "targetPort"
          ]
        }
      },
      {
        "name": "stop_port_forward",
        "description": "Stop a port-forward process",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "scale_deployment",
        "description": "Scale a Kubernetes deployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "replicas": {
              "type": "number"
            }
          },
          "required": [
            "name",
            "namespace",
            "replicas"
          ]
        }
      }
    ]
  },
  "fibery-mcp-server": {
    "display_name": "Fibery MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/Fibery-inc/fibery-mcp-server"
    },
    "homepage": "[NOT GIVEN]",
    "author": {
      "name": "Fibery-inc"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "fibery",
      "mcp",
      "llm"
    ],
    "arguments": {
      "fibery-host": {
        "description": "Your Fibery domain (e.g., your-domain.fibery.io)",
        "required": true,
        "example": "your-domain.fibery.io"
      },
      "fibery-api-token": {
        "description": "Your Fibery API token",
        "required": true,
        "example": "your-api-token"
      }
    },
    "installations": {
      "uv": {
        "type": "uvx",
        "command": "uv",
        "args": [
          "tool",
          "run",
          "fibery-mcp-server",
          "--fibery-host",
          "your-domain.fibery.io",
          "--fibery-api-token",
          "your-api-token"
        ],
        "package": "fibery-mcp-server",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "List Databases",
        "description": "Retrieves a list of all databases available in your Fibery workspace.",
        "prompt": "What databases do I have in my Fibery workspace?"
      },
      {
        "title": "Describe Database",
        "description": "Provides a detailed breakdown of a specific database's structure, showing all fields with their titles, names, and types.",
        "prompt": "Tell me about the structure of my Tasks database"
      },
      {
        "title": "Query Database",
        "description": "Offers powerful, flexible access to your Fibery data through the Fibery API.",
        "prompt": "Find all high priority tasks that are due this week"
      },
      {
        "title": "Create Entity",
        "description": "Creates new entities in your Fibery workspace with specified field values.",
        "prompt": "Create a new task called 'Review project proposal' with high priority"
      },
      {
        "title": "Update Entity",
        "description": "Updates existing entities in your Fibery workspace with new field values.",
        "prompt": "Change the status of task 'Review project proposal' to 'In Progress'"
      }
    ],
    "name": "fibery-mcp-server",
    "description": "This MCP (Model Context Protocol) server provides integration between Fibery and any LLM provider supporting the MCP protocol (e.g., Claude for Desktop), allowing you to interact with your Fibery workspace using natural language.",
    "categories": [
      "Productivity"
    ],
    "tools": [
      {
        "name": "current_date",
        "description": "Get today's date in ISO 8601 format (YYYY-mm-dd.HH:MM:SS.000Z)",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "list_databases",
        "description": "Get list of all databases (their names) in user's Fibery workspace (schema)",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "describe_database",
        "description": "Get list of all fields (in format of 'Title [name]: type') in the selected Fibery database and for all related databases.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database_name": {
              "type": "string",
              "description": "Database name as defined in Fibery schema"
            }
          },
          "required": [
            "database_name"
          ]
        }
      },
      {
        "name": "query_database",
        "description": "Run any Fibery API command. This gives tremendous flexibility, but requires a bit of experience with the low-level Fibery API. In case query succeeded, return value contains a list of records with fields you specified in select. If request failed, will return detailed error message.\nExamples (note, that these databases are non-existent, use databases only from user's schema!):\nQuery: What newly created Features do we have for the past 2 months?\nTool use:\n{\n    \"q_from\": \"Dev/Feature\",\n    \"q_select\": {\n        \"Name\": [\"Dev/Name\"],\n        \"Public Id\": [\"fibery/public-id\"],\n        \"Creation Date\": [\"fibery/creation-date\"]\n    },\n    \"q_where\": [\">\", [\"fibery/creation-date\"], \"$twoMonthsAgo\"],\n    \"q_order_by\": {\"fibery/creation-date\": \"q/desc\"},\n    \"q_limit\": 100,\n    \"q_offset\": 0,\n    \"q_params\": {\n        $twoMonthsAgo: \"2025-01-16T00:00:00.000Z\"\n    }\n}\n\nQuery: What Admin Tasks for the past week are Approval or Done?\nTool use:\n{\n    \"q_from\": \"Administrative/Admin Task\",\n    \"q_select\": {\n        \"Name\": [\"Administrative/Name\"],\n        \"Public Id\": [\"fibery/public-id\"],\n        \"Creation Date\": [\"fibery/creation-date\"],\n        \"State\": [\"workflow/state\", \"enum/name\"]\n    },\n    \"q_where\": [\n        \"q/and\", # satisfy time AND states condition\n            [\">\", [\"fibery/creation-date\"], \"$oneWeekAgo\"],\n            [\n                \"q/or\", # nested or, since entity can be in either of these states\n                    [\"=\", [\"workflow/state\", \"enum/name\"], \"$state1\"],\n                    [\"=\", [\"workflow/state\", \"enum/name\"], \"$state2\"]\n            ]\n    ],\n    \"q_order_by\": {\"fibery/creation-date\": \"q/desc\"},\n    \"q_limit\": 100,\n    \"q_offset\": 0,\n    \"q_params\": { # notice that parameters used in \"where\" are always passed in params!\n        $oneWeekAgo: \"2025-03-07T00:00:00.000Z\",\n        $state1: \"Approval\",\n        $state2: \"Done\"\n    }\n}\n\nQuery: What Admin Tasks for the past week are Approval or Done?\nTool use:\n{\n    \"q_from\": \"Administrative/Admin Task\",\n    \"q_select\": {\n        \"State\": [\"workflow/state\", \"enum/name\"],\n        \"Public Id\": [\"fibery/public-id\"],\n        \"Creation Date\": [\"fibery/creation-date\"],\n        \"Modification Date\": [\"fibery/modification-date\"],\n        \"Deadline\": [\"Administrative/Deadline\"],\n        \"Group\": [\"Administrative/Group\", \"Administrative/name\"],\n        \"Name\": [\"Administrative/Name\"],\n        \"Priority\": [\"Administrative/Priority_Administrative/Admin Task\", \"enum/name\"]\n    },\n    \"q_where\": [\"!=\", [\"workflow/state\", \"workflow/Final\"], \"$stateType\"], # Administrative/Admin Task is not \"Finished\" yet\n    \"q_order_by\": {\"fibery/creation-date\": \"q/desc\"},\n    \"q_limit\": 100,\n    \"q_offset\": 0,\n    \"q_params: {\n        \"$stateType\": true\n    }\n}\n\nQuery: Summarize acc contacts with public id 1.\nTool use:\n{\n    \"q_from\": \"Accounting/Acc Contacts\",\n    \"q_select\": {\n        \"Name\": [\"Accounting/Name\"],\n        \"Public Id\": [\"fibery/public-id\"],\n        \"Creation Date\": [\"fibery/creation-date\"],\n        \"Description\": [\"Accounting/Description\"]\n    },\n    \"q_where\": [\"=\", [\"fibery/public-id\"], \"$publicId\"],\n    \"q_limit\": 1,\n    \"q_params\": {\n        $publicId: \"1\",\n    }\n}",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q_from": {
              "type": "string",
              "description": "Specifies the entity type in \"Space/Type\" format (e.g., \"Product Management/feature\", \"Product Management/Insight\")"
            },
            "q_select": {
              "type": "object",
              "description": "Defines what fields to retrieve. Can include:\n  - Primitive fields using format {\"AliasName\": \"FieldName\"} (i.e. {\"Name\": \"Product Management/Name\"})\n  - Related entity fields using format {\"AliasName\": [\"Related entity\", \"related entity field\"]} (i.e. {\"Secret\": [\"Product Management/Description\", \"Collaboration~Documents/secret\"]}). Careful, does not work with 1-* connection!\nTo work with 1-* relationships, you can use sub-querying: {\"AliasName\": {\"q/from\": \"Related type\", \"q/select\": {\"AliasName 2\": \"fibery/id\"}, \"q/limit\": 50}}\nAliasName can be of any arbitrary value."
            },
            "q_where": {
              "type": "object",
              "description": "Filter conditions in format [operator, [field_path], value] or [\"q/and\"|\"q/or\", ...conditions]. Common usages:\n- Simple comparison: [\"=\", [\"field\", \"path\"], \"$param\"]. You cannot pass value of $param directly in where clause. Use params object instead. Pay really close attention to it as it is not common practice, but that's how it works in our case!\n- Logical combinations: [\"q/and\", [\"<\", [\"field1\"], \"$param1\"], [\"=\", [\"field2\"], \"$param2\"]]\n- Available operators: =, !=, <, <=, >, >=, q/contains, q/not-contains, q/in, q/not-in"
            },
            "q_order_by": {
              "type": "object",
              "description": "List of sorting criteria in format {\"field1\": \"q/asc\", \"field2\": \"q/desc\"}"
            },
            "q_limit": {
              "type": "integer",
              "description": "Number of results per page (defaults to 50). Maximum allowed value is 1000"
            },
            "q_offset": {
              "type": "integer",
              "description": "Number of results to skip. Mainly used in combination with limit and orderBy for pagination."
            },
            "q_params": {
              "type": "object",
              "description": "Dictionary of parameter values referenced in where using \"$param\" syntax. For example, {$fromDate: \"2025-01-01\"}"
            }
          },
          "required": [
            "q_from",
            "q_select"
          ]
        }
      },
      {
        "name": "create_entity",
        "description": "Create Fibery entity with specified fields.\nExamples (note, that these databases are non-existent, use databases only from user's schema!):\nQuery: Create a feature\nTool use:\n{\n    \"database\": \"Product Management/Feature\",\n    \"entity\": {\n        \"Product Management/Name\": \"New Feature\",\n        \"Product Management/Description\": \"Description of the new feature\",\n        \"workflow/state\": \"To Do\"\n    }\n}\nIn case of successful execution, you will get a link to created entity. Make sure to give that link to the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "description": "Fibery Database where to create an entity."
            },
            "entity": {
              "type": "object",
              "description": "Dictionary that defines what fields to set in format {\"FieldName\": value} (i.e. {\"Product Management/Name\": \"My new entity\"})."
            }
          },
          "required": [
            "database",
            "entity"
          ]
        }
      },
      {
        "name": "update_entity",
        "description": "Update Fibery entity with specified fields.\nExamples (note, that these databases are non-existent, use databases only from user's schema!):\nQuery: Update a feature we talked about\nTool use:\n{\n    \"database\": \"Product Management/Feature\",\n    \"entity\": {\n        \"fibery/id\": \"12345678-1234-5678-1234-567812345678\",\n        \"Product Management/Name\": \"New Feature 2\",\n        \"Product Management/Description\": {\"append\": true, \"content\": \"Notes: some notes\"},\n        \"workflow/state\": \"In Progress\"\n    }\n}\nIn case of successful execution, you will get a link to updated entity. Make sure to give that link to the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "description": "Fibery Database where to update an entity."
            },
            "entity": {
              "type": "object",
              "description": "Dictionary that defines what fields to set in format {\"FieldName\": value} (i.e. {\"Product Management/Name\": \"My new entity\"}).\nException are document fields. For them you must specify append (boolean, whether to append to current content) and content itself: {\"Product Management/Description\": {\"append\": true, \"content\": \"Additional info\"}}"
            }
          },
          "required": [
            "database",
            "entity"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "unifai-mcp-server": {
    "display_name": "UnifAI MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/unifai-network/unifai-mcp-server"
    },
    "license": "MIT",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "-p",
          "unifai-sdk",
          "unifai-tools-mcp"
        ],
        "env": {
          "UNIFAI_AGENT_API_KEY": "${UNIFAI_AGENT_API_KEY}"
        },
        "description": "Available in UnifAI Node SDK"
      },
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "unifai-sdk",
          "unifai-tools-mcp"
        ],
        "env": {
          "UNIFAI_AGENT_API_KEY": "${UNIFAI_AGENT_API_KEY}"
        },
        "description": "Available in UnifAI Python SDK"
      }
    },
    "homepage": "https://github.com/unifai-network/unifai-mcp-server",
    "author": {
      "name": "unifai-network"
    },
    "arguments": {
      "UNIFAI_AGENT_API_KEY": {
        "description": "UnifAI Agent API Key for authentication",
        "required": true,
        "example": "<UNIFAI_AGENT_API_KEY>"
      }
    },
    "tags": [
      "unifai",
      "mcp"
    ],
    "name": "unifai-mcp-server",
    "description": "Dynamically search and call tools using UnifAI Network",
    "categories": [
      "MCP Tools"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "search_services",
        "description": "Search for tools. The tools cover a wide range of domains include data source, API, SDK, etc. Try searching whenever you need to use a tool. Returned actions should ONLY be used in invoke_service.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to search for tools, you can describe what you want to do or what tools you want to use"
            },
            "limit": {
              "type": "number",
              "description": "The maximum number of tools to return, must be between 1 and 100, default is 10, recommend at least 10"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "invoke_service",
        "description": "Call a tool returned by search_services",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "string",
              "description": "The exact action you want to call in the search_services result."
            },
            "payload": {
              "type": "string",
              "description": "Action payload, based on the payload schema in the search_services result. You can pass either the json object directly or json encoded string of the object."
            },
            "payment": {
              "type": "number",
              "description": "Amount to authorize in USD. Positive number means you will be charged no more than this amount, negative number means you are requesting to get paid for at least this amount. Only include this field if the action you are calling includes payment information."
            }
          },
          "required": [
            "action",
            "payload"
          ]
        }
      }
    ]
  },
  "contentful-mcp": {
    "name": "contentful-mcp",
    "display_name": "Contentful Management",
    "description": "Read, update, delete, publish content in your [Contentful](https://contentful.com/) space(s) from this MCP Server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ivo-toby/contentful-mcp"
    },
    "homepage": "https://github.com/ivo-toby/contentful-mcp",
    "author": {
      "name": "ivo-toby"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Contentful",
      "Management API",
      "CRUD Operations"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@ivotoby/contentful-management-mcp-server"
        ],
        "env": {
          "CONTENTFUL_MANAGEMENT_ACCESS_TOKEN": "${CONTENTFUL_MANAGEMENT_ACCESS_TOKEN}"
        }
      }
    },
    "arguments": {
      "CONTENTFUL_MANAGEMENT_ACCESS_TOKEN": {
        "description": "Your Content Management API token for accessing Contentful services.",
        "required": true,
        "example": "<Your CMA token>"
      }
    },
    "tools": [
      {
        "name": "search_entries",
        "description": "Search for entries using query parameters. Returns a maximum of 3 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "object",
              "description": "Query parameters for searching entries",
              "properties": {
                "content_type": {
                  "type": "string"
                },
                "select": {
                  "type": "string"
                },
                "limit": {
                  "type": "number",
                  "default": 3,
                  "maximum": 3,
                  "description": "Maximum number of items to return (max: 3)"
                },
                "skip": {
                  "type": "number",
                  "default": 0,
                  "description": "Number of items to skip for pagination"
                },
                "order": {
                  "type": "string"
                },
                "query": {
                  "type": "string"
                }
              },
              "required": [
                "limit",
                "skip"
              ]
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "query",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_entry",
        "description": "Create a new entry in Contentful, before executing this function, you need to know the contentTypeId (not the content type NAME) and the fields of that contentType, you can get the fields definition by using the GET_CONTENT_TYPE tool. ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string",
              "description": "The ID of the content type for the new entry"
            },
            "fields": {
              "type": "object",
              "description": "The fields of the entry"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_entry",
        "description": "Retrieve an existing entry",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_entry",
        "description": "Update an existing entry, very important: always send all field values and all values related to locales, also the fields values that have not been updated",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "type": "string"
            },
            "fields": {
              "type": "object"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_entry",
        "description": "Delete an entry",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_entry",
        "description": "Publish an entry or multiple entries. Accepts either a single entryId (string) or an array of entryIds (up to 100 entries). For a single entry, it uses the standard publish operation. For multiple entries, it automatically uses bulk publishing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "maxItems": 100,
                  "description": "Array of entry IDs to publish (max: 100)"
                }
              ],
              "description": "ID of the entry to publish, or an array of entry IDs (max: 100)"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_entry",
        "description": "Unpublish an entry or multiple entries. Accepts either a single entryId (string) or an array of entryIds (up to 100 entries). For a single entry, it uses the standard unpublish operation. For multiple entries, it automatically uses bulk unpublishing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "maxItems": 100,
                  "description": "Array of entry IDs to unpublish (max: 100)"
                }
              ],
              "description": "ID of the entry to unpublish, or an array of entry IDs (max: 100)"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_assets",
        "description": "List assets in a space. Returns a maximum of 3 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 3,
              "maximum": 3,
              "description": "Maximum number of items to return (max: 3)"
            },
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of items to skip for pagination"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "limit",
            "skip",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "upload_asset",
        "description": "Upload a new asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "file": {
              "type": "object",
              "properties": {
                "upload": {
                  "type": "string"
                },
                "fileName": {
                  "type": "string"
                },
                "contentType": {
                  "type": "string"
                }
              },
              "required": [
                "upload",
                "fileName",
                "contentType"
              ]
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "title",
            "file",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_asset",
        "description": "Retrieve an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_asset",
        "description": "Update an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "file": {
              "type": "object",
              "properties": {
                "url": {
                  "type": "string"
                },
                "fileName": {
                  "type": "string"
                },
                "contentType": {
                  "type": "string"
                }
              },
              "required": [
                "url",
                "fileName",
                "contentType"
              ]
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_asset",
        "description": "Delete an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_asset",
        "description": "Publish an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_asset",
        "description": "Unpublish an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_content_types",
        "description": "List content types in a space. Returns a maximum of 10 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "maximum": 20,
              "description": "Maximum number of items to return (max: 3)"
            },
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of items to skip for pagination"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "limit",
            "skip",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_content_type",
        "description": "Get details of a specific content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_content_type",
        "description": "Create a new content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "fields": {
              "type": "array",
              "description": "Array of field definitions for the content type",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "The ID of the field"
                  },
                  "name": {
                    "type": "string",
                    "description": "Display name of the field"
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of the field (Text, Number, Date, Location, Media, Boolean, JSON, Link, Array, etc)",
                    "enum": [
                      "Symbol",
                      "Text",
                      "Integer",
                      "Number",
                      "Date",
                      "Location",
                      "Object",
                      "Boolean",
                      "Link",
                      "Array"
                    ]
                  },
                  "required": {
                    "type": "boolean",
                    "description": "Whether this field is required",
                    "default": false
                  },
                  "localized": {
                    "type": "boolean",
                    "description": "Whether this field can be localized",
                    "default": false
                  },
                  "linkType": {
                    "type": "string",
                    "description": "Required for Link fields. Specifies what type of resource this field links to",
                    "enum": [
                      "Entry",
                      "Asset"
                    ]
                  },
                  "items": {
                    "type": "object",
                    "description": "Required for Array fields. Specifies the type of items in the array",
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "Symbol",
                          "Link"
                        ]
                      },
                      "linkType": {
                        "type": "string",
                        "enum": [
                          "Entry",
                          "Asset"
                        ]
                      },
                      "validations": {
                        "type": "array",
                        "items": {
                          "type": "object"
                        }
                      }
                    }
                  },
                  "validations": {
                    "type": "array",
                    "description": "Array of validation rules for the field",
                    "items": {
                      "type": "object"
                    }
                  }
                },
                "required": [
                  "id",
                  "name",
                  "type"
                ]
              }
            },
            "description": {
              "type": "string"
            },
            "displayField": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "name",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_content_type",
        "description": "Update an existing content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string"
            },
            "name": {
              "type": "string"
            },
            "fields": {
              "type": "array",
              "items": {
                "type": "object"
              }
            },
            "description": {
              "type": "string"
            },
            "displayField": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "name",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_content_type",
        "description": "Delete a content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_content_type",
        "description": "Publish a content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_spaces",
        "description": "List all available spaces",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_space",
        "description": "Get details of a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId"
          ]
        }
      },
      {
        "name": "list_environments",
        "description": "List all environments in a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId"
          ]
        }
      },
      {
        "name": "create_environment",
        "description": "Create a new environment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "spaceId",
            "environmentId",
            "name"
          ]
        }
      },
      {
        "name": "delete_environment",
        "description": "Delete an environment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "bulk_validate",
        "description": "Validate multiple entries at once",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryIds": {
              "type": "array",
              "description": "Array of entry IDs to validate",
              "items": {
                "type": "string"
              }
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryIds",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_ai_actions",
        "description": "List all AI Actions in a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Maximum number of AI Actions to return"
            },
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of AI Actions to skip for pagination"
            },
            "status": {
              "type": "string",
              "enum": [
                "all",
                "published"
              ],
              "description": "Filter AI Actions by status"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_ai_action",
        "description": "Get a specific AI Action by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to retrieve"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_ai_action",
        "description": "Create a new AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the AI Action"
            },
            "description": {
              "type": "string",
              "description": "The description of the AI Action"
            },
            "instruction": {
              "type": "object",
              "description": "The instruction object containing the template and variables",
              "properties": {
                "template": {
                  "type": "string",
                  "description": "The prompt template with variable placeholders"
                },
                "variables": {
                  "type": "array",
                  "description": "Array of variable definitions",
                  "items": {
                    "type": "object"
                  }
                },
                "conditions": {
                  "type": "array",
                  "description": "Optional array of conditions for the template",
                  "items": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "template",
                "variables"
              ]
            },
            "configuration": {
              "type": "object",
              "description": "The model configuration",
              "properties": {
                "modelType": {
                  "type": "string",
                  "description": "The type of model to use (e.g., gpt-4)"
                },
                "modelTemperature": {
                  "type": "number",
                  "description": "The temperature setting for the model (0.0 to 1.0)",
                  "minimum": 0,
                  "maximum": 1
                }
              },
              "required": [
                "modelType",
                "modelTemperature"
              ]
            },
            "testCases": {
              "type": "array",
              "description": "Optional array of test cases for the AI Action",
              "items": {
                "type": "object"
              }
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "name",
            "description",
            "instruction",
            "configuration",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_ai_action",
        "description": "Update an existing AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to update"
            },
            "name": {
              "type": "string",
              "description": "The name of the AI Action"
            },
            "description": {
              "type": "string",
              "description": "The description of the AI Action"
            },
            "instruction": {
              "type": "object",
              "description": "The instruction object containing the template and variables",
              "properties": {
                "template": {
                  "type": "string",
                  "description": "The prompt template with variable placeholders"
                },
                "variables": {
                  "type": "array",
                  "description": "Array of variable definitions",
                  "items": {
                    "type": "object"
                  }
                },
                "conditions": {
                  "type": "array",
                  "description": "Optional array of conditions for the template",
                  "items": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "template",
                "variables"
              ]
            },
            "configuration": {
              "type": "object",
              "description": "The model configuration",
              "properties": {
                "modelType": {
                  "type": "string",
                  "description": "The type of model to use (e.g., gpt-4)"
                },
                "modelTemperature": {
                  "type": "number",
                  "description": "The temperature setting for the model (0.0 to 1.0)",
                  "minimum": 0,
                  "maximum": 1
                }
              },
              "required": [
                "modelType",
                "modelTemperature"
              ]
            },
            "testCases": {
              "type": "array",
              "description": "Optional array of test cases for the AI Action",
              "items": {
                "type": "object"
              }
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "name",
            "description",
            "instruction",
            "configuration",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_ai_action",
        "description": "Delete an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to delete"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_ai_action",
        "description": "Publish an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to publish"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_ai_action",
        "description": "Unpublish an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to unpublish"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "invoke_ai_action",
        "description": "Invoke an AI Action with variables",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to invoke"
            },
            "variables": {
              "type": "object",
              "description": "Key-value pairs of variable IDs and their values",
              "additionalProperties": {
                "type": "string"
              }
            },
            "rawVariables": {
              "type": "array",
              "description": "Array of raw variable objects (for complex variable types like references)",
              "items": {
                "type": "object"
              }
            },
            "outputFormat": {
              "type": "string",
              "enum": [
                "Markdown",
                "RichText",
                "PlainText"
              ],
              "default": "Markdown",
              "description": "The format of the output content"
            },
            "waitForCompletion": {
              "type": "boolean",
              "default": true,
              "description": "Whether to wait for the AI Action to complete before returning"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_ai_action_invocation",
        "description": "Get the result of a previous AI Action invocation",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action"
            },
            "invocationId": {
              "type": "string",
              "description": "The ID of the specific invocation to retrieve"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "invocationId",
            "spaceId",
            "environmentId"
          ]
        }
      }
    ]
  },
  "deepseek-mcp-server": {
    "name": "deepseek-mcp-server",
    "display_name": "DeepSeek",
    "description": "Model Context Protocol server integrating DeepSeek's advanced language models, in addition to [other useful API endpoints](https://github.com/DMontgomery40/deepseek-mcp-server?tab=readme-ov-file#features)",
    "repository": {
      "type": "git",
      "url": "https://github.com/DMontgomery40/deepseek-mcp-server"
    },
    "homepage": "https://github.com/DMontgomery40/deepseek-mcp-server",
    "author": {
      "name": "DMontgomery40"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "DeepSeek",
      "API",
      "Language Model"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "deepseek-mcp-server"
        ],
        "env": {
          "DEEPSEEK_API_KEY": "${DEEPSEEK_API_KEY}"
        }
      }
    },
    "arguments": {
      "DEEPSEEK_API_KEY": {
        "description": "An API key required to authenticate requests to the DeepSeek API.",
        "required": true,
        "example": "your-api-key"
      }
    },
    "tools": [
      {
        "name": "chat_completion",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string"
            },
            "messages": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "role": {
                    "type": "string",
                    "enum": [
                      "system",
                      "user",
                      "assistant"
                    ]
                  },
                  "content": {
                    "type": "string"
                  }
                },
                "required": [
                  "role",
                  "content"
                ],
                "additionalProperties": false
              }
            },
            "model": {
              "type": "string",
              "default": "deepseek-reasoner"
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2,
              "default": 0.7
            },
            "max_tokens": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "default": 8000
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "default": 1
            },
            "frequency_penalty": {
              "type": "number",
              "minimum": -2,
              "maximum": 2,
              "default": 0.1
            },
            "presence_penalty": {
              "type": "number",
              "minimum": -2,
              "maximum": 2,
              "default": 0
            }
          }
        }
      },
      {
        "name": "multi_turn_chat",
        "inputSchema": {
          "type": "object",
          "properties": {
            "messages": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "role": {
                        "type": "string",
                        "enum": [
                          "system",
                          "user",
                          "assistant"
                        ]
                      },
                      "content": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "const": "text"
                          },
                          "text": {
                            "type": "string"
                          }
                        },
                        "required": [
                          "type",
                          "text"
                        ],
                        "additionalProperties": false
                      }
                    },
                    "required": [
                      "role",
                      "content"
                    ],
                    "additionalProperties": false
                  }
                }
              ]
            },
            "model": {
              "type": "string",
              "default": "deepseek-chat"
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2,
              "default": 0.7
            },
            "max_tokens": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "default": 8000
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "default": 1
            },
            "frequency_penalty": {
              "type": "number",
              "minimum": -2,
              "maximum": 2,
              "default": 0.1
            },
            "presence_penalty": {
              "type": "number",
              "minimum": -2,
              "maximum": 2,
              "default": 0
            }
          },
          "required": [
            "messages"
          ]
        }
      }
    ]
  },
  "gitlab": {
    "name": "gitlab",
    "display_name": "GitLab",
    "description": "GitLab API, enabling project management",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/gitlab",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "GitLab",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-gitlab"
        ],
        "env": {
          "GITLAB_PERSONAL_ACCESS_TOKEN": "${GITLAB_PERSONAL_ACCESS_TOKEN}",
          "GITLAB_API_URL": "${GITLAB_API_URL}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "-e",
          "GITLAB_PERSONAL_ACCESS_TOKEN",
          "-e",
          "GITLAB_API_URL",
          "mcp/gitlab"
        ],
        "env": {
          "GITLAB_PERSONAL_ACCESS_TOKEN": "${GITLAB_PERSONAL_ACCESS_TOKEN}",
          "GITLAB_API_URL": "${GITLAB_API_URL}"
        }
      }
    },
    "arguments": {
      "GITLAB_PERSONAL_ACCESS_TOKEN": {
        "description": "Your GitLab personal access token",
        "required": true
      },
      "GITLAB_API_URL": {
        "description": "Base URL for GitLab API",
        "required": false,
        "example": "https://gitlab.com/api/v4"
      }
    },
    "tools": [
      {
        "name": "create_or_update_file",
        "description": "Create or update a single file in a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "file_path": {
              "type": "string",
              "description": "Path where to create/update the file"
            },
            "content": {
              "type": "string",
              "description": "Content of the file"
            },
            "commit_message": {
              "type": "string",
              "description": "Commit message"
            },
            "branch": {
              "type": "string",
              "description": "Branch to create/update the file in"
            },
            "previous_path": {
              "type": "string",
              "description": "Path of the file to move/rename"
            }
          },
          "required": [
            "project_id",
            "file_path",
            "content",
            "commit_message",
            "branch"
          ]
        }
      },
      {
        "name": "search_repositories",
        "description": "Search for GitLab projects",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "Search query"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination (default: 1)"
            },
            "per_page": {
              "type": "number",
              "description": "Number of results per page (default: 20)"
            }
          },
          "required": [
            "search"
          ]
        }
      },
      {
        "name": "create_repository",
        "description": "Create a new GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Repository name"
            },
            "description": {
              "type": "string",
              "description": "Repository description"
            },
            "visibility": {
              "type": "string",
              "enum": [
                "private",
                "internal",
                "public"
              ],
              "description": "Repository visibility level"
            },
            "initialize_with_readme": {
              "type": "boolean",
              "description": "Initialize with README.md"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_file_contents",
        "description": "Get the contents of a file or directory from a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "file_path": {
              "type": "string",
              "description": "Path to the file or directory"
            },
            "ref": {
              "type": "string",
              "description": "Branch/tag/commit to get contents from"
            }
          },
          "required": [
            "project_id",
            "file_path"
          ]
        }
      },
      {
        "name": "push_files",
        "description": "Push multiple files to a GitLab project in a single commit",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "branch": {
              "type": "string",
              "description": "Branch to push to"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "file_path": {
                    "type": "string",
                    "description": "Path where to create the file"
                  },
                  "content": {
                    "type": "string",
                    "description": "Content of the file"
                  }
                },
                "required": [
                  "file_path",
                  "content"
                ],
                "additionalProperties": false
              },
              "description": "Array of files to push"
            },
            "commit_message": {
              "type": "string",
              "description": "Commit message"
            }
          },
          "required": [
            "project_id",
            "branch",
            "files",
            "commit_message"
          ]
        }
      },
      {
        "name": "create_issue",
        "description": "Create a new issue in a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "title": {
              "type": "string",
              "description": "Issue title"
            },
            "description": {
              "type": "string",
              "description": "Issue description"
            },
            "assignee_ids": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Array of user IDs to assign"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of label names"
            },
            "milestone_id": {
              "type": "number",
              "description": "Milestone ID to assign"
            }
          },
          "required": [
            "project_id",
            "title"
          ]
        }
      },
      {
        "name": "create_merge_request",
        "description": "Create a new merge request in a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "title": {
              "type": "string",
              "description": "Merge request title"
            },
            "description": {
              "type": "string",
              "description": "Merge request description"
            },
            "source_branch": {
              "type": "string",
              "description": "Branch containing changes"
            },
            "target_branch": {
              "type": "string",
              "description": "Branch to merge into"
            },
            "draft": {
              "type": "boolean",
              "description": "Create as draft merge request"
            },
            "allow_collaboration": {
              "type": "boolean",
              "description": "Allow commits from upstream members"
            }
          },
          "required": [
            "project_id",
            "title",
            "source_branch",
            "target_branch"
          ]
        }
      },
      {
        "name": "fork_repository",
        "description": "Fork a GitLab project to your account or specified namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "namespace": {
              "type": "string",
              "description": "Namespace to fork to (full path)"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "create_branch",
        "description": "Create a new branch in a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "branch": {
              "type": "string",
              "description": "Name for the new branch"
            },
            "ref": {
              "type": "string",
              "description": "Source branch/commit for new branch"
            }
          },
          "required": [
            "project_id",
            "branch"
          ]
        }
      }
    ],
    "is_official": true
  },
  "dune-analytics-mcp": {
    "name": "dune-analytics-mcp",
    "display_name": "Dune Analytics",
    "description": "A mcp server that bridges Dune Analytics data to AI agents.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kukapay/dune-analytics-mcp"
    },
    "homepage": "https://github.com/kukapay/dune-analytics-mcp",
    "author": {
      "name": "Kukapay"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Dune",
      "Analytics",
      "AI agents"
    ],
    "examples": [
      {
        "title": "Get Latest Result",
        "description": "Retrieves the latest results of a specified Dune query.",
        "prompt": "get_latest_result(query_id=4853921)"
      },
      {
        "title": "Run Query",
        "description": "Executes a Dune query and returns the results.",
        "prompt": "run_query(query_id=1215383)"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kukapay/dune-analytics-mcp",
          "main.py"
        ],
        "env": {
          "DUNE_API_KEY": "${DUNE_API_KEY}"
        }
      }
    },
    "arguments": {
      "DUNE_API_KEY": {
        "description": "A valid Dune Analytics API key obtained from Dune Analytics for authentication and data access.",
        "required": true,
        "example": "your_api_key_here"
      }
    }
  },
  "whois-mcp": {
    "name": "whois-mcp",
    "display_name": "Whois Lookup",
    "description": "MCP server that performs whois lookup against domain, IP, ASN and TLD.",
    "repository": {
      "type": "git",
      "url": "https://github.com/bharathvaj-ganesan/whois-mcp"
    },
    "homepage": "https://github.com/bharathvaj-ganesan/whois-mcp",
    "author": {
      "name": "bharathvaj-ganesan"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "whois",
      "domain",
      "tools"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@bharathvaj/whois-mcp@latest"
        ]
      }
    },
    "examples": [
      {
        "title": "Look up WHOIS information",
        "description": "Using the Whois MCP to find out domain details.",
        "prompt": "What can you tell me about example.com?"
      }
    ],
    "tools": [
      {
        "name": "whois_domain",
        "description": "Looksup whois information about the domain",
        "inputSchema": {
          "type": "object",
          "properties": {
            "domain": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "domain"
          ]
        }
      },
      {
        "name": "whois_tld",
        "description": "Looksup whois information about the Top Level Domain (TLD)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tld": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "tld"
          ]
        }
      },
      {
        "name": "whois_ip",
        "description": "Looksup whois information about the IP",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ip": {
              "type": "string",
              "anyOf": [
                {
                  "format": "ipv4"
                },
                {
                  "format": "ipv6"
                }
              ]
            }
          },
          "required": [
            "ip"
          ]
        }
      },
      {
        "name": "whois_as",
        "description": "Looksup whois information about the Autonomous System Number (ASN)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "asn": {
              "type": "string",
              "pattern": "^AS\\d+$"
            }
          },
          "required": [
            "asn"
          ]
        }
      }
    ]
  },
  "deepseek-thinker-mcp": {
    "name": "deepseek-thinker-mcp",
    "display_name": "Deepseek Thinker",
    "description": "A MCP (Model Context Protocol) provider Deepseek reasoning content to MCP-enabled AI Clients, like Claude Desktop. Supports access to Deepseek's thought processes from the Deepseek API service or from a local Ollama server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ruixingshi/deepseek-thinker-mcp"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Deepseek",
      "AI Clients",
      "Reasoning"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "deepseek-thinker-mcp"
        ],
        "env": {
          "API_KEY": "${API_KEY}",
          "BASE_URL": "${BASE_URL}"
        }
      }
    },
    "author": {
      "name": "ruixingshi"
    },
    "homepage": "https://github.com/ruixingshi/deepseek-thinker-mcp",
    "arguments": {
      "API_KEY": {
        "description": "Your OpenAI API Key for authentication with the OpenAI services.",
        "required": true,
        "example": "sk-xxxxxxxxxx"
      },
      "BASE_URL": {
        "description": "The base URL for the OpenAI API that you are connecting to.",
        "required": true,
        "example": "https://api.openai.com/v1"
      }
    },
    "tools": [
      {
        "name": "get-deepseek-thinker",
        "description": "think with deepseek",
        "inputSchema": {
          "type": "object",
          "properties": {
            "originPrompt": {
              "type": "string",
              "description": "user's original prompt"
            }
          },
          "required": [
            "originPrompt"
          ]
        }
      }
    ]
  },
  "inbox-zero": {
    "display_name": "Inbox Zero MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/elie222/inbox-zero"
    },
    "homepage": "https://github.com/elie222/inbox-zero/tree/main/apps/mcp-server",
    "author": {
      "name": "elie222"
    },
    "license": "MIT",
    "tags": [
      "email",
      "inbox",
      "assistant",
      "mcp"
    ],
    "arguments": {
      "API_KEY": {
        "description": "Your Inbox Zero API key from the /settings page in the web app",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "build/index.js"
        ],
        "env": {
          "API_KEY": ""
        },
        "description": "Run the MCP server using Node.js"
      }
    },
    "examples": [
      {
        "title": "Manage your inbox",
        "description": "Use the MCP server to interact with your Inbox Zero personal assistant",
        "prompt": "Help me organize my inbox"
      }
    ],
    "name": "inbox-zero",
    "description": "data-color-mode=\"auto\" data-light-theme=\"light\" data-dark-theme=\"dark\"",
    "categories": [
      "Messaging"
    ],
    "is_official": true
  },
  "git": {
    "name": "git",
    "display_name": "git",
    "description": "Tools to read, search, and manipulate Git repositories",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/git",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Git",
      "Server",
      "Automation"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-git",
          "--repository",
          "${GIT_REPO_PATH}"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "--mount",
          "type=bind,src=${GIT_REPO_PATH},dst=${GIT_REPO_PATH}",
          "mcp/git"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp_server_git",
          "--repository",
          "${GIT_REPO_PATH}"
        ]
      }
    },
    "arguments": {
      "GIT_REPO_PATH": {
        "description": "The path to the Git repository that the mcp-server-git will interact with.",
        "required": true,
        "example": "/path/to/git/repo"
      }
    },
    "tools": [
      {
        "name": "git_status",
        "description": "Shows the working tree status",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitStatus",
          "type": "object"
        }
      },
      {
        "name": "git_diff_unstaged",
        "description": "Shows changes in the working directory that are not yet staged",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitDiffUnstaged",
          "type": "object"
        }
      },
      {
        "name": "git_diff_staged",
        "description": "Shows changes that are staged for commit",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitDiffStaged",
          "type": "object"
        }
      },
      {
        "name": "git_diff",
        "description": "Shows differences between branches or commits",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "target": {
              "title": "Target",
              "type": "string"
            }
          },
          "required": [
            "repo_path",
            "target"
          ],
          "title": "GitDiff",
          "type": "object"
        }
      },
      {
        "name": "git_commit",
        "description": "Records changes to the repository",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "message": {
              "title": "Message",
              "type": "string"
            }
          },
          "required": [
            "repo_path",
            "message"
          ],
          "title": "GitCommit",
          "type": "object"
        }
      },
      {
        "name": "git_add",
        "description": "Adds file contents to the staging area",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "files": {
              "items": {
                "type": "string"
              },
              "title": "Files",
              "type": "array"
            }
          },
          "required": [
            "repo_path",
            "files"
          ],
          "title": "GitAdd",
          "type": "object"
        }
      },
      {
        "name": "git_reset",
        "description": "Unstages all staged changes",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitReset",
          "type": "object"
        }
      },
      {
        "name": "git_log",
        "description": "Shows the commit logs",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "max_count": {
              "default": 10,
              "title": "Max Count",
              "type": "integer"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitLog",
          "type": "object"
        }
      },
      {
        "name": "git_create_branch",
        "description": "Creates a new branch from an optional base branch",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "branch_name": {
              "title": "Branch Name",
              "type": "string"
            },
            "base_branch": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Base Branch"
            }
          },
          "required": [
            "repo_path",
            "branch_name"
          ],
          "title": "GitCreateBranch",
          "type": "object"
        }
      },
      {
        "name": "git_checkout",
        "description": "Switches branches",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "branch_name": {
              "title": "Branch Name",
              "type": "string"
            }
          },
          "required": [
            "repo_path",
            "branch_name"
          ],
          "title": "GitCheckout",
          "type": "object"
        }
      },
      {
        "name": "git_show",
        "description": "Shows the contents of a commit",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "revision": {
              "title": "Revision",
              "type": "string"
            }
          },
          "required": [
            "repo_path",
            "revision"
          ],
          "title": "GitShow",
          "type": "object"
        }
      }
    ],
    "is_official": true
  },
  "code-executor": {
    "name": "code-executor",
    "display_name": "Code Executor",
    "description": "An MCP server that allows LLMs to execute Python code within a specified Conda environment.",
    "repository": {
      "type": "git",
      "url": "https://github.com/bazinga012/mcp_code_executor"
    },
    "homepage": "https://github.com/bazinga012/mcp_code_executor",
    "author": {
      "name": "bazinga012"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Python",
      "Conda",
      "Execution"
    ],
    "examples": [
      {
        "title": "Execute Python Code",
        "description": "An example of executing Python code using MCP Code Executor",
        "prompt": "Please execute the following code: print('Hello, World!')"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/bazinga012/mcp_code_executor"
        ],
        "env": {
          "CODE_STORAGE_DIR": "${CODE_STORAGE_DIR}",
          "CONDA_ENV_NAME": "${CONDA_ENV_NAME}"
        }
      }
    },
    "arguments": {
      "CODE_STORAGE_DIR": {
        "description": "The directory where the generated code will be stored.",
        "required": true,
        "example": "/path/to/code/storage"
      },
      "CONDA_ENV_NAME": {
        "description": "The name of the Conda environment in which the code will be executed.",
        "required": true,
        "example": "your-conda-env"
      }
    },
    "tools": [
      {
        "name": "execute_code",
        "description": "Execute Python code in the specified conda environment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "Python code to execute"
            },
            "filename": {
              "type": "string",
              "description": "Optional: Name of the file to save the code (default: generated UUID)"
            }
          },
          "required": [
            "code"
          ]
        }
      }
    ]
  },
  "world-bank-data-api": {
    "name": "world-bank-data-api",
    "display_name": "World Bank Data API",
    "description": "A server that fetches data indicators available with the World Bank as part of their data API",
    "repository": {
      "type": "git",
      "url": "https://github.com/anshumax/world_bank_mcp_server"
    },
    "homepage": "https://github.com/anshumax/world_bank_mcp_server",
    "author": {
      "name": "anshumax"
    },
    "license": "[NOT FOUND]",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "World Bank",
      "Data",
      "API",
      "Indicators",
      "Analysis"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/anshumax/world_bank_mcp_server",
          "world_bank_mcp_server"
        ]
      }
    },
    "examples": [
      {
        "title": "List Countries",
        "description": "Lists available countries in the World Bank open data API.",
        "prompt": "List all countries available in the World Bank data."
      },
      {
        "title": "List Indicators",
        "description": "Lists available indicators in the World Bank open data API.",
        "prompt": "List all indicators available in the World Bank data."
      },
      {
        "title": "Analyze Indicators",
        "description": "Analyzes specific indicators for a selected country.",
        "prompt": "Analyze the poverty indicators for Kenya."
      }
    ],
    "tools": [
      {
        "name": "get_indicator_for_country",
        "description": "Get values for an indicator for a specific country from the World Bank API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "country_id": {
              "type": "string",
              "description": "The ID of the country for which the indicator is to be queried"
            },
            "indicator_id": {
              "type": "string",
              "description": "The ID of the indicator to be queried"
            }
          },
          "required": [
            "country_id",
            "indicator_id"
          ]
        }
      }
    ]
  },
  "firebase": {
    "name": "firebase",
    "display_name": "Firebase",
    "description": "Server to interact with Firebase services including Firebase Authentication, Firestore, and Firebase Storage.",
    "repository": {
      "type": "git",
      "url": "https://github.com/gannonh/firebase-mcp"
    },
    "homepage": "https://github.com/gannonh/firebase-mcp",
    "author": {
      "name": "gannonh"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Firebase",
      "LLM",
      "Server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@gannonh/firebase-mcp"
        ],
        "env": {
          "SERVICE_ACCOUNT_KEY_PATH": "${SERVICE_ACCOUNT_KEY_PATH}",
          "FIREBASE_STORAGE_BUCKET": "${FIREBASE_STORAGE_BUCKET}"
        }
      }
    },
    "arguments": {
      "SERVICE_ACCOUNT_KEY_PATH": {
        "description": "Path to your Firebase service account key JSON file",
        "required": true,
        "example": "/absolute/path/to/serviceAccountKey.json"
      },
      "FIREBASE_STORAGE_BUCKET": {
        "description": "Bucket name for Firebase Storage",
        "required": false,
        "example": "your-project-id.firebasestorage.app"
      }
    },
    "tools": [
      {
        "name": "firestore_add_document",
        "description": "Add a document to a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "data": {
              "type": "object",
              "description": "Document data"
            }
          },
          "required": [
            "collection",
            "data"
          ]
        }
      },
      {
        "name": "firestore_list_documents",
        "description": "List documents from a Firestore collection with filtering and ordering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "filters": {
              "type": "array",
              "description": "Array of filter conditions",
              "items": {
                "type": "object",
                "properties": {
                  "field": {
                    "type": "string",
                    "description": "Field name to filter"
                  },
                  "operator": {
                    "type": "string",
                    "description": "Comparison operator (==, >, <, >=, <=, array-contains, in, array-contains-any)"
                  },
                  "value": {
                    "description": "Value to compare against (use ISO format for dates)"
                  }
                },
                "required": [
                  "field",
                  "operator",
                  "value"
                ]
              }
            },
            "limit": {
              "type": "number",
              "description": "Number of documents to return",
              "default": 20
            },
            "pageToken": {
              "type": "string",
              "description": "Token for pagination to get the next page of results"
            },
            "orderBy": {
              "type": "array",
              "description": "Array of fields to order by",
              "items": {
                "type": "object",
                "properties": {
                  "field": {
                    "type": "string",
                    "description": "Field name to order by"
                  },
                  "direction": {
                    "type": "string",
                    "description": "Sort direction (asc or desc)",
                    "enum": [
                      "asc",
                      "desc"
                    ],
                    "default": "asc"
                  }
                },
                "required": [
                  "field"
                ]
              }
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "firestore_get_document",
        "description": "Get a document from a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "id": {
              "type": "string",
              "description": "Document ID"
            }
          },
          "required": [
            "collection",
            "id"
          ]
        }
      },
      {
        "name": "firestore_update_document",
        "description": "Update a document in a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "id": {
              "type": "string",
              "description": "Document ID"
            },
            "data": {
              "type": "object",
              "description": "Updated document data"
            }
          },
          "required": [
            "collection",
            "id",
            "data"
          ]
        }
      },
      {
        "name": "firestore_delete_document",
        "description": "Delete a document from a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "id": {
              "type": "string",
              "description": "Document ID"
            }
          },
          "required": [
            "collection",
            "id"
          ]
        }
      },
      {
        "name": "auth_get_user",
        "description": "Get a user by ID or email from Firebase Authentication",
        "inputSchema": {
          "type": "object",
          "properties": {
            "identifier": {
              "type": "string",
              "description": "User ID or email address"
            }
          },
          "required": [
            "identifier"
          ]
        }
      },
      {
        "name": "storage_list_files",
        "description": "List files in a given path in Firebase Storage",
        "inputSchema": {
          "type": "object",
          "properties": {
            "directoryPath": {
              "type": "string",
              "description": "The optional path to list files from. If not provided, the root is used."
            }
          },
          "required": []
        }
      },
      {
        "name": "storage_get_file_info",
        "description": "Get file information including metadata and download URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The path of the file to get information for"
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "firestore_list_collections",
        "description": "List root collections in Firestore",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ]
  },
  "dify": {
    "name": "dify",
    "display_name": "Dify",
    "description": "A simple implementation of an MCP server for dify workflows.",
    "repository": {
      "type": "git",
      "url": "https://github.com/YanxingLiu/dify-mcp-server"
    },
    "homepage": "https://github.com/YanxingLiu/dify-mcp-server",
    "author": {
      "name": "YanxingLiu"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "dify",
      "server",
      "workflows"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/YanxingLiu/dify-mcp-server",
          "dify_mcp_server"
        ],
        "env": {
          "CONFIG_PATH": "${CONFIG_PATH}"
        }
      }
    },
    "arguments": {
      "CONFIG_PATH": {
        "description": "This environment variable indicates the path to the configuration file for the Dify MCP server, typically a YAML file containing necessary settings.",
        "required": true,
        "example": "/Users/lyx/Downloads/config.yaml"
      }
    }
  },
  "code-sandbox-mcp": {
    "name": "code-sandbox-mcp",
    "display_name": "Code Sandbox",
    "description": "An MCP server to create secure code sandbox environment for executing code within Docker containers.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Automata-Labs-team/code-sandbox-mcp"
    },
    "homepage": "https://github.com/Automata-Labs-team/code-sandbox-mcp",
    "author": {
      "name": "Automata-Labs-team"
    },
    "license": "MIT",
    "installations": {
      "custom": {
        "type": "custom",
        "command": "/path/to/code-sandbox-mcp",
        "args": [],
        "env": {}
      }
    },
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Docker",
      "Sandbox",
      "Code Execution"
    ]
  },
  "rijksmuseum": {
    "name": "rijksmuseum",
    "display_name": "Rijksmuseum",
    "description": "Interface with the Rijksmuseum API to search artworks, retrieve artwork details, access image tiles, and explore user collections.",
    "repository": {
      "type": "git",
      "url": "https://github.com/r-huijts/rijksmuseum-mcp"
    },
    "homepage": "https://github.com/r-huijts/rijksmuseum-mcp",
    "author": {
      "name": "r-huijts"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "collection",
      "Rijksmuseum"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-server-rijksmuseum"
        ],
        "env": {
          "RIJKSMUSEUM_API_KEY": "${RIJKSMUSEUM_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Artwork Discovery",
        "description": "Queries related to discovering artworks in the museum's collection.",
        "prompt": "\"Show me all paintings by Rembrandt from the 1640s\""
      },
      {
        "title": "Artwork Analysis",
        "description": "Queries related to analyzing specific artworks.",
        "prompt": "\"Tell me everything about The Night Watch\""
      },
      {
        "title": "Artist Research",
        "description": "Queries focused on researching artists and their works.",
        "prompt": "\"Create a timeline of Rembrandt's self-portraits\""
      },
      {
        "title": "Thematic Exploration",
        "description": "Queries that explore themes in the artworks.",
        "prompt": "\"Find all artworks depicting biblical scenes\""
      },
      {
        "title": "Collection Analysis",
        "description": "Queries about user-curated collections.",
        "prompt": "\"Show me the most popular user-curated collections\""
      },
      {
        "title": "Visual Details",
        "description": "Queries for examining visual details in artworks.",
        "prompt": "\"Let me examine the details in the background of The Night Watch\""
      }
    ],
    "arguments": {
      "RIJKSMUSEUM_API_KEY": {
        "description": "Your Rijksmuseum API key used for authenticating requests to the Rijksmuseum API.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "search_artwork",
        "description": "Search and filter artworks in the Rijksmuseum collection. This tool provides extensive filtering options including artist name, type of artwork, materials, techniques, time periods, colors, and more. Results can be sorted in various ways and are paginated.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "General search query that will match against artwork titles, descriptions, materials, techniques, etc. Use this for broad searches like 'sunflowers', 'portrait', 'landscape', etc."
            },
            "involvedMaker": {
              "type": "string",
              "description": "Search for artworks by a specific artist. Must be case-sensitive and exact, e.g., 'Rembrandt van Rijn', 'Vincent van Gogh'. Use + for spaces in names."
            },
            "type": {
              "type": "string",
              "description": "Filter by the type of artwork. Common values include 'painting', 'print', 'drawing', 'sculpture', 'photograph', 'furniture'. Use singular form."
            },
            "material": {
              "type": "string",
              "description": "Filter by the material used in the artwork. Examples: 'canvas', 'paper', 'wood', 'oil paint', 'marble'. Matches exact material names from the museum's classification."
            },
            "technique": {
              "type": "string",
              "description": "Filter by the technique used to create the artwork. Examples: 'oil painting', 'etching', 'watercolor', 'photography'. Matches specific techniques from the museum's classification."
            },
            "century": {
              "type": "integer",
              "description": "Filter artworks by the century they were created in. Use negative numbers for BCE, positive for CE. Range from -1 (100-1 BCE) to 21 (2000-2099 CE). Example: 17 for 17th century (1600-1699).",
              "minimum": -1,
              "maximum": 21
            },
            "color": {
              "type": "string",
              "description": "Filter artworks by predominant color. Use hexadecimal color codes without the # symbol. Examples: 'FF0000' for red, '00FF00' for green, '0000FF' for blue. The API will match artworks containing this color."
            },
            "imgonly": {
              "type": "boolean",
              "description": "When true, only returns artworks that have associated images. Set to true if you need to show or analyze the visual aspects of artworks.",
              "default": false
            },
            "toppieces": {
              "type": "boolean",
              "description": "When true, only returns artworks designated as masterpieces by the Rijksmuseum. These are the most significant and famous works in the collection.",
              "default": false
            },
            "sortBy": {
              "type": "string",
              "enum": [
                "relevance",
                "objecttype",
                "chronologic",
                "achronologic",
                "artist",
                "artistdesc"
              ],
              "description": "Determines the order of results. Options: 'relevance' (best matches first), 'objecttype' (grouped by type), 'chronologic' (oldest to newest), 'achronologic' (newest to oldest), 'artist' (artist name A-Z), 'artistdesc' (artist name Z-A).",
              "default": "relevance"
            },
            "p": {
              "type": "integer",
              "description": "Page number for paginated results, starting at 0. Use in combination with 'ps' to navigate through large result sets. Note: p * ps cannot exceed 10,000.",
              "minimum": 0,
              "default": 0
            },
            "ps": {
              "type": "integer",
              "description": "Number of artworks to return per page. Higher values return more results but take longer to process. Maximum of 100 items per page.",
              "minimum": 1,
              "maximum": 100,
              "default": 10
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the search and returned data. Use 'en' for English or 'nl' for Dutch (Nederlands). Affects artwork titles, descriptions, and other text fields.",
              "default": "en"
            }
          }
        }
      },
      {
        "name": "get_artwork_details",
        "description": "Retrieve comprehensive details about a specific artwork from the Rijksmuseum collection. Returns extensive information including:\n\n- Basic details (title, artist, dates)\n- Physical properties (dimensions, materials, techniques)\n- Historical context (dating, historical persons, documentation)\n- Visual information (colors, image data)\n- Curatorial information (descriptions, labels, location)\n- Acquisition details\n- Exhibition history\n\nThis is the primary tool for in-depth research on a specific artwork, providing all available museum documentation and metadata.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectNumber": {
              "type": "string",
              "description": "The unique identifier of the artwork in the Rijksmuseum collection. Format is typically a combination of letters and numbers (e.g., 'SK-C-5' for The Night Watch, 'SK-A-3262' for Van Gogh's Self Portrait). Case-sensitive. This ID can be obtained from search results."
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the artwork details. Use 'en' for English or 'nl' for Dutch (Nederlands). Affects all textual information including descriptions, titles, and historical documentation.",
              "default": "en"
            }
          },
          "required": [
            "objectNumber"
          ]
        }
      },
      {
        "name": "get_artwork_image",
        "description": "Retrieve detailed image tile information for high-resolution viewing of an artwork. This tool provides data for implementing deep zoom functionality, allowing detailed examination of the artwork at various zoom levels.\n\nThe response includes multiple zoom levels (z0 to z6):\n- z0: Highest resolution (largest image)\n- z6: Lowest resolution (smallest image)\n\nEach zoom level contains:\n- Total width and height of the image at that level\n- A set of image tiles that make up the complete image\n- Position information (x,y) for each tile\n\nThis is particularly useful for:\n- Implementing deep zoom viewers\n- Studying fine artwork details\n- Analyzing brushwork or conservation details\n- Creating interactive viewing experiences",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectNumber": {
              "type": "string",
              "description": "The unique identifier of the artwork in the Rijksmuseum collection. Same format as used in get_artwork_details. The artwork must have an associated image for this to work."
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the API response. Use 'en' for English or 'nl' for Dutch (Nederlands). While this endpoint primarily returns image data, any textual metadata will be in the specified language.",
              "default": "en"
            }
          },
          "required": [
            "objectNumber"
          ]
        }
      },
      {
        "name": "get_user_sets",
        "description": "Retrieve collections created by Rijksstudio users. These are curated sets of artworks that users have grouped together based on themes, artists, periods, or personal interests.\n\nEach set includes:\n- Basic information (name, description, creation date)\n- Creator details (username, language preference)\n- Collection statistics (number of items)\n- Navigation links (API and web URLs)\n\nThis tool is useful for:\n- Discovering user-curated exhibitions\n- Finding thematically related artworks\n- Exploring popular artwork groupings\n- Studying collection patterns",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "description": "Page number for paginated results, starting at 0. Use with pageSize to navigate through sets. Note: page * pageSize cannot exceed 10,000.",
              "minimum": 0,
              "default": 0
            },
            "pageSize": {
              "type": "number",
              "description": "Number of user sets to return per page. Must be between 1 and 100. Larger values return more results but take longer to process.",
              "minimum": 1,
              "maximum": 100,
              "default": 10
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the response data. Use 'en' for English or 'nl' for Dutch (Nederlands). Affects set descriptions and user information.",
              "default": "en"
            }
          }
        }
      },
      {
        "name": "get_user_set_details",
        "description": "Retrieve detailed information about a specific user-created collection in Rijksstudio. Returns comprehensive information about the set and its contents, including:\n\n- Set metadata (name, description, creation date)\n- Creator information\n- List of artworks in the set\n- Image data for each artwork\n- Navigation links\n\nThis tool is particularly useful for:\n- Analyzing thematic groupings of artworks\n- Studying curatorial choices\n- Understanding collection patterns\n- Exploring relationships between artworks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "setId": {
              "type": "string",
              "description": "The unique identifier of the user set to fetch. Format is typically 'userId-setname'. This ID can be obtained from the get_user_sets results."
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the response data. Use 'en' for English or 'nl' for Dutch (Nederlands). Affects set descriptions and artwork information.",
              "default": "en"
            },
            "page": {
              "type": "number",
              "description": "Page number for paginated results, starting at 0. Use with pageSize to navigate through large sets. Note: page * pageSize cannot exceed 10,000.",
              "minimum": 0,
              "default": 0
            },
            "pageSize": {
              "type": "number",
              "description": "Number of artworks to return per page. Must be between 1 and 100. Default is 25. Larger values return more artworks but take longer to process.",
              "minimum": 1,
              "maximum": 100,
              "default": 25
            }
          },
          "required": [
            "setId"
          ]
        }
      },
      {
        "name": "open_image_in_browser",
        "description": "Open a high-resolution image of an artwork in the default web browser for viewing. This tool is useful when you want to examine an artwork visually or show it to the user. Works with any valid Rijksmuseum image URL.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "imageUrl": {
              "type": "string",
              "description": "The full URL of the artwork image to open. Must be a valid HTTP/HTTPS URL from the Rijksmuseum's servers. These URLs can be obtained from artwork search results or details."
            }
          },
          "required": [
            "imageUrl"
          ]
        }
      },
      {
        "name": "get_artist_timeline",
        "description": "Generate a chronological timeline of an artist's works in the Rijksmuseum collection. This tool is perfect for studying an artist's development, analyzing their artistic periods, or understanding their contribution to art history over time.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "artist": {
              "type": "string",
              "description": "The name of the artist to create a timeline for. Must match the museum's naming convention (e.g., 'Rembrandt van Rijn', 'Vincent van Gogh'). Case sensitive and exact match required."
            },
            "maxWorks": {
              "type": "number",
              "description": "Maximum number of works to include in the timeline. Works are selected based on significance and quality of available images. Higher numbers give a more complete picture but may include less significant works.",
              "minimum": 1,
              "maximum": 50,
              "default": 10
            }
          },
          "required": [
            "artist"
          ]
        }
      }
    ]
  },
  "mem0-mcp": {
    "name": "mem0-mcp",
    "display_name": "Mem0 Server",
    "description": "A Model Context Protocol server for Mem0, which helps with managing coding preferences.",
    "repository": {
      "type": "git",
      "url": "https://github.com/mem0ai/mem0-mcp"
    },
    "homepage": "https://github.com/mem0ai/mem0-mcp",
    "author": {
      "name": "mem0ai"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "coding preferences",
      "mem0"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/mem0ai/mem0-mcp",
          "main.py"
        ]
      }
    },
    "arguments": {
      "host": {
        "description": "The host address that the server will bind to. This can be configured to allow access from different IP addresses or set it to 'localhost' for local access only.",
        "required": false,
        "example": "0.0.0.0"
      },
      "port": {
        "description": "The port number on which the server will listen for incoming connections. Changing this can help to avoid port conflicts with other services on the same machine.",
        "required": false,
        "example": "8080"
      }
    }
  },
  "slack": {
    "name": "slack",
    "display_name": "Slack",
    "description": "Channel management and messaging capabilities",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "slack",
      "api",
      "bot"
    ],
    "examples": [
      {
        "title": "Post a message to a channel",
        "description": "Send a message to a specified Slack channel.",
        "prompt": "Include the channel ID and the message text."
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-slack"
        ],
        "env": {
          "SLACK_BOT_TOKEN": "${SLACK_BOT_TOKEN}",
          "SLACK_TEAM_ID": "${SLACK_TEAM_ID}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "SLACK_BOT_TOKEN",
          "-e",
          "SLACK_TEAM_ID",
          "mcp/slack"
        ],
        "env": {
          "SLACK_BOT_TOKEN": "${SLACK_BOT_TOKEN}",
          "SLACK_TEAM_ID": "${SLACK_TEAM_ID}"
        }
      }
    },
    "author": {
      "name": "modelcontextprotocol"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/slack",
    "arguments": {
      "SLACK_BOT_TOKEN": {
        "description": "The OAuth token for the bot user in the Slack workspace, used for authenticating API requests.",
        "required": true,
        "example": "xoxb-your-bot-token"
      },
      "SLACK_TEAM_ID": {
        "description": "The unique identifier of the Slack workspace, required for operations within the workspace.",
        "required": true,
        "example": "T01234567"
      }
    },
    "tools": [
      {
        "name": "slack_list_channels",
        "description": "List public channels in the workspace with pagination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of channels to return (default 100, max 200)",
              "default": 100
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page of results"
            }
          }
        }
      },
      {
        "name": "slack_post_message",
        "description": "Post a new message to a Slack channel",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel to post to"
            },
            "text": {
              "type": "string",
              "description": "The message text to post"
            }
          },
          "required": [
            "channel_id",
            "text"
          ]
        }
      },
      {
        "name": "slack_reply_to_thread",
        "description": "Reply to a specific message thread in Slack",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel containing the thread"
            },
            "thread_ts": {
              "type": "string",
              "description": "The timestamp of the parent message in the format '1234567890.123456'. Timestamps in the format without the period can be converted by adding the period such that 6 numbers come after it."
            },
            "text": {
              "type": "string",
              "description": "The reply text"
            }
          },
          "required": [
            "channel_id",
            "thread_ts",
            "text"
          ]
        }
      },
      {
        "name": "slack_add_reaction",
        "description": "Add a reaction emoji to a message",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel containing the message"
            },
            "timestamp": {
              "type": "string",
              "description": "The timestamp of the message to react to"
            },
            "reaction": {
              "type": "string",
              "description": "The name of the emoji reaction (without ::)"
            }
          },
          "required": [
            "channel_id",
            "timestamp",
            "reaction"
          ]
        }
      },
      {
        "name": "slack_get_channel_history",
        "description": "Get recent messages from a channel",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel"
            },
            "limit": {
              "type": "number",
              "description": "Number of messages to retrieve (default 10)",
              "default": 10
            }
          },
          "required": [
            "channel_id"
          ]
        }
      },
      {
        "name": "slack_get_thread_replies",
        "description": "Get all replies in a message thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel containing the thread"
            },
            "thread_ts": {
              "type": "string",
              "description": "The timestamp of the parent message in the format '1234567890.123456'. Timestamps in the format without the period can be converted by adding the period such that 6 numbers come after it."
            }
          },
          "required": [
            "channel_id",
            "thread_ts"
          ]
        }
      },
      {
        "name": "slack_get_users",
        "description": "Get a list of all users in the workspace with their basic profile information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page of results"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of users to return (default 100, max 200)",
              "default": 100
            }
          }
        }
      },
      {
        "name": "slack_get_user_profile",
        "description": "Get detailed profile information for a specific user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user_id": {
              "type": "string",
              "description": "The ID of the user"
            }
          },
          "required": [
            "user_id"
          ]
        }
      }
    ],
    "is_official": true
  },
  "openai-websearch-mcp": {
    "name": "openai-websearch-mcp",
    "display_name": "OpenAI WebSearch",
    "description": "This is a Python-based MCP server that provides OpenAI `web_search` build-in tool.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ConechoAI/openai-websearch-mcp"
    },
    "homepage": "https://github.com/ConechoAI/openai-websearch-mcp",
    "author": {
      "name": "ConechoAI"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "openai",
      "websearch",
      "AI assistant"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "openai-websearch-mcp"
        ],
        "env": {
          "OPENAI_API_KEY": "${OPENAI_API_KEY}"
        }
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "openai_websearch_mcp"
        ],
        "env": {
          "OPENAI_API_KEY": "${OPENAI_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Using web search",
        "description": "Perform a web search using the OpenAI WebSearch MCP server.",
        "prompt": "search('latest news on AI')"
      }
    ],
    "arguments": {
      "OPENAI_API_KEY": {
        "description": "Your OpenAI API key to authenticate requests to the OpenAI API.",
        "required": true,
        "example": "sk-xxxx"
      }
    },
    "tools": [
      {
        "name": "web_search",
        "description": " It allows AI assistants to search the web during conversations with users",
        "inputSchema": {
          "$defs": {
            "UserLocation": {
              "properties": {
                "type": {
                  "const": "approximate",
                  "default": "approximate",
                  "title": "Type",
                  "type": "string"
                },
                "city": {
                  "title": "City",
                  "type": "string"
                },
                "country": {
                  "default": null,
                  "title": "Country",
                  "type": "string"
                },
                "region": {
                  "default": null,
                  "title": "Region",
                  "type": "string"
                },
                "timezone": {
                  "enum": [
                    "Africa/Abidjan",
                    "Africa/Accra",
                    "Africa/Addis_Ababa",
                    "Africa/Algiers",
                    "Africa/Asmara",
                    "Africa/Asmera",
                    "Africa/Bamako",
                    "Africa/Bangui",
                    "Africa/Banjul",
                    "Africa/Bissau",
                    "Africa/Blantyre",
                    "Africa/Brazzaville",
                    "Africa/Bujumbura",
                    "Africa/Cairo",
                    "Africa/Casablanca",
                    "Africa/Ceuta",
                    "Africa/Conakry",
                    "Africa/Dakar",
                    "Africa/Dar_es_Salaam",
                    "Africa/Djibouti",
                    "Africa/Douala",
                    "Africa/El_Aaiun",
                    "Africa/Freetown",
                    "Africa/Gaborone",
                    "Africa/Harare",
                    "Africa/Johannesburg",
                    "Africa/Juba",
                    "Africa/Kampala",
                    "Africa/Khartoum",
                    "Africa/Kigali",
                    "Africa/Kinshasa",
                    "Africa/Lagos",
                    "Africa/Libreville",
                    "Africa/Lome",
                    "Africa/Luanda",
                    "Africa/Lubumbashi",
                    "Africa/Lusaka",
                    "Africa/Malabo",
                    "Africa/Maputo",
                    "Africa/Maseru",
                    "Africa/Mbabane",
                    "Africa/Mogadishu",
                    "Africa/Monrovia",
                    "Africa/Nairobi",
                    "Africa/Ndjamena",
                    "Africa/Niamey",
                    "Africa/Nouakchott",
                    "Africa/Ouagadougou",
                    "Africa/Porto-Novo",
                    "Africa/Sao_Tome",
                    "Africa/Timbuktu",
                    "Africa/Tripoli",
                    "Africa/Tunis",
                    "Africa/Windhoek",
                    "America/Adak",
                    "America/Anchorage",
                    "America/Anguilla",
                    "America/Antigua",
                    "America/Araguaina",
                    "America/Argentina/Buenos_Aires",
                    "America/Argentina/Catamarca",
                    "America/Argentina/ComodRivadavia",
                    "America/Argentina/Cordoba",
                    "America/Argentina/Jujuy",
                    "America/Argentina/La_Rioja",
                    "America/Argentina/Mendoza",
                    "America/Argentina/Rio_Gallegos",
                    "America/Argentina/Salta",
                    "America/Argentina/San_Juan",
                    "America/Argentina/San_Luis",
                    "America/Argentina/Tucuman",
                    "America/Argentina/Ushuaia",
                    "America/Aruba",
                    "America/Asuncion",
                    "America/Atikokan",
                    "America/Atka",
                    "America/Bahia",
                    "America/Bahia_Banderas",
                    "America/Barbados",
                    "America/Belem",
                    "America/Belize",
                    "America/Blanc-Sablon",
                    "America/Boa_Vista",
                    "America/Bogota",
                    "America/Boise",
                    "America/Buenos_Aires",
                    "America/Cambridge_Bay",
                    "America/Campo_Grande",
                    "America/Cancun",
                    "America/Caracas",
                    "America/Catamarca",
                    "America/Cayenne",
                    "America/Cayman",
                    "America/Chicago",
                    "America/Chihuahua",
                    "America/Ciudad_Juarez",
                    "America/Coral_Harbour",
                    "America/Cordoba",
                    "America/Costa_Rica",
                    "America/Creston",
                    "America/Cuiaba",
                    "America/Curacao",
                    "America/Danmarkshavn",
                    "America/Dawson",
                    "America/Dawson_Creek",
                    "America/Denver",
                    "America/Detroit",
                    "America/Dominica",
                    "America/Edmonton",
                    "America/Eirunepe",
                    "America/El_Salvador",
                    "America/Ensenada",
                    "America/Fort_Nelson",
                    "America/Fort_Wayne",
                    "America/Fortaleza",
                    "America/Glace_Bay",
                    "America/Godthab",
                    "America/Goose_Bay",
                    "America/Grand_Turk",
                    "America/Grenada",
                    "America/Guadeloupe",
                    "America/Guatemala",
                    "America/Guayaquil",
                    "America/Guyana",
                    "America/Halifax",
                    "America/Havana",
                    "America/Hermosillo",
                    "America/Indiana/Indianapolis",
                    "America/Indiana/Knox",
                    "America/Indiana/Marengo",
                    "America/Indiana/Petersburg",
                    "America/Indiana/Tell_City",
                    "America/Indiana/Vevay",
                    "America/Indiana/Vincennes",
                    "America/Indiana/Winamac",
                    "America/Indianapolis",
                    "America/Inuvik",
                    "America/Iqaluit",
                    "America/Jamaica",
                    "America/Jujuy",
                    "America/Juneau",
                    "America/Kentucky/Louisville",
                    "America/Kentucky/Monticello",
                    "America/Knox_IN",
                    "America/Kralendijk",
                    "America/La_Paz",
                    "America/Lima",
                    "America/Los_Angeles",
                    "America/Louisville",
                    "America/Lower_Princes",
                    "America/Maceio",
                    "America/Managua",
                    "America/Manaus",
                    "America/Marigot",
                    "America/Martinique",
                    "America/Matamoros",
                    "America/Mazatlan",
                    "America/Mendoza",
                    "America/Menominee",
                    "America/Merida",
                    "America/Metlakatla",
                    "America/Mexico_City",
                    "America/Miquelon",
                    "America/Moncton",
                    "America/Monterrey",
                    "America/Montevideo",
                    "America/Montreal",
                    "America/Montserrat",
                    "America/Nassau",
                    "America/New_York",
                    "America/Nipigon",
                    "America/Nome",
                    "America/Noronha",
                    "America/North_Dakota/Beulah",
                    "America/North_Dakota/Center",
                    "America/North_Dakota/New_Salem",
                    "America/Nuuk",
                    "America/Ojinaga",
                    "America/Panama",
                    "America/Pangnirtung",
                    "America/Paramaribo",
                    "America/Phoenix",
                    "America/Port-au-Prince",
                    "America/Port_of_Spain",
                    "America/Porto_Acre",
                    "America/Porto_Velho",
                    "America/Puerto_Rico",
                    "America/Punta_Arenas",
                    "America/Rainy_River",
                    "America/Rankin_Inlet",
                    "America/Recife",
                    "America/Regina",
                    "America/Resolute",
                    "America/Rio_Branco",
                    "America/Rosario",
                    "America/Santa_Isabel",
                    "America/Santarem",
                    "America/Santiago",
                    "America/Santo_Domingo",
                    "America/Sao_Paulo",
                    "America/Scoresbysund",
                    "America/Shiprock",
                    "America/Sitka",
                    "America/St_Barthelemy",
                    "America/St_Johns",
                    "America/St_Kitts",
                    "America/St_Lucia",
                    "America/St_Thomas",
                    "America/St_Vincent",
                    "America/Swift_Current",
                    "America/Tegucigalpa",
                    "America/Thule",
                    "America/Thunder_Bay",
                    "America/Tijuana",
                    "America/Toronto",
                    "America/Tortola",
                    "America/Vancouver",
                    "America/Virgin",
                    "America/Whitehorse",
                    "America/Winnipeg",
                    "America/Yakutat",
                    "America/Yellowknife",
                    "Antarctica/Casey",
                    "Antarctica/Davis",
                    "Antarctica/DumontDUrville",
                    "Antarctica/Macquarie",
                    "Antarctica/Mawson",
                    "Antarctica/McMurdo",
                    "Antarctica/Palmer",
                    "Antarctica/Rothera",
                    "Antarctica/South_Pole",
                    "Antarctica/Syowa",
                    "Antarctica/Troll",
                    "Antarctica/Vostok",
                    "Arctic/Longyearbyen",
                    "Asia/Aden",
                    "Asia/Almaty",
                    "Asia/Amman",
                    "Asia/Anadyr",
                    "Asia/Aqtau",
                    "Asia/Aqtobe",
                    "Asia/Ashgabat",
                    "Asia/Ashkhabad",
                    "Asia/Atyrau",
                    "Asia/Baghdad",
                    "Asia/Bahrain",
                    "Asia/Baku",
                    "Asia/Bangkok",
                    "Asia/Barnaul",
                    "Asia/Beirut",
                    "Asia/Bishkek",
                    "Asia/Brunei",
                    "Asia/Calcutta",
                    "Asia/Chita",
                    "Asia/Choibalsan",
                    "Asia/Chongqing",
                    "Asia/Chungking",
                    "Asia/Colombo",
                    "Asia/Dacca",
                    "Asia/Damascus",
                    "Asia/Dhaka",
                    "Asia/Dili",
                    "Asia/Dubai",
                    "Asia/Dushanbe",
                    "Asia/Famagusta",
                    "Asia/Gaza",
                    "Asia/Harbin",
                    "Asia/Hebron",
                    "Asia/Ho_Chi_Minh",
                    "Asia/Hong_Kong",
                    "Asia/Hovd",
                    "Asia/Irkutsk",
                    "Asia/Istanbul",
                    "Asia/Jakarta",
                    "Asia/Jayapura",
                    "Asia/Jerusalem",
                    "Asia/Kabul",
                    "Asia/Kamchatka",
                    "Asia/Karachi",
                    "Asia/Kashgar",
                    "Asia/Kathmandu",
                    "Asia/Katmandu",
                    "Asia/Khandyga",
                    "Asia/Kolkata",
                    "Asia/Krasnoyarsk",
                    "Asia/Kuala_Lumpur",
                    "Asia/Kuching",
                    "Asia/Kuwait",
                    "Asia/Macao",
                    "Asia/Macau",
                    "Asia/Magadan",
                    "Asia/Makassar",
                    "Asia/Manila",
                    "Asia/Muscat",
                    "Asia/Nicosia",
                    "Asia/Novokuznetsk",
                    "Asia/Novosibirsk",
                    "Asia/Omsk",
                    "Asia/Oral",
                    "Asia/Phnom_Penh",
                    "Asia/Pontianak",
                    "Asia/Pyongyang",
                    "Asia/Qatar",
                    "Asia/Qostanay",
                    "Asia/Qyzylorda",
                    "Asia/Rangoon",
                    "Asia/Riyadh",
                    "Asia/Saigon",
                    "Asia/Sakhalin",
                    "Asia/Samarkand",
                    "Asia/Seoul",
                    "Asia/Shanghai",
                    "Asia/Singapore",
                    "Asia/Srednekolymsk",
                    "Asia/Taipei",
                    "Asia/Tashkent",
                    "Asia/Tbilisi",
                    "Asia/Tehran",
                    "Asia/Tel_Aviv",
                    "Asia/Thimbu",
                    "Asia/Thimphu",
                    "Asia/Tokyo",
                    "Asia/Tomsk",
                    "Asia/Ujung_Pandang",
                    "Asia/Ulaanbaatar",
                    "Asia/Ulan_Bator",
                    "Asia/Urumqi",
                    "Asia/Ust-Nera",
                    "Asia/Vientiane",
                    "Asia/Vladivostok",
                    "Asia/Yakutsk",
                    "Asia/Yangon",
                    "Asia/Yekaterinburg",
                    "Asia/Yerevan",
                    "Atlantic/Azores",
                    "Atlantic/Bermuda",
                    "Atlantic/Canary",
                    "Atlantic/Cape_Verde",
                    "Atlantic/Faeroe",
                    "Atlantic/Faroe",
                    "Atlantic/Jan_Mayen",
                    "Atlantic/Madeira",
                    "Atlantic/Reykjavik",
                    "Atlantic/South_Georgia",
                    "Atlantic/St_Helena",
                    "Atlantic/Stanley",
                    "Australia/ACT",
                    "Australia/Adelaide",
                    "Australia/Brisbane",
                    "Australia/Broken_Hill",
                    "Australia/Canberra",
                    "Australia/Currie",
                    "Australia/Darwin",
                    "Australia/Eucla",
                    "Australia/Hobart",
                    "Australia/LHI",
                    "Australia/Lindeman",
                    "Australia/Lord_Howe",
                    "Australia/Melbourne",
                    "Australia/NSW",
                    "Australia/North",
                    "Australia/Perth",
                    "Australia/Queensland",
                    "Australia/South",
                    "Australia/Sydney",
                    "Australia/Tasmania",
                    "Australia/Victoria",
                    "Australia/West",
                    "Australia/Yancowinna",
                    "Brazil/Acre",
                    "Brazil/DeNoronha",
                    "Brazil/East",
                    "Brazil/West",
                    "CET",
                    "CST6CDT",
                    "Canada/Atlantic",
                    "Canada/Central",
                    "Canada/Eastern",
                    "Canada/Mountain",
                    "Canada/Newfoundland",
                    "Canada/Pacific",
                    "Canada/Saskatchewan",
                    "Canada/Yukon",
                    "Chile/Continental",
                    "Chile/EasterIsland",
                    "Cuba",
                    "EET",
                    "EST",
                    "EST5EDT",
                    "Egypt",
                    "Eire",
                    "Etc/GMT",
                    "Etc/GMT+0",
                    "Etc/GMT+1",
                    "Etc/GMT+10",
                    "Etc/GMT+11",
                    "Etc/GMT+12",
                    "Etc/GMT+2",
                    "Etc/GMT+3",
                    "Etc/GMT+4",
                    "Etc/GMT+5",
                    "Etc/GMT+6",
                    "Etc/GMT+7",
                    "Etc/GMT+8",
                    "Etc/GMT+9",
                    "Etc/GMT-0",
                    "Etc/GMT-1",
                    "Etc/GMT-10",
                    "Etc/GMT-11",
                    "Etc/GMT-12",
                    "Etc/GMT-13",
                    "Etc/GMT-14",
                    "Etc/GMT-2",
                    "Etc/GMT-3",
                    "Etc/GMT-4",
                    "Etc/GMT-5",
                    "Etc/GMT-6",
                    "Etc/GMT-7",
                    "Etc/GMT-8",
                    "Etc/GMT-9",
                    "Etc/GMT0",
                    "Etc/Greenwich",
                    "Etc/UCT",
                    "Etc/UTC",
                    "Etc/Universal",
                    "Etc/Zulu",
                    "Europe/Amsterdam",
                    "Europe/Andorra",
                    "Europe/Astrakhan",
                    "Europe/Athens",
                    "Europe/Belfast",
                    "Europe/Belgrade",
                    "Europe/Berlin",
                    "Europe/Bratislava",
                    "Europe/Brussels",
                    "Europe/Bucharest",
                    "Europe/Budapest",
                    "Europe/Busingen",
                    "Europe/Chisinau",
                    "Europe/Copenhagen",
                    "Europe/Dublin",
                    "Europe/Gibraltar",
                    "Europe/Guernsey",
                    "Europe/Helsinki",
                    "Europe/Isle_of_Man",
                    "Europe/Istanbul",
                    "Europe/Jersey",
                    "Europe/Kaliningrad",
                    "Europe/Kiev",
                    "Europe/Kirov",
                    "Europe/Kyiv",
                    "Europe/Lisbon",
                    "Europe/Ljubljana",
                    "Europe/London",
                    "Europe/Luxembourg",
                    "Europe/Madrid",
                    "Europe/Malta",
                    "Europe/Mariehamn",
                    "Europe/Minsk",
                    "Europe/Monaco",
                    "Europe/Moscow",
                    "Europe/Nicosia",
                    "Europe/Oslo",
                    "Europe/Paris",
                    "Europe/Podgorica",
                    "Europe/Prague",
                    "Europe/Riga",
                    "Europe/Rome",
                    "Europe/Samara",
                    "Europe/San_Marino",
                    "Europe/Sarajevo",
                    "Europe/Saratov",
                    "Europe/Simferopol",
                    "Europe/Skopje",
                    "Europe/Sofia",
                    "Europe/Stockholm",
                    "Europe/Tallinn",
                    "Europe/Tirane",
                    "Europe/Tiraspol",
                    "Europe/Ulyanovsk",
                    "Europe/Uzhgorod",
                    "Europe/Vaduz",
                    "Europe/Vatican",
                    "Europe/Vienna",
                    "Europe/Vilnius",
                    "Europe/Volgograd",
                    "Europe/Warsaw",
                    "Europe/Zagreb",
                    "Europe/Zaporozhye",
                    "Europe/Zurich",
                    "Factory",
                    "GB",
                    "GB-Eire",
                    "GMT",
                    "GMT+0",
                    "GMT-0",
                    "GMT0",
                    "Greenwich",
                    "HST",
                    "Hongkong",
                    "Iceland",
                    "Indian/Antananarivo",
                    "Indian/Chagos",
                    "Indian/Christmas",
                    "Indian/Cocos",
                    "Indian/Comoro",
                    "Indian/Kerguelen",
                    "Indian/Mahe",
                    "Indian/Maldives",
                    "Indian/Mauritius",
                    "Indian/Mayotte",
                    "Indian/Reunion",
                    "Iran",
                    "Israel",
                    "Jamaica",
                    "Japan",
                    "Kwajalein",
                    "Libya",
                    "MET",
                    "MST",
                    "MST7MDT",
                    "Mexico/BajaNorte",
                    "Mexico/BajaSur",
                    "Mexico/General",
                    "NZ",
                    "NZ-CHAT",
                    "Navajo",
                    "PRC",
                    "PST8PDT",
                    "Pacific/Apia",
                    "Pacific/Auckland",
                    "Pacific/Bougainville",
                    "Pacific/Chatham",
                    "Pacific/Chuuk",
                    "Pacific/Easter",
                    "Pacific/Efate",
                    "Pacific/Enderbury",
                    "Pacific/Fakaofo",
                    "Pacific/Fiji",
                    "Pacific/Funafuti",
                    "Pacific/Galapagos",
                    "Pacific/Gambier",
                    "Pacific/Guadalcanal",
                    "Pacific/Guam",
                    "Pacific/Honolulu",
                    "Pacific/Johnston",
                    "Pacific/Kanton",
                    "Pacific/Kiritimati",
                    "Pacific/Kosrae",
                    "Pacific/Kwajalein",
                    "Pacific/Majuro",
                    "Pacific/Marquesas",
                    "Pacific/Midway",
                    "Pacific/Nauru",
                    "Pacific/Niue",
                    "Pacific/Norfolk",
                    "Pacific/Noumea",
                    "Pacific/Pago_Pago",
                    "Pacific/Palau",
                    "Pacific/Pitcairn",
                    "Pacific/Pohnpei",
                    "Pacific/Ponape",
                    "Pacific/Port_Moresby",
                    "Pacific/Rarotonga",
                    "Pacific/Saipan",
                    "Pacific/Samoa",
                    "Pacific/Tahiti",
                    "Pacific/Tarawa",
                    "Pacific/Tongatapu",
                    "Pacific/Truk",
                    "Pacific/Wake",
                    "Pacific/Wallis",
                    "Pacific/Yap",
                    "Poland",
                    "Portugal",
                    "ROC",
                    "ROK",
                    "Singapore",
                    "Turkey",
                    "UCT",
                    "US/Alaska",
                    "US/Aleutian",
                    "US/Arizona",
                    "US/Central",
                    "US/East-Indiana",
                    "US/Eastern",
                    "US/Hawaii",
                    "US/Indiana-Starke",
                    "US/Michigan",
                    "US/Mountain",
                    "US/Pacific",
                    "US/Samoa",
                    "UTC",
                    "Universal",
                    "W-SU",
                    "WET",
                    "Zulu"
                  ],
                  "minLength": 1,
                  "title": "Timezone",
                  "type": "string"
                }
              },
              "required": [
                "city",
                "timezone"
              ],
              "title": "UserLocation",
              "type": "object"
            }
          },
          "properties": {
            "input": {
              "title": "Input",
              "type": "string"
            },
            "model": {
              "default": "gpt-4o-mini",
              "enum": [
                "gpt-4o",
                "gpt-4o-mini"
              ],
              "title": "Model",
              "type": "string"
            },
            "type": {
              "default": "web_search_preview",
              "enum": [
                "web_search_preview",
                "web_search_preview_2025_03_11"
              ],
              "title": "Type",
              "type": "string"
            },
            "search_context_size": {
              "default": "medium",
              "enum": [
                "low",
                "medium",
                "high"
              ],
              "title": "Search Context Size",
              "type": "string"
            },
            "user_location": {
              "$ref": "#/$defs/UserLocation",
              "default": null
            }
          },
          "required": [
            "input"
          ],
          "title": "web_searchArguments",
          "type": "object"
        }
      }
    ]
  },
  "linear": {
    "name": "linear",
    "display_name": "Linear",
    "description": "Allows LLM to interact with Linear's API for project management, including searching, creating, and updating issues.",
    "repository": {
      "type": "git",
      "url": "https://github.com/jerhadf/linear-mcp-server"
    },
    "homepage": "https://github.com/jerhadf/linear-mcp-server",
    "author": {
      "name": "jerhadf"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "linear",
      "issue tracking",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "linear-mcp-server"
        ],
        "env": {
          "LINEAR_API_KEY": "${LINEAR_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Show me all my high-priority issues",
        "description": "Execute the search_issues tool and/or linear-user:///{userId}/assigned to find issues assigned to the user with priority 1",
        "prompt": "Show me all my high-priority issues"
      },
      {
        "title": "Create a bug report",
        "description": "Use create_issue to create a new high-priority issue with appropriate details and status tracking.",
        "prompt": "Based on what I've told you about this bug already, make a bug report for the authentication system"
      },
      {
        "title": "Find all in-progress frontend tasks",
        "description": "Use search_issues to locate frontend-related issues with in progress status.",
        "prompt": "Find all in progress frontend tasks"
      },
      {
        "title": "Get summary of recent updates",
        "description": "Use search_issues to identify relevant issue(s) and fetch the issue details.",
        "prompt": "Give me a summary of recent updates on the issues for mobile app development"
      },
      {
        "title": "Analyze current workload for the mobile team",
        "description": "Combine linear-team:///{teamId}/issues and search_issues to analyze issue distribution and priorities across the mobile team.",
        "prompt": "What's the current workload for the mobile team?"
      }
    ],
    "arguments": {
      "LINEAR_API_KEY": {
        "description": "Your Linear API key to authenticate requests to the Linear API.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "linear_create_issue",
        "description": "Creates a new Linear issue with specified details. Use this to create tickets for tasks, bugs, or feature requests. Returns the created issue's identifier and URL. Required fields are title and teamId, with optional description, priority (0-4, where 0 is no priority and 1 is urgent), and status.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "Issue title"
            },
            "teamId": {
              "type": "string",
              "description": "Team ID"
            },
            "description": {
              "type": "string",
              "description": "Issue description"
            },
            "priority": {
              "type": "number",
              "description": "Priority (0-4)"
            },
            "status": {
              "type": "string",
              "description": "Issue status"
            }
          },
          "required": [
            "title",
            "teamId"
          ]
        }
      },
      {
        "name": "linear_update_issue",
        "description": "Updates an existing Linear issue's properties. Use this to modify issue details like title, description, priority, or status. Requires the issue ID and accepts any combination of updatable fields. Returns the updated issue's identifier and URL.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Issue ID"
            },
            "title": {
              "type": "string",
              "description": "New title"
            },
            "description": {
              "type": "string",
              "description": "New description"
            },
            "priority": {
              "type": "number",
              "description": "New priority (0-4)"
            },
            "status": {
              "type": "string",
              "description": "New status"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "linear_search_issues",
        "description": "Searches Linear issues using flexible criteria. Supports filtering by any combination of: title/description text, team, status, assignee, labels, priority (1=urgent, 2=high, 3=normal, 4=low), and estimate. Returns up to 10 issues by default (configurable via limit).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Optional text to search in title and description"
            },
            "teamId": {
              "type": "string",
              "description": "Filter by team ID"
            },
            "status": {
              "type": "string",
              "description": "Filter by status name (e.g., 'In Progress', 'Done')"
            },
            "assigneeId": {
              "type": "string",
              "description": "Filter by assignee's user ID"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter by label names"
            },
            "priority": {
              "type": "number",
              "description": "Filter by priority (1=urgent, 2=high, 3=normal, 4=low)"
            },
            "estimate": {
              "type": "number",
              "description": "Filter by estimate points"
            },
            "includeArchived": {
              "type": "boolean",
              "description": "Include archived issues in results (default: false)"
            },
            "limit": {
              "type": "number",
              "description": "Max results to return (default: 10)"
            }
          }
        }
      },
      {
        "name": "linear_get_user_issues",
        "description": "Retrieves issues assigned to a specific user or the authenticated user if no userId is provided. Returns issues sorted by last updated, including priority, status, and other metadata. Useful for finding a user's workload or tracking assigned tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "userId": {
              "type": "string",
              "description": "Optional user ID. If not provided, returns authenticated user's issues"
            },
            "includeArchived": {
              "type": "boolean",
              "description": "Include archived issues in results"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of issues to return (default: 50)"
            }
          }
        }
      },
      {
        "name": "linear_add_comment",
        "description": "Adds a comment to an existing Linear issue. Supports markdown formatting in the comment body. Can optionally specify a custom user name and avatar for the comment. Returns the created comment's details including its URL.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID of the issue to comment on"
            },
            "body": {
              "type": "string",
              "description": "Comment text in markdown format"
            },
            "createAsUser": {
              "type": "string",
              "description": "Optional custom username to show for the comment"
            },
            "displayIconUrl": {
              "type": "string",
              "description": "Optional avatar URL for the comment"
            }
          },
          "required": [
            "issueId",
            "body"
          ]
        }
      }
    ]
  },
  "mcp-create": {
    "name": "mcp-create",
    "display_name": "Create Server",
    "description": "A dynamic MCP server management service that creates, runs, and manages Model Context Protocol servers on-the-fly.",
    "repository": {
      "type": "git",
      "url": "https://github.com/tesla0225/mcp-create"
    },
    "homepage": "https://github.com/tesla0225/mcp-create",
    "author": {
      "name": "tesla0225"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "dynamic",
      "TypeScript"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/tesla0225/mcp-create"
        ]
      }
    },
    "examples": [
      {
        "title": "Creating a New Server",
        "description": "Example of creating a new server using TypeScript.",
        "prompt": "{\"name\":\"create-server-from-template\",\"arguments\":{\"language\":\"typescript\"}}"
      },
      {
        "title": "Executing a Tool",
        "description": "Example of executing a tool on a server.",
        "prompt": "{\"name\":\"execute-tool\",\"arguments\":{\"serverId\":\"ba7c9a4f-6ba8-4cad-8ec8-a41a08c19fac\",\"toolName\":\"echo\",\"args\":{\"message\":\"Hello, dynamic MCP server!\"}}}"
      }
    ]
  },
  "thirdweb": {
    "display_name": "thirdweb MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/thirdweb-dev/ai"
    },
    "homepage": "https://thirdweb.com",
    "author": {
      "name": "thirdweb-dev"
    },
    "license": "Apache-2.0",
    "tags": [
      "blockchain",
      "mcp",
      "thirdweb",
      "web3",
      "ipfs"
    ],
    "arguments": {
      "THIRDWEB_SECRET_KEY": {
        "description": "Your thirdweb API secret key from dashboard",
        "required": true,
        "example": "your-secret-key"
      },
      "THIRDWEB_ENGINE_URL": {
        "description": "URL endpoint for thirdweb Engine service",
        "required": false,
        "example": "https://your-engine-url"
      },
      "THIRDWEB_ENGINE_AUTH_JWT": {
        "description": "Authentication JWT token for Engine",
        "required": false,
        "example": "your-jwt-token"
      },
      "THIRDWEB_ENGINE_BACKEND_WALLET_ADDRESS": {
        "description": "Wallet address for Engine backend",
        "required": false,
        "example": "0x..."
      },
      "chain-id": {
        "description": "Blockchain network IDs to connect to (e.g., 1 for Ethereum mainnet, 137 for Polygon)",
        "required": false,
        "example": "1"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "thirdweb-mcp"
        ],
        "env": {
          "THIRDWEB_SECRET_KEY": "your-secret-key"
        },
        "description": "Run with uvx package manager",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Basic Usage",
        "description": "Basic usage with default settings (stdio transport with Nebula and Insight)",
        "prompt": "THIRDWEB_SECRET_KEY=... thirdweb-mcp"
      },
      {
        "title": "SSE Transport",
        "description": "Using SSE transport on a custom port",
        "prompt": "THIRDWEB_SECRET_KEY=... thirdweb-mcp --transport sse --port 8080"
      },
      {
        "title": "Full Configuration",
        "description": "Enabling all services with specific chain IDs",
        "prompt": "THIRDWEB_SECRET_KEY=... thirdweb-mcp --chain-id 1 --chain-id 137 \\\n    --engine-url YOUR_ENGINE_URL \\\n    --engine-auth-jwt YOUR_ENGINE_JWT \\\n    --engine-backend-wallet-address YOUR_ENGINE_BACKEND_WALLET_ADDRESS"
      }
    ],
    "name": "thirdweb",
    "description": "Read/write to over 2k blockchains, enabling data querying, contract analysis/deployment, and transaction execution, powered by Thirdweb",
    "categories": [
      "AI Systems"
    ],
    "tools": [
      {
        "name": "chat",
        "description": "Send a message to Nebula AI and get a response. This can be used for blockchain queries, contract interactions, and access to thirdweb tools.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "description": "The natural language message to process. Can be a question about blockchain data, a request to execute a transaction, or any web3-related query.",
              "title": "Message",
              "type": "string"
            },
            "session_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Optional session ID to maintain conversation context. If provided, this message will be part of an ongoing conversation; if omitted, a new session is created.",
              "title": "Session Id"
            },
            "context": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Contextual information for processing the request, including: chainIds (array of chain identifiers) and walletAddress (user's wallet for transaction signing). Example: {'chainIds': ['1', '137'], 'walletAddress': '0x123...'}",
              "title": "Context"
            }
          },
          "required": [
            "message"
          ]
        }
      },
      {
        "name": "get_session",
        "description": "Fetch complete information about a specific Nebula AI session, including conversation history, context settings, and metadata. Use this to examine past interactions or resume an existing conversation thread.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "session_id": {
              "description": "Unique identifier for the target session. This UUID references a specific conversation history in the Nebula system.",
              "title": "Session Id",
              "type": "string"
            }
          },
          "required": [
            "session_id"
          ]
        }
      },
      {
        "name": "list_sessions",
        "description": "Retrieve all available Nebula AI sessions for the authenticated account. Returns an array of session metadata including IDs, titles, and creation timestamps, allowing you to find and reference existing conversations.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "decode_signature",
        "description": "Decode a function or event signature. Use this when you need to understand what a specific function selector or event signature does and what parameters it accepts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "signature": {
              "description": "Function or event signature to decode (e.g., '0x095ea7b3' for the approve function). Usually begins with 0x.",
              "title": "Signature",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum). Specify to improve signature lookup accuracy.",
              "title": "Chain"
            }
          },
          "required": [
            "signature"
          ]
        }
      },
      {
        "name": "get_address_transactions",
        "description": "Look up transactions for a wallet or contract address. Use this when asked about a specific Ethereum address (e.g., '0x1234...') to get account details including balance, transaction count, and contract verification status. This tool is specifically for addresses (accounts and contracts), NOT transaction hashes or ENS names.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "description": "Wallet or contract address to look up (e.g., '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045' for Vitalik's address). Must be a valid blockchain address starting with 0x and 42 characters long.",
              "title": "Address",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum). Specify the blockchain network for the address.",
              "title": "Chain"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_all_events",
        "description": "Retrieve blockchain events with flexible filtering options. Use this to search for specific events or to analyze event patterns across multiple blocks. Do not use this tool to simply look up a single transaction.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum Mainnet, 137 for Polygon). Specify multiple IDs as a list [1, 137] for cross-chain queries (max 5).",
              "title": "Chain"
            },
            "contract_address": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Contract address to filter events by (e.g., '0x1234...'). Only return events emitted by this contract.",
              "title": "Contract Address"
            },
            "block_number_gte": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Minimum block number to start querying from (inclusive).",
              "title": "Block Number Gte"
            },
            "block_number_lt": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Maximum block number to query up to (exclusive).",
              "title": "Block Number Lt"
            },
            "transaction_hash": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Specific transaction hash to filter events by (e.g., '0xabc123...'). Useful for examining events in a particular transaction.",
              "title": "Transaction Hash"
            },
            "topic_0": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter by event signature hash (first topic). For example, '0xa6697e974e6a320f454390be03f74955e8978f1a6971ea6730542e37b66179bc' for Transfer events.",
              "title": "Topic 0"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Maximum number of events to return per request. Default is 20, adjust for pagination.",
              "title": "Limit"
            },
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Page number for paginated results, starting from 0. Use with limit parameter.",
              "title": "Page"
            },
            "sort_order": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "desc",
              "description": "Sort order for the events. Default is 'desc' for descending order. Use 'asc' for ascending order.",
              "title": "Sort Order"
            }
          },
          "required": []
        }
      },
      {
        "name": "get_all_transactions",
        "description": "Retrieve blockchain transactions with flexible filtering options. Use this to analyze transaction patterns, track specific transactions, or monitor wallet activity.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum, 137 for Polygon). Specify multiple IDs as a list for cross-chain queries.",
              "title": "Chain"
            },
            "from_address": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter transactions sent from this address (e.g., '0x1234...'). Useful for tracking outgoing transactions from a wallet.",
              "title": "From Address"
            },
            "to_address": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter transactions sent to this address (e.g., '0x1234...'). Useful for tracking incoming transactions to a contract or wallet.",
              "title": "To Address"
            },
            "function_selector": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter by function selector (e.g., '0x095ea7b3' for the approve function). Useful for finding specific contract interactions.",
              "title": "Function Selector"
            },
            "sort_order": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "desc",
              "description": "Sort order for the transactions. Default is 'asc' for ascending order. Use 'desc' for descending order.",
              "title": "Sort Order"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Maximum number of transactions to return per request. Default is 20, adjust based on your needs.",
              "title": "Limit"
            },
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Page number for paginated results, starting from 0. Use with limit parameter for browsing large result sets.",
              "title": "Page"
            }
          },
          "required": []
        }
      },
      {
        "name": "get_block_details",
        "description": "Get detailed information about a specific block by its number or hash. Use this when asked about blockchain blocks (e.g., 'What's in block 12345678?' or 'Tell me about this block: 0xabc123...'). This tool is specifically for block data, NOT transactions, addresses, or contracts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "block_identifier": {
              "description": "Block number or block hash to look up. Can be either a simple number (e.g., '12345678') or a block hash (e.g., '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3' for Ethereum block 0). Use for queries like 'what happened in block 14000000' or 'show me block 0xd4e56...'.",
              "title": "Block Identifier",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum). Specify the blockchain network where the block exists.",
              "title": "Chain"
            }
          },
          "required": [
            "block_identifier"
          ]
        }
      },
      {
        "name": "get_contract_events",
        "description": "Retrieve events from a specific contract address. Use this to analyze activity or monitor events for a particular smart contract.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_address": {
              "description": "The contract address to query events for (e.g., '0x1234...'). Must be a valid Ethereum address.",
              "title": "Contract Address",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum Mainnet, 137 for Polygon). Specify multiple IDs as a list for cross-chain queries (max 5).",
              "title": "Chain"
            },
            "block_number_gte": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Only return events from blocks with number greater than or equal to this value. Useful for querying recent history.",
              "title": "Block Number Gte"
            },
            "topic_0": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter by event signature hash (first topic). For example, Transfer event has a specific signature hash.",
              "title": "Topic 0"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Maximum number of events to return per request. Default is 20, increase for more results.",
              "title": "Limit"
            },
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Page number for paginated results, starting from 0. Use with limit parameter for browsing large result sets.",
              "title": "Page"
            },
            "sort_order": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "desc",
              "description": "Sort order for the events. Default is 'desc' for descending order. Use 'asc' for ascending order.",
              "title": "Sort Order"
            }
          },
          "required": [
            "contract_address"
          ]
        }
      },
      {
        "name": "get_contract_metadata",
        "description": "Get contract ABI and metadata about a smart contract, including name, symbol, decimals, and other contract-specific information. Use this when asked about a contract's functions, interface, or capabilities. This tool specifically retrieves details about deployed smart contracts (NOT regular wallet addresses or transaction hashes).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_address": {
              "description": "The contract address to get metadata for (e.g., '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' for WETH). Must be a deployed smart contract address (not a regular wallet). Use this for queries like 'what functions does this contract have' or 'get the ABI for contract 0x1234...'.",
              "title": "Contract Address",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) where the contract is deployed (e.g., 1 for Ethereum). Specify the correct network.",
              "title": "Chain"
            }
          },
          "required": [
            "contract_address"
          ]
        }
      },
      {
        "name": "get_ens_transactions",
        "description": "Look up transactions associated with an ENS domain name (anything ending in .eth like 'vitalik.eth'). This tool is specifically for ENS domains, NOT addresses, transaction hashes, or contract queries.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ens_name": {
              "description": "ENS name to resolve (e.g., 'vitalik.eth', 'thirdweb.eth'). Must be a valid ENS domain ending with .eth.",
              "title": "Ens Name",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum). ENS is primarily on Ethereum mainnet.",
              "title": "Chain"
            }
          },
          "required": [
            "ens_name"
          ]
        }
      },
      {
        "name": "get_erc1155_tokens",
        "description": "Retrieve ERC1155 tokens (semi-fungible tokens) owned by a specified address. Shows balances of multi-token contracts with metadata.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner_address": {
              "description": "The wallet address to get ERC1155 tokens for (e.g., '0x1234...'). Returns all token IDs and their quantities.",
              "title": "Owner Address",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum, 137 for Polygon). Specify multiple IDs as a list for cross-chain queries.",
              "title": "Chain"
            },
            "include_price": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Set to True to include estimated prices for tokens where available. Useful for valuation.",
              "title": "Include Price"
            },
            "include_spam": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Set to True to include suspected spam tokens. Default is False to filter out potentially unwanted items.",
              "title": "Include Spam"
            }
          },
          "required": [
            "owner_address"
          ]
        }
      },
      {
        "name": "get_erc20_tokens",
        "description": "Retrieve ERC20 token balances for a specified address. Lists all fungible tokens owned with their balances, metadata, and optionally prices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner_address": {
              "description": "The wallet address to get ERC20 token balances for (e.g., '0x1234...'). Must be a valid Ethereum address.",
              "title": "Owner Address",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum, 137 for Polygon). Specify multiple IDs as a list for cross-chain queries.",
              "title": "Chain"
            },
            "include_price": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Set to True to include current market prices for tokens. Useful for calculating portfolio value.",
              "title": "Include Price"
            },
            "include_spam": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Set to True to include suspected spam tokens. Default is False to filter out unwanted tokens.",
              "title": "Include Spam"
            }
          },
          "required": [
            "owner_address"
          ]
        }
      },
      {
        "name": "get_erc721_tokens",
        "description": "Retrieve ERC721 NFTs (non-fungible tokens) owned by a specified address. Lists all unique NFTs with their metadata and optionally prices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner_address": {
              "description": "The wallet address to get ERC721 NFTs for (e.g., '0x1234...'). Returns all NFTs owned by this address.",
              "title": "Owner Address",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum, 137 for Polygon). Specify multiple IDs as a list for cross-chain queries.",
              "title": "Chain"
            },
            "include_price": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Set to True to include estimated prices for NFTs where available. Useful for valuation.",
              "title": "Include Price"
            },
            "include_spam": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Set to True to include suspected spam NFTs. Default is False to filter out potentially unwanted items.",
              "title": "Include Spam"
            }
          },
          "required": [
            "owner_address"
          ]
        }
      },
      {
        "name": "get_nft_owners",
        "description": "Get ownership information for NFTs in a specific collection. Shows which addresses own which token IDs and in what quantities.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_address": {
              "description": "The NFT contract address to query ownership for (e.g., '0x1234...'). Must be an ERC721 or ERC1155 contract.",
              "title": "Contract Address",
              "type": "string"
            },
            "token_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Specific token ID to query owners for (e.g., '42'). If provided, shows all owners of this specific NFT.",
              "title": "Token Id"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) where the NFT contract is deployed (e.g., 1 for Ethereum). Specify the correct network.",
              "title": "Chain"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Maximum number of ownership records to return per request. Default is 20, adjust for pagination.",
              "title": "Limit"
            },
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Page number for paginated results, starting from 0. Use with limit parameter for browsing large collections.",
              "title": "Page"
            }
          },
          "required": [
            "contract_address"
          ]
        }
      },
      {
        "name": "get_nft_transfers",
        "description": "Track NFT transfers for a collection, specific token, or transaction. Useful for monitoring NFT trading activity or verifying transfers.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_address": {
              "description": "The NFT contract address to query transfers for (e.g., '0x1234...'). Must be an ERC721 or ERC1155 contract.",
              "title": "Contract Address",
              "type": "string"
            },
            "token_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Specific token ID to query transfers for (e.g., '42'). If provided, only shows transfers of this NFT.",
              "title": "Token Id"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum). Specify the chain where the NFT contract is deployed.",
              "title": "Chain"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Maximum number of transfer records to return per request. Default is 20, adjust for pagination.",
              "title": "Limit"
            },
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Page number for paginated results, starting from 0. Use with limit parameter for browsing transfer history.",
              "title": "Page"
            }
          },
          "required": [
            "contract_address"
          ]
        }
      },
      {
        "name": "get_nfts",
        "description": "Retrieve detailed information about NFTs from a specific collection, including metadata, attributes, and images. Optionally get data for a specific token ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_address": {
              "description": "The NFT contract address to query (e.g., '0x1234...'). Must be an ERC721 or ERC1155 contract.",
              "title": "Contract Address",
              "type": "string"
            },
            "token_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Specific token ID to query (e.g., '42'). If provided, returns data only for this NFT. Otherwise returns collection data.",
              "title": "Token Id"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) where the NFT contract is deployed (e.g., 1 for Ethereum). Specify the correct network.",
              "title": "Chain"
            },
            "include_metadata": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Set to True to include full NFT metadata like attributes, image URL, etc. Useful for displaying NFT details.",
              "title": "Include Metadata"
            }
          },
          "required": [
            "contract_address"
          ]
        }
      },
      {
        "name": "get_token_prices",
        "description": "Get current market prices for native and ERC20 tokens. Useful for valuation, tracking portfolio value, or monitoring price changes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "token_addresses": {
              "description": "List of token contract addresses to get prices for (e.g., ['0x1234...', '0x5678...']). Can include ERC20 tokens. Use '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' for native tokens (ETH, POL, MATIC, etc.).",
              "items": {
                "type": "string"
              },
              "title": "Token Addresses",
              "type": "array"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) where the tokens exist (e.g., 1 for Ethereum, 137 for Polygon). Must match the token network.",
              "title": "Chain"
            }
          },
          "required": [
            "token_addresses"
          ]
        }
      },
      {
        "name": "get_transaction_details",
        "description": "Get detailed information about a specific transaction by its hash. Use this when asked to analyze, look up, check, or get details about a transaction hash (e.g., 'What can you tell me about this transaction: 0x5407ea41...'). This tool specifically deals with transaction hashes (txid/txhash), NOT addresses, contracts, or ENS names.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "transaction_hash": {
              "description": "Transaction hash to look up (e.g., '0x5407ea41de24b7353d70eab42d72c92b42a44e140f930e349973cfc7b8c9c1d7'). Must be a valid transaction hash beginning with 0x and typically 66 characters long. Use this for queries like 'tell me about this transaction' or 'what happened in transaction 0x1234...'.",
              "title": "Transaction Hash",
              "type": "string"
            },
            "chain": {
              "anyOf": [
                {
                  "items": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "type": "array"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Chain ID(s) to query (e.g., 1 for Ethereum). Specify the blockchain network where the transaction exists.",
              "title": "Chain"
            }
          },
          "required": [
            "transaction_hash"
          ]
        }
      },
      {
        "name": "fetch_ipfs_content",
        "description": "Fetch content from IPFS by hash. Retrieves data stored on IPFS using the thirdweb gateway.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ipfs_hash": {
              "description": "The IPFS hash/URI to fetch content from (e.g., 'ipfs://QmXyZ...'). Must start with 'ipfs://'.",
              "title": "Ipfs Hash",
              "type": "string"
            }
          },
          "required": [
            "ipfs_hash"
          ]
        }
      },
      {
        "name": "upload_to_ipfs",
        "description": "Upload a file, directory, or JSON data to IPFS. Stores any type on decentralized storage and returns an IPFS URI.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "description": "Data to upload: can be a file path, directory path, dict, dataclass, or BaseModel instance.",
              "title": "Data"
            }
          },
          "required": [
            "data"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "okta": {
    "name": "okta",
    "display_name": "Okta",
    "description": "Interact with Okta API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kapilduraphe/okta-mcp-server"
    },
    "homepage": "https://github.com/kapilduraphe/okta-mcp-server",
    "author": {
      "name": "kapilduraphe"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Okta",
      "user management",
      "group management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/kapilduraphe/okta-mcp-server"
        ],
        "env": {
          "OKTA_ORG_URL": "${OKTA_ORG_URL}",
          "OKTA_API_TOKEN": "${OKTA_API_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Show user details",
        "description": "Retrieve details for a specific user.",
        "prompt": "Show me details for user with userId XXXX"
      },
      {
        "title": "Check user status",
        "description": "Get the status of a specific user.",
        "prompt": "What's the status of user john.doe@company.com"
      },
      {
        "title": "Last login info",
        "description": "Find out when a user last logged in.",
        "prompt": "When was the last login for user jane.smith@organization.com"
      },
      {
        "title": "List users by department",
        "description": "Get a list of all users in the marketing department.",
        "prompt": "List all users in the marketing department"
      },
      {
        "title": "Find recent users",
        "description": "Retrieve users created in the last month.",
        "prompt": "Find users created in the last month"
      },
      {
        "title": "Show user groups",
        "description": "List all groups in the Okta organization.",
        "prompt": "Show me all the groups in my Okta organization"
      },
      {
        "title": "Admin groups",
        "description": "List groups that contain the word 'admin'.",
        "prompt": "List groups containing the word 'admin'"
      }
    ],
    "arguments": {
      "OKTA_ORG_URL": {
        "description": "The base URL for your Okta organization, should include 'https://'.",
        "required": true,
        "example": "https://dev-123456.okta.com"
      },
      "OKTA_API_TOKEN": {
        "description": "A valid API token used to authenticate API requests to Okta.",
        "required": true
      }
    }
  },
  "base-free-usdc-transfer": {
    "name": "base-free-usdc-transfer",
    "display_name": "Free USDC Transfer",
    "description": "Send USDC on [Base](https://base.org/) for free using Claude AI! Built with [Coinbase CDP](https://docs.cdp.coinbase.com/mpc-wallet/docs/welcome).",
    "repository": {
      "type": "git",
      "url": "https://github.com/magnetai/mcp-free-usdc-transfer"
    },
    "homepage": "https://github.com/magnetai/mcp-free-usdc-transfer",
    "author": {
      "name": "magnetai"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "USDC",
      "Base",
      "Coinbase",
      "MPC Wallet"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@magnetai/free-usdc-transfer"
        ],
        "env": {
          "COINBASE_CDP_API_KEY_NAME": "${COINBASE_CDP_API_KEY_NAME}",
          "COINBASE_CDP_PRIVATE_KEY": "${COINBASE_CDP_PRIVATE_KEY}"
        }
      }
    },
    "arguments": {
      "COINBASE_CDP_API_KEY_NAME": {
        "description": "The name of your Coinbase CDP API key, which is required for authenticating API requests.",
        "required": true,
        "example": "my_api_key_name"
      }
    },
    "tools": [
      {
        "name": "tranfer-usdc",
        "description": "Analyze the value of the purchased items and transfer USDC to the recipient via the Base chain. Due to the uncertainty of blockchain transaction times, the transaction is only scheduled here and will not wait for the transaction to be completed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "usdc_amount": {
              "type": "number",
              "description": "USDC amount, greater than 0"
            },
            "recipient": {
              "type": "string",
              "description": "Recipient's on-chain address or ENS addresses ending in .eth"
            }
          },
          "required": [
            "usdc_amount",
            "recipient"
          ]
        }
      },
      {
        "name": "create_coinbase_mpc_wallet",
        "description": "Used to create your Coinbase MPC wallet address. The newly created wallet cannot be used directly; the user must first deposit USDC. The transfer after creation requires user confirmation",
        "inputSchema": {
          "type": "object"
        }
      }
    ]
  },
  "mariadb": {
    "name": "mariadb",
    "display_name": "MariaDB Database Integration",
    "description": "MariaDB database integration with configurable access controls in Python.",
    "repository": {
      "type": "git",
      "url": "https://github.com/abel9851/mcp-server-mariadb"
    },
    "homepage": "https://github.com/abel9851/mcp-server-mariadb",
    "author": {
      "name": "abel9851"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "MariaDB",
      "Data Retrieval"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-mariadb",
          "--host",
          "${DB_HOST}",
          "--port",
          "${DB_PORT}",
          "--user",
          "${DB_USER}",
          "--password",
          "${DB_PASSWORD}",
          "--database",
          "${DB_NAME}"
        ]
      }
    },
    "examples": [
      {
        "title": "Query Database",
        "description": "Example of executing a read-only operation against MariaDB.",
        "prompt": "Execute read-only operations against your MariaDB database."
      }
    ],
    "arguments": {
      "DB_HOST": {
        "description": "The hostname of the MariaDB server to connect to.",
        "required": true,
        "example": "localhost"
      },
      "DB_PORT": {
        "description": "The port number on which the MariaDB server is listening.",
        "required": true,
        "example": "3306"
      },
      "DB_USER": {
        "description": "The username to connect to the MariaDB database.",
        "required": true,
        "example": "root"
      },
      "DB_PASSWORD": {
        "description": "The password for the MariaDB user.",
        "required": true
      },
      "DB_NAME": {
        "description": "The name of the database to connect to.",
        "required": true
      }
    },
    "tools": [
      {
        "name": "query_database",
        "description": "Execute a read-only operation against the MariaDB database.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "servicenow": {
    "name": "servicenow",
    "display_name": "ServiceNow",
    "description": "A MCP server to interact with a ServiceNow instance",
    "repository": {
      "type": "git",
      "url": "https://github.com/osomai/servicenow-mcp"
    },
    "homepage": "https://github.com/osomai/servicenow-mcp",
    "author": {
      "name": "osomai"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "ServiceNow",
      "Automation"
    ],
    "examples": [
      {
        "title": "Incident Management - Creating an Incident",
        "description": "Create a new incident for a network outage in the east region.",
        "prompt": "Create a new incident for a network outage in the east region."
      },
      {
        "title": "Service Catalog - List Items",
        "description": "Show me all items in the service catalog.",
        "prompt": "Show me all items in the service catalog."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/osomai/servicenow-mcp",
          "servicenow-mcp"
        ],
        "env": {
          "SERVICENOW_INSTANCE_URL": "${SERVICENOW_INSTANCE_URL}",
          "SERVICENOW_USERNAME": "${SERVICENOW_USERNAME}",
          "SERVICENOW_PASSWORD": "${SERVICENOW_PASSWORD}",
          "SERVICENOW_AUTH_TYPE": "${SERVICENOW_AUTH_TYPE}"
        }
      }
    },
    "arguments": {
      "SERVICENOW_INSTANCE_URL": {
        "description": "URL of the ServiceNow instance to connect to.",
        "required": true,
        "example": "https://your-instance.service-now.com"
      },
      "SERVICENOW_USERNAME": {
        "description": "Username for accessing the ServiceNow instance.",
        "required": true,
        "example": "your-username"
      },
      "SERVICENOW_PASSWORD": {
        "description": "Password for the ServiceNow username.",
        "required": true,
        "example": "your-password"
      },
      "SERVICENOW_AUTH_TYPE": {
        "description": "Authentication type for connecting to ServiceNow. Options are 'basic', 'oauth', or 'api_key'.",
        "required": true,
        "example": "basic"
      }
    },
    "tools": [
      {
        "name": "create_incident",
        "description": "Create a new incident in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateIncidentParams": {
              "description": "Parameters for creating an incident.",
              "properties": {
                "short_description": {
                  "description": "Short description of the incident",
                  "title": "Short Description",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the incident",
                  "title": "Description"
                },
                "caller_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User who reported the incident",
                  "title": "Caller Id"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Category of the incident",
                  "title": "Category"
                },
                "subcategory": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Subcategory of the incident",
                  "title": "Subcategory"
                },
                "priority": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Priority of the incident",
                  "title": "Priority"
                },
                "impact": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Impact of the incident",
                  "title": "Impact"
                },
                "urgency": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Urgency of the incident",
                  "title": "Urgency"
                },
                "assigned_to": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User assigned to the incident",
                  "title": "Assigned To"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Group assigned to the incident",
                  "title": "Assignment Group"
                }
              },
              "required": [
                "short_description"
              ],
              "title": "CreateIncidentParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateIncidentParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_incidentArguments",
          "type": "object"
        }
      },
      {
        "name": "update_incident",
        "description": "Update an existing incident in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateIncidentParams": {
              "description": "Parameters for updating an incident.",
              "properties": {
                "incident_id": {
                  "description": "Incident ID or sys_id",
                  "title": "Incident Id",
                  "type": "string"
                },
                "short_description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Short description of the incident",
                  "title": "Short Description"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the incident",
                  "title": "Description"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "State of the incident",
                  "title": "State"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Category of the incident",
                  "title": "Category"
                },
                "subcategory": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Subcategory of the incident",
                  "title": "Subcategory"
                },
                "priority": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Priority of the incident",
                  "title": "Priority"
                },
                "impact": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Impact of the incident",
                  "title": "Impact"
                },
                "urgency": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Urgency of the incident",
                  "title": "Urgency"
                },
                "assigned_to": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User assigned to the incident",
                  "title": "Assigned To"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Group assigned to the incident",
                  "title": "Assignment Group"
                },
                "work_notes": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Work notes to add to the incident",
                  "title": "Work Notes"
                },
                "close_notes": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Close notes to add to the incident",
                  "title": "Close Notes"
                },
                "close_code": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Close code for the incident",
                  "title": "Close Code"
                }
              },
              "required": [
                "incident_id"
              ],
              "title": "UpdateIncidentParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateIncidentParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_incidentArguments",
          "type": "object"
        }
      },
      {
        "name": "add_comment",
        "description": "Add a comment to an incident in ServiceNow",
        "inputSchema": {
          "$defs": {
            "AddCommentParams": {
              "description": "Parameters for adding a comment to an incident.",
              "properties": {
                "incident_id": {
                  "description": "Incident ID or sys_id",
                  "title": "Incident Id",
                  "type": "string"
                },
                "comment": {
                  "description": "Comment to add to the incident",
                  "title": "Comment",
                  "type": "string"
                },
                "is_work_note": {
                  "default": false,
                  "description": "Whether the comment is a work note",
                  "title": "Is Work Note",
                  "type": "boolean"
                }
              },
              "required": [
                "incident_id",
                "comment"
              ],
              "title": "AddCommentParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddCommentParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_commentArguments",
          "type": "object"
        }
      },
      {
        "name": "resolve_incident",
        "description": "Resolve an incident in ServiceNow",
        "inputSchema": {
          "$defs": {
            "ResolveIncidentParams": {
              "description": "Parameters for resolving an incident.",
              "properties": {
                "incident_id": {
                  "description": "Incident ID or sys_id",
                  "title": "Incident Id",
                  "type": "string"
                },
                "resolution_code": {
                  "description": "Resolution code for the incident",
                  "title": "Resolution Code",
                  "type": "string"
                },
                "resolution_notes": {
                  "description": "Resolution notes for the incident",
                  "title": "Resolution Notes",
                  "type": "string"
                }
              },
              "required": [
                "incident_id",
                "resolution_code",
                "resolution_notes"
              ],
              "title": "ResolveIncidentParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ResolveIncidentParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "resolve_incidentArguments",
          "type": "object"
        }
      },
      {
        "name": "list_incidents",
        "description": "List incidents from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListIncidentsParams": {
              "description": "Parameters for listing incidents.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of incidents to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by incident state",
                  "title": "State"
                },
                "assigned_to": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by assigned user",
                  "title": "Assigned To"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by category",
                  "title": "Category"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for incidents",
                  "title": "Query"
                }
              },
              "title": "ListIncidentsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListIncidentsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_incidentsArguments",
          "type": "object"
        }
      },
      {
        "name": "list_catalog_items",
        "description": "List service catalog items.",
        "inputSchema": {
          "$defs": {
            "ListCatalogItemsParams": {
              "description": "Parameters for listing service catalog items.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of catalog items to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by category",
                  "title": "Category"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for catalog items",
                  "title": "Query"
                },
                "active": {
                  "default": true,
                  "description": "Whether to only return active catalog items",
                  "title": "Active",
                  "type": "boolean"
                }
              },
              "title": "ListCatalogItemsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListCatalogItemsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_catalog_itemsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_catalog_item",
        "description": "Get a specific service catalog item.",
        "inputSchema": {
          "$defs": {
            "GetCatalogItemParams": {
              "description": "Parameters for getting a specific service catalog item.",
              "properties": {
                "item_id": {
                  "description": "Catalog item ID or sys_id",
                  "title": "Item Id",
                  "type": "string"
                }
              },
              "required": [
                "item_id"
              ],
              "title": "GetCatalogItemParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetCatalogItemParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_catalog_itemArguments",
          "type": "object"
        }
      },
      {
        "name": "list_catalog_categories",
        "description": "List service catalog categories.",
        "inputSchema": {
          "$defs": {
            "ListCatalogCategoriesParams": {
              "description": "Parameters for listing service catalog categories.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of categories to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for categories",
                  "title": "Query"
                },
                "active": {
                  "default": true,
                  "description": "Whether to only return active categories",
                  "title": "Active",
                  "type": "boolean"
                }
              },
              "title": "ListCatalogCategoriesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListCatalogCategoriesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_catalog_categoriesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_catalog_category",
        "description": "Create a new service catalog category.",
        "inputSchema": {
          "$defs": {
            "CreateCatalogCategoryParams": {
              "description": "Parameters for creating a new service catalog category.",
              "properties": {
                "title": {
                  "description": "Title of the category",
                  "title": "Title",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the category",
                  "title": "Description"
                },
                "parent": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent category sys_id",
                  "title": "Parent"
                },
                "icon": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Icon for the category",
                  "title": "Icon"
                },
                "active": {
                  "default": true,
                  "description": "Whether the category is active",
                  "title": "Active",
                  "type": "boolean"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Order of the category",
                  "title": "Order"
                }
              },
              "required": [
                "title"
              ],
              "title": "CreateCatalogCategoryParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateCatalogCategoryParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_catalog_categoryArguments",
          "type": "object"
        }
      },
      {
        "name": "update_catalog_category",
        "description": "Update an existing service catalog category.",
        "inputSchema": {
          "$defs": {
            "UpdateCatalogCategoryParams": {
              "description": "Parameters for updating a service catalog category.",
              "properties": {
                "category_id": {
                  "description": "Category ID or sys_id",
                  "title": "Category Id",
                  "type": "string"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Title of the category",
                  "title": "Title"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the category",
                  "title": "Description"
                },
                "parent": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent category sys_id",
                  "title": "Parent"
                },
                "icon": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Icon for the category",
                  "title": "Icon"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the category is active",
                  "title": "Active"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Order of the category",
                  "title": "Order"
                }
              },
              "required": [
                "category_id"
              ],
              "title": "UpdateCatalogCategoryParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateCatalogCategoryParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_catalog_categoryArguments",
          "type": "object"
        }
      },
      {
        "name": "move_catalog_items",
        "description": "Move catalog items to a different category.",
        "inputSchema": {
          "$defs": {
            "MoveCatalogItemsParams": {
              "description": "Parameters for moving catalog items between categories.",
              "properties": {
                "item_ids": {
                  "description": "List of catalog item IDs to move",
                  "items": {
                    "type": "string"
                  },
                  "title": "Item Ids",
                  "type": "array"
                },
                "target_category_id": {
                  "description": "Target category ID to move items to",
                  "title": "Target Category Id",
                  "type": "string"
                }
              },
              "required": [
                "item_ids",
                "target_category_id"
              ],
              "title": "MoveCatalogItemsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/MoveCatalogItemsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "move_catalog_itemsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_optimization_recommendations",
        "description": "Get optimization recommendations for the service catalog.",
        "inputSchema": {
          "$defs": {
            "OptimizationRecommendationsParams": {
              "properties": {
                "recommendation_types": {
                  "items": {
                    "type": "string"
                  },
                  "title": "Recommendation Types",
                  "type": "array"
                },
                "category_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Category Id"
                }
              },
              "required": [
                "recommendation_types"
              ],
              "title": "OptimizationRecommendationsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/OptimizationRecommendationsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_optimization_recommendationsArguments",
          "type": "object"
        }
      },
      {
        "name": "update_catalog_item",
        "description": "Update a service catalog item.",
        "inputSchema": {
          "$defs": {
            "UpdateCatalogItemParams": {
              "properties": {
                "item_id": {
                  "title": "Item Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Name"
                },
                "short_description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Short Description"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Description"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Category"
                },
                "price": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Price"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Active"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Order"
                }
              },
              "required": [
                "item_id"
              ],
              "title": "UpdateCatalogItemParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateCatalogItemParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_catalog_itemArguments",
          "type": "object"
        }
      },
      {
        "name": "create_catalog_item_variable",
        "description": "Create a new catalog item variable",
        "inputSchema": {
          "$defs": {
            "CreateCatalogItemVariableParams": {
              "description": "Parameters for creating a catalog item variable.",
              "properties": {
                "catalog_item_id": {
                  "description": "The sys_id of the catalog item",
                  "title": "Catalog Item Id",
                  "type": "string"
                },
                "name": {
                  "description": "The name of the variable (internal name)",
                  "title": "Name",
                  "type": "string"
                },
                "type": {
                  "description": "The type of variable (e.g., string, integer, boolean, reference)",
                  "title": "Type",
                  "type": "string"
                },
                "label": {
                  "description": "The display label for the variable",
                  "title": "Label",
                  "type": "string"
                },
                "mandatory": {
                  "default": false,
                  "description": "Whether the variable is required",
                  "title": "Mandatory",
                  "type": "boolean"
                },
                "help_text": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Help text to display with the variable",
                  "title": "Help Text"
                },
                "default_value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Default value for the variable",
                  "title": "Default Value"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the variable",
                  "title": "Description"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Display order of the variable",
                  "title": "Order"
                },
                "reference_table": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "For reference fields, the table to reference",
                  "title": "Reference Table"
                },
                "reference_qualifier": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "For reference fields, the query to filter reference options",
                  "title": "Reference Qualifier"
                },
                "max_length": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum length for string fields",
                  "title": "Max Length"
                },
                "min": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Minimum value for numeric fields",
                  "title": "Min"
                },
                "max": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum value for numeric fields",
                  "title": "Max"
                }
              },
              "required": [
                "catalog_item_id",
                "name",
                "type",
                "label"
              ],
              "title": "CreateCatalogItemVariableParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateCatalogItemVariableParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_catalog_item_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "list_catalog_item_variables",
        "description": "List catalog item variables",
        "inputSchema": {
          "$defs": {
            "ListCatalogItemVariablesParams": {
              "description": "Parameters for listing catalog item variables.",
              "properties": {
                "catalog_item_id": {
                  "description": "The sys_id of the catalog item",
                  "title": "Catalog Item Id",
                  "type": "string"
                },
                "include_details": {
                  "default": true,
                  "description": "Whether to include detailed information about each variable",
                  "title": "Include Details",
                  "type": "boolean"
                },
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum number of variables to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Offset for pagination",
                  "title": "Offset"
                }
              },
              "required": [
                "catalog_item_id"
              ],
              "title": "ListCatalogItemVariablesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListCatalogItemVariablesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_catalog_item_variablesArguments",
          "type": "object"
        }
      },
      {
        "name": "update_catalog_item_variable",
        "description": "Update a catalog item variable",
        "inputSchema": {
          "$defs": {
            "UpdateCatalogItemVariableParams": {
              "description": "Parameters for updating a catalog item variable.",
              "properties": {
                "variable_id": {
                  "description": "The sys_id of the variable to update",
                  "title": "Variable Id",
                  "type": "string"
                },
                "label": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "The display label for the variable",
                  "title": "Label"
                },
                "mandatory": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the variable is required",
                  "title": "Mandatory"
                },
                "help_text": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Help text to display with the variable",
                  "title": "Help Text"
                },
                "default_value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Default value for the variable",
                  "title": "Default Value"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the variable",
                  "title": "Description"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Display order of the variable",
                  "title": "Order"
                },
                "reference_qualifier": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "For reference fields, the query to filter reference options",
                  "title": "Reference Qualifier"
                },
                "max_length": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum length for string fields",
                  "title": "Max Length"
                },
                "min": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Minimum value for numeric fields",
                  "title": "Min"
                },
                "max": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum value for numeric fields",
                  "title": "Max"
                }
              },
              "required": [
                "variable_id"
              ],
              "title": "UpdateCatalogItemVariableParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateCatalogItemVariableParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_catalog_item_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "create_change_request",
        "description": "Create a new change request in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateChangeRequestParams": {
              "description": "Parameters for creating a change request.",
              "properties": {
                "short_description": {
                  "description": "Short description of the change request",
                  "title": "Short Description",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the change request",
                  "title": "Description"
                },
                "type": {
                  "description": "Type of change (normal, standard, emergency)",
                  "title": "Type",
                  "type": "string"
                },
                "risk": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Risk level of the change",
                  "title": "Risk"
                },
                "impact": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Impact of the change",
                  "title": "Impact"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Category of the change",
                  "title": "Category"
                },
                "requested_by": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User who requested the change",
                  "title": "Requested By"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Group assigned to the change",
                  "title": "Assignment Group"
                },
                "start_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned start date (YYYY-MM-DD HH:MM:SS)",
                  "title": "Start Date"
                },
                "end_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned end date (YYYY-MM-DD HH:MM:SS)",
                  "title": "End Date"
                }
              },
              "required": [
                "short_description",
                "type"
              ],
              "title": "CreateChangeRequestParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateChangeRequestParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_change_requestArguments",
          "type": "object"
        }
      },
      {
        "name": "update_change_request",
        "description": "Update an existing change request in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateChangeRequestParams": {
              "description": "Parameters for updating a change request.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "short_description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Short description of the change request",
                  "title": "Short Description"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the change request",
                  "title": "Description"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "State of the change request",
                  "title": "State"
                },
                "risk": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Risk level of the change",
                  "title": "Risk"
                },
                "impact": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Impact of the change",
                  "title": "Impact"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Category of the change",
                  "title": "Category"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Group assigned to the change",
                  "title": "Assignment Group"
                },
                "start_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned start date (YYYY-MM-DD HH:MM:SS)",
                  "title": "Start Date"
                },
                "end_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned end date (YYYY-MM-DD HH:MM:SS)",
                  "title": "End Date"
                },
                "work_notes": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Work notes to add to the change request",
                  "title": "Work Notes"
                }
              },
              "required": [
                "change_id"
              ],
              "title": "UpdateChangeRequestParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateChangeRequestParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_change_requestArguments",
          "type": "object"
        }
      },
      {
        "name": "list_change_requests",
        "description": "List change requests from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListChangeRequestsParams": {
              "description": "Parameters for listing change requests.",
              "properties": {
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 10,
                  "description": "Maximum number of records to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 0,
                  "description": "Offset to start from",
                  "title": "Offset"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by state",
                  "title": "State"
                },
                "type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by type (normal, standard, emergency)",
                  "title": "Type"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by category",
                  "title": "Category"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by assignment group",
                  "title": "Assignment Group"
                },
                "timeframe": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by timeframe (upcoming, in-progress, completed)",
                  "title": "Timeframe"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional query string",
                  "title": "Query"
                }
              },
              "title": "ListChangeRequestsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListChangeRequestsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_change_requestsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_change_request_details",
        "description": "Get detailed information about a specific change request",
        "inputSchema": {
          "$defs": {
            "GetChangeRequestDetailsParams": {
              "description": "Parameters for getting change request details.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                }
              },
              "required": [
                "change_id"
              ],
              "title": "GetChangeRequestDetailsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetChangeRequestDetailsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_change_request_detailsArguments",
          "type": "object"
        }
      },
      {
        "name": "add_change_task",
        "description": "Add a task to a change request",
        "inputSchema": {
          "$defs": {
            "AddChangeTaskParams": {
              "description": "Parameters for adding a task to a change request.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "short_description": {
                  "description": "Short description of the task",
                  "title": "Short Description",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the task",
                  "title": "Description"
                },
                "assigned_to": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User assigned to the task",
                  "title": "Assigned To"
                },
                "planned_start_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned start date (YYYY-MM-DD HH:MM:SS)",
                  "title": "Planned Start Date"
                },
                "planned_end_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned end date (YYYY-MM-DD HH:MM:SS)",
                  "title": "Planned End Date"
                }
              },
              "required": [
                "change_id",
                "short_description"
              ],
              "title": "AddChangeTaskParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddChangeTaskParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_change_taskArguments",
          "type": "object"
        }
      },
      {
        "name": "submit_change_for_approval",
        "description": "Submit a change request for approval",
        "inputSchema": {
          "$defs": {
            "SubmitChangeForApprovalParams": {
              "description": "Parameters for submitting a change request for approval.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "approval_comments": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Comments for the approval request",
                  "title": "Approval Comments"
                }
              },
              "required": [
                "change_id"
              ],
              "title": "SubmitChangeForApprovalParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/SubmitChangeForApprovalParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "submit_change_for_approvalArguments",
          "type": "object"
        }
      },
      {
        "name": "approve_change",
        "description": "Approve a change request",
        "inputSchema": {
          "$defs": {
            "ApproveChangeParams": {
              "description": "Parameters for approving a change request.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "approver_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "ID of the approver",
                  "title": "Approver Id"
                },
                "approval_comments": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Comments for the approval",
                  "title": "Approval Comments"
                }
              },
              "required": [
                "change_id"
              ],
              "title": "ApproveChangeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ApproveChangeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "approve_changeArguments",
          "type": "object"
        }
      },
      {
        "name": "reject_change",
        "description": "Reject a change request",
        "inputSchema": {
          "$defs": {
            "RejectChangeParams": {
              "description": "Parameters for rejecting a change request.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "approver_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "ID of the approver",
                  "title": "Approver Id"
                },
                "rejection_reason": {
                  "description": "Reason for rejection",
                  "title": "Rejection Reason",
                  "type": "string"
                }
              },
              "required": [
                "change_id",
                "rejection_reason"
              ],
              "title": "RejectChangeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/RejectChangeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "reject_changeArguments",
          "type": "object"
        }
      },
      {
        "name": "list_workflows",
        "description": "List workflows from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListWorkflowsParams": {
              "description": "Parameters for listing workflows.",
              "properties": {
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 10,
                  "description": "Maximum number of records to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 0,
                  "description": "Offset to start from",
                  "title": "Offset"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by name (contains)",
                  "title": "Name"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional query string",
                  "title": "Query"
                }
              },
              "title": "ListWorkflowsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListWorkflowsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_workflowsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_workflow_details",
        "description": "Get detailed information about a specific workflow",
        "inputSchema": {
          "$defs": {
            "GetWorkflowDetailsParams": {
              "description": "Parameters for getting workflow details.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "include_versions": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": false,
                  "description": "Include workflow versions",
                  "title": "Include Versions"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "GetWorkflowDetailsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetWorkflowDetailsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_workflow_detailsArguments",
          "type": "object"
        }
      },
      {
        "name": "list_workflow_versions",
        "description": "List workflow versions from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListWorkflowVersionsParams": {
              "description": "Parameters for listing workflow versions.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 10,
                  "description": "Maximum number of records to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 0,
                  "description": "Offset to start from",
                  "title": "Offset"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "ListWorkflowVersionsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListWorkflowVersionsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_workflow_versionsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_workflow_activities",
        "description": "Get activities for a specific workflow",
        "inputSchema": {
          "$defs": {
            "GetWorkflowActivitiesParams": {
              "description": "Parameters for getting workflow activities.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "version": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Specific version to get activities for",
                  "title": "Version"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "GetWorkflowActivitiesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetWorkflowActivitiesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_workflow_activitiesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_workflow",
        "description": "Create a new workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateWorkflowParams": {
              "description": "Parameters for creating a new workflow.",
              "properties": {
                "name": {
                  "description": "Name of the workflow",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the workflow",
                  "title": "Description"
                },
                "table": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Table the workflow applies to",
                  "title": "Table"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": true,
                  "description": "Whether the workflow is active",
                  "title": "Active"
                },
                "attributes": {
                  "anyOf": [
                    {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional attributes for the workflow",
                  "title": "Attributes"
                }
              },
              "required": [
                "name"
              ],
              "title": "CreateWorkflowParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateWorkflowParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "update_workflow",
        "description": "Update an existing workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateWorkflowParams": {
              "description": "Parameters for updating a workflow.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Name of the workflow",
                  "title": "Name"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the workflow",
                  "title": "Description"
                },
                "table": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Table the workflow applies to",
                  "title": "Table"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the workflow is active",
                  "title": "Active"
                },
                "attributes": {
                  "anyOf": [
                    {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional attributes for the workflow",
                  "title": "Attributes"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "UpdateWorkflowParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateWorkflowParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "activate_workflow",
        "description": "Activate a workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "ActivateWorkflowParams": {
              "description": "Parameters for activating a workflow.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "ActivateWorkflowParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ActivateWorkflowParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "activate_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "deactivate_workflow",
        "description": "Deactivate a workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "DeactivateWorkflowParams": {
              "description": "Parameters for deactivating a workflow.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "DeactivateWorkflowParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/DeactivateWorkflowParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "deactivate_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "add_workflow_activity",
        "description": "Add a new activity to a workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "AddWorkflowActivityParams": {
              "description": "Parameters for adding an activity to a workflow.",
              "properties": {
                "workflow_version_id": {
                  "description": "Workflow version ID",
                  "title": "Workflow Version Id",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the activity",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the activity",
                  "title": "Description"
                },
                "activity_type": {
                  "description": "Type of activity (e.g., 'approval', 'task', 'notification')",
                  "title": "Activity Type",
                  "type": "string"
                },
                "attributes": {
                  "anyOf": [
                    {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional attributes for the activity",
                  "title": "Attributes"
                }
              },
              "required": [
                "workflow_version_id",
                "name",
                "activity_type"
              ],
              "title": "AddWorkflowActivityParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddWorkflowActivityParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_workflow_activityArguments",
          "type": "object"
        }
      },
      {
        "name": "update_workflow_activity",
        "description": "Update an existing activity in a workflow",
        "inputSchema": {
          "$defs": {
            "UpdateWorkflowActivityParams": {
              "description": "Parameters for updating a workflow activity.",
              "properties": {
                "activity_id": {
                  "description": "Activity ID or sys_id",
                  "title": "Activity Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Name of the activity",
                  "title": "Name"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the activity",
                  "title": "Description"
                },
                "attributes": {
                  "anyOf": [
                    {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional attributes for the activity",
                  "title": "Attributes"
                }
              },
              "required": [
                "activity_id"
              ],
              "title": "UpdateWorkflowActivityParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateWorkflowActivityParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_workflow_activityArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_workflow_activity",
        "description": "Delete an activity from a workflow",
        "inputSchema": {
          "$defs": {
            "DeleteWorkflowActivityParams": {
              "description": "Parameters for deleting a workflow activity.",
              "properties": {
                "activity_id": {
                  "description": "Activity ID or sys_id",
                  "title": "Activity Id",
                  "type": "string"
                }
              },
              "required": [
                "activity_id"
              ],
              "title": "DeleteWorkflowActivityParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/DeleteWorkflowActivityParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "delete_workflow_activityArguments",
          "type": "object"
        }
      },
      {
        "name": "reorder_workflow_activities",
        "description": "Reorder activities in a workflow",
        "inputSchema": {
          "$defs": {
            "ReorderWorkflowActivitiesParams": {
              "description": "Parameters for reordering workflow activities.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "activity_ids": {
                  "description": "List of activity IDs in the desired order",
                  "items": {
                    "type": "string"
                  },
                  "title": "Activity Ids",
                  "type": "array"
                }
              },
              "required": [
                "workflow_id",
                "activity_ids"
              ],
              "title": "ReorderWorkflowActivitiesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ReorderWorkflowActivitiesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "reorder_workflow_activitiesArguments",
          "type": "object"
        }
      },
      {
        "name": "list_changesets",
        "description": "List changesets from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListChangesetsParams": {
              "description": "Parameters for listing changesets.",
              "properties": {
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 10,
                  "description": "Maximum number of records to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 0,
                  "description": "Offset to start from",
                  "title": "Offset"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by state",
                  "title": "State"
                },
                "application": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by application",
                  "title": "Application"
                },
                "developer": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by developer",
                  "title": "Developer"
                },
                "timeframe": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by timeframe (recent, last_week, last_month)",
                  "title": "Timeframe"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional query string",
                  "title": "Query"
                }
              },
              "title": "ListChangesetsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListChangesetsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_changesetsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_changeset_details",
        "description": "Get detailed information about a specific changeset",
        "inputSchema": {
          "$defs": {
            "GetChangesetDetailsParams": {
              "description": "Parameters for getting changeset details.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                }
              },
              "required": [
                "changeset_id"
              ],
              "title": "GetChangesetDetailsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetChangesetDetailsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_changeset_detailsArguments",
          "type": "object"
        }
      },
      {
        "name": "create_changeset",
        "description": "Create a new changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateChangesetParams": {
              "description": "Parameters for creating a changeset.",
              "properties": {
                "name": {
                  "description": "Name of the changeset",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the changeset",
                  "title": "Description"
                },
                "application": {
                  "description": "Application the changeset belongs to",
                  "title": "Application",
                  "type": "string"
                },
                "developer": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Developer responsible for the changeset",
                  "title": "Developer"
                }
              },
              "required": [
                "name",
                "application"
              ],
              "title": "CreateChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "update_changeset",
        "description": "Update an existing changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateChangesetParams": {
              "description": "Parameters for updating a changeset.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Name of the changeset",
                  "title": "Name"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the changeset",
                  "title": "Description"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "State of the changeset",
                  "title": "State"
                },
                "developer": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Developer responsible for the changeset",
                  "title": "Developer"
                }
              },
              "required": [
                "changeset_id"
              ],
              "title": "UpdateChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "commit_changeset",
        "description": "Commit a changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CommitChangesetParams": {
              "description": "Parameters for committing a changeset.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                },
                "commit_message": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Commit message",
                  "title": "Commit Message"
                }
              },
              "required": [
                "changeset_id"
              ],
              "title": "CommitChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CommitChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "commit_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "publish_changeset",
        "description": "Publish a changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "PublishChangesetParams": {
              "description": "Parameters for publishing a changeset.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                },
                "publish_notes": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Notes for publishing",
                  "title": "Publish Notes"
                }
              },
              "required": [
                "changeset_id"
              ],
              "title": "PublishChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/PublishChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "publish_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "add_file_to_changeset",
        "description": "Add a file to a changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "AddFileToChangesetParams": {
              "description": "Parameters for adding a file to a changeset.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                },
                "file_path": {
                  "description": "Path of the file to add",
                  "title": "File Path",
                  "type": "string"
                },
                "file_content": {
                  "description": "Content of the file",
                  "title": "File Content",
                  "type": "string"
                }
              },
              "required": [
                "changeset_id",
                "file_path",
                "file_content"
              ],
              "title": "AddFileToChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddFileToChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_file_to_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "list_script_includes",
        "description": "List script includes from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListScriptIncludesParams": {
              "description": "Parameters for listing script includes.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of script includes to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "client_callable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by client callable status",
                  "title": "Client Callable"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for script includes",
                  "title": "Query"
                }
              },
              "title": "ListScriptIncludesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListScriptIncludesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_script_includesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_script_include",
        "description": "Get a specific script include from ServiceNow",
        "inputSchema": {
          "$defs": {
            "GetScriptIncludeParams": {
              "description": "Parameters for getting a script include.",
              "properties": {
                "script_include_id": {
                  "description": "Script include ID or name",
                  "title": "Script Include Id",
                  "type": "string"
                }
              },
              "required": [
                "script_include_id"
              ],
              "title": "GetScriptIncludeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetScriptIncludeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_script_includeArguments",
          "type": "object"
        }
      },
      {
        "name": "create_script_include",
        "description": "Create a new script include in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateScriptIncludeParams": {
              "description": "Parameters for creating a script include.",
              "properties": {
                "name": {
                  "description": "Name of the script include",
                  "title": "Name",
                  "type": "string"
                },
                "script": {
                  "description": "Script content",
                  "title": "Script",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the script include",
                  "title": "Description"
                },
                "api_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "API name of the script include",
                  "title": "Api Name"
                },
                "client_callable": {
                  "default": false,
                  "description": "Whether the script include is client callable",
                  "title": "Client Callable",
                  "type": "boolean"
                },
                "active": {
                  "default": true,
                  "description": "Whether the script include is active",
                  "title": "Active",
                  "type": "boolean"
                },
                "access": {
                  "default": "package_private",
                  "description": "Access level of the script include",
                  "title": "Access",
                  "type": "string"
                }
              },
              "required": [
                "name",
                "script"
              ],
              "title": "CreateScriptIncludeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateScriptIncludeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_script_includeArguments",
          "type": "object"
        }
      },
      {
        "name": "update_script_include",
        "description": "Update an existing script include in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateScriptIncludeParams": {
              "description": "Parameters for updating a script include.",
              "properties": {
                "script_include_id": {
                  "description": "Script include ID or name",
                  "title": "Script Include Id",
                  "type": "string"
                },
                "script": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Script content",
                  "title": "Script"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the script include",
                  "title": "Description"
                },
                "api_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "API name of the script include",
                  "title": "Api Name"
                },
                "client_callable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the script include is client callable",
                  "title": "Client Callable"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the script include is active",
                  "title": "Active"
                },
                "access": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Access level of the script include",
                  "title": "Access"
                }
              },
              "required": [
                "script_include_id"
              ],
              "title": "UpdateScriptIncludeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateScriptIncludeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_script_includeArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_script_include",
        "description": "Delete a script include in ServiceNow",
        "inputSchema": {
          "$defs": {
            "DeleteScriptIncludeParams": {
              "description": "Parameters for deleting a script include.",
              "properties": {
                "script_include_id": {
                  "description": "Script include ID or name",
                  "title": "Script Include Id",
                  "type": "string"
                }
              },
              "required": [
                "script_include_id"
              ],
              "title": "DeleteScriptIncludeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/DeleteScriptIncludeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "delete_script_includeArguments",
          "type": "object"
        }
      },
      {
        "name": "create_knowledge_base",
        "description": "Create a new knowledge base in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateKnowledgeBaseParams": {
              "description": "Parameters for creating a knowledge base.",
              "properties": {
                "title": {
                  "description": "Title of the knowledge base",
                  "title": "Title",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the knowledge base",
                  "title": "Description"
                },
                "owner": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "The specified admin user or group",
                  "title": "Owner"
                },
                "managers": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Users who can manage this knowledge base",
                  "title": "Managers"
                },
                "publish_workflow": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": "Knowledge - Instant Publish",
                  "description": "Publication workflow",
                  "title": "Publish Workflow"
                },
                "retire_workflow": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": "Knowledge - Instant Retire",
                  "description": "Retirement workflow",
                  "title": "Retire Workflow"
                }
              },
              "required": [
                "title"
              ],
              "title": "CreateKnowledgeBaseParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateKnowledgeBaseParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_knowledge_baseArguments",
          "type": "object"
        }
      },
      {
        "name": "list_knowledge_bases",
        "description": "List knowledge bases from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListKnowledgeBasesParams": {
              "description": "Parameters for listing knowledge bases.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of knowledge bases to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for knowledge bases",
                  "title": "Query"
                }
              },
              "title": "ListKnowledgeBasesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListKnowledgeBasesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_knowledge_basesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_category",
        "description": "Create a new category in a knowledge base",
        "inputSchema": {
          "$defs": {
            "CreateCategoryParams": {
              "description": "Parameters for creating a category in a knowledge base.",
              "properties": {
                "title": {
                  "description": "Title of the category",
                  "title": "Title",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the category",
                  "title": "Description"
                },
                "knowledge_base": {
                  "description": "The knowledge base to create the category in",
                  "title": "Knowledge Base",
                  "type": "string"
                },
                "parent_category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent category (if creating a subcategory)",
                  "title": "Parent Category"
                },
                "active": {
                  "default": true,
                  "description": "Whether the category is active",
                  "title": "Active",
                  "type": "boolean"
                }
              },
              "required": [
                "title",
                "knowledge_base"
              ],
              "title": "CreateCategoryParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateCategoryParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_categoryArguments",
          "type": "object"
        }
      },
      {
        "name": "create_article",
        "description": "Create a new knowledge article",
        "inputSchema": {
          "$defs": {
            "CreateArticleParams": {
              "description": "Parameters for creating a knowledge article.",
              "properties": {
                "title": {
                  "description": "Title of the article",
                  "title": "Title",
                  "type": "string"
                },
                "text": {
                  "description": "The main body text for the article",
                  "title": "Text",
                  "type": "string"
                },
                "short_description": {
                  "description": "Short description of the article",
                  "title": "Short Description",
                  "type": "string"
                },
                "knowledge_base": {
                  "description": "The knowledge base to create the article in",
                  "title": "Knowledge Base",
                  "type": "string"
                },
                "category": {
                  "description": "Category for the article",
                  "title": "Category",
                  "type": "string"
                },
                "keywords": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Keywords for search",
                  "title": "Keywords"
                },
                "article_type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": "text",
                  "description": "The type of article",
                  "title": "Article Type"
                }
              },
              "required": [
                "title",
                "text",
                "short_description",
                "knowledge_base",
                "category"
              ],
              "title": "CreateArticleParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateArticleParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_articleArguments",
          "type": "object"
        }
      },
      {
        "name": "update_article",
        "description": "Update an existing knowledge article",
        "inputSchema": {
          "$defs": {
            "UpdateArticleParams": {
              "description": "Parameters for updating a knowledge article.",
              "properties": {
                "article_id": {
                  "description": "ID of the article to update",
                  "title": "Article Id",
                  "type": "string"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated title of the article",
                  "title": "Title"
                },
                "text": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated main body text for the article",
                  "title": "Text"
                },
                "short_description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated short description",
                  "title": "Short Description"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated category for the article",
                  "title": "Category"
                },
                "keywords": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated keywords for search",
                  "title": "Keywords"
                }
              },
              "required": [
                "article_id"
              ],
              "title": "UpdateArticleParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateArticleParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_articleArguments",
          "type": "object"
        }
      },
      {
        "name": "publish_article",
        "description": "Publish a knowledge article",
        "inputSchema": {
          "$defs": {
            "PublishArticleParams": {
              "description": "Parameters for publishing a knowledge article.",
              "properties": {
                "article_id": {
                  "description": "ID of the article to publish",
                  "title": "Article Id",
                  "type": "string"
                },
                "workflow_state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": "published",
                  "description": "The workflow state to set",
                  "title": "Workflow State"
                },
                "workflow_version": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "The workflow version to use",
                  "title": "Workflow Version"
                }
              },
              "required": [
                "article_id"
              ],
              "title": "PublishArticleParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/PublishArticleParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "publish_articleArguments",
          "type": "object"
        }
      },
      {
        "name": "list_articles",
        "description": "List knowledge articles",
        "inputSchema": {
          "$defs": {
            "ListArticlesParams": {
              "description": "Parameters for listing knowledge articles.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of articles to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "knowledge_base": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by knowledge base",
                  "title": "Knowledge Base"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by category",
                  "title": "Category"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for articles",
                  "title": "Query"
                },
                "workflow_state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by workflow state",
                  "title": "Workflow State"
                }
              },
              "title": "ListArticlesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListArticlesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_articlesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_article",
        "description": "Get a specific knowledge article by ID",
        "inputSchema": {
          "$defs": {
            "GetArticleParams": {
              "description": "Parameters for getting a knowledge article.",
              "properties": {
                "article_id": {
                  "description": "ID of the article to get",
                  "title": "Article Id",
                  "type": "string"
                }
              },
              "required": [
                "article_id"
              ],
              "title": "GetArticleParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetArticleParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_articleArguments",
          "type": "object"
        }
      },
      {
        "name": "list_categories",
        "description": "List categories in a knowledge base",
        "inputSchema": {
          "$defs": {
            "ListCategoriesParams": {
              "description": "Parameters for listing categories in a knowledge base.",
              "properties": {
                "knowledge_base": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by knowledge base ID",
                  "title": "Knowledge Base"
                },
                "parent_category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by parent category ID",
                  "title": "Parent Category"
                },
                "limit": {
                  "default": 10,
                  "description": "Maximum number of categories to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for categories",
                  "title": "Query"
                }
              },
              "title": "ListCategoriesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListCategoriesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_categoriesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_user",
        "description": "Create a new user in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateUserParams": {
              "description": "Parameters for creating a user.",
              "properties": {
                "user_name": {
                  "description": "Username for the user",
                  "title": "User Name",
                  "type": "string"
                },
                "first_name": {
                  "description": "First name of the user",
                  "title": "First Name",
                  "type": "string"
                },
                "last_name": {
                  "description": "Last name of the user",
                  "title": "Last Name",
                  "type": "string"
                },
                "email": {
                  "description": "Email address of the user",
                  "title": "Email",
                  "type": "string"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Job title of the user",
                  "title": "Title"
                },
                "department": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Department the user belongs to",
                  "title": "Department"
                },
                "manager": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Manager of the user (sys_id or username)",
                  "title": "Manager"
                },
                "roles": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Roles to assign to the user",
                  "title": "Roles"
                },
                "phone": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Phone number of the user",
                  "title": "Phone"
                },
                "mobile_phone": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Mobile phone number of the user",
                  "title": "Mobile Phone"
                },
                "location": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Location of the user",
                  "title": "Location"
                },
                "password": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Password for the user account",
                  "title": "Password"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": true,
                  "description": "Whether the user account is active",
                  "title": "Active"
                }
              },
              "required": [
                "user_name",
                "first_name",
                "last_name",
                "email"
              ],
              "title": "CreateUserParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateUserParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_userArguments",
          "type": "object"
        }
      },
      {
        "name": "update_user",
        "description": "Update an existing user in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateUserParams": {
              "description": "Parameters for updating a user.",
              "properties": {
                "user_id": {
                  "description": "User ID or sys_id to update",
                  "title": "User Id",
                  "type": "string"
                },
                "user_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Username for the user",
                  "title": "User Name"
                },
                "first_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "First name of the user",
                  "title": "First Name"
                },
                "last_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Last name of the user",
                  "title": "Last Name"
                },
                "email": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Email address of the user",
                  "title": "Email"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Job title of the user",
                  "title": "Title"
                },
                "department": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Department the user belongs to",
                  "title": "Department"
                },
                "manager": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Manager of the user (sys_id or username)",
                  "title": "Manager"
                },
                "roles": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Roles to assign to the user",
                  "title": "Roles"
                },
                "phone": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Phone number of the user",
                  "title": "Phone"
                },
                "mobile_phone": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Mobile phone number of the user",
                  "title": "Mobile Phone"
                },
                "location": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Location of the user",
                  "title": "Location"
                },
                "password": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Password for the user account",
                  "title": "Password"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the user account is active",
                  "title": "Active"
                }
              },
              "required": [
                "user_id"
              ],
              "title": "UpdateUserParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateUserParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_userArguments",
          "type": "object"
        }
      },
      {
        "name": "get_user",
        "description": "Get a specific user in ServiceNow",
        "inputSchema": {
          "$defs": {
            "GetUserParams": {
              "description": "Parameters for getting a user.",
              "properties": {
                "user_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User ID or sys_id",
                  "title": "User Id"
                },
                "user_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Username of the user",
                  "title": "User Name"
                },
                "email": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Email address of the user",
                  "title": "Email"
                }
              },
              "title": "GetUserParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetUserParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_userArguments",
          "type": "object"
        }
      },
      {
        "name": "list_users",
        "description": "List users in ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListUsersParams": {
              "description": "Parameters for listing users.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of users to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "department": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by department",
                  "title": "Department"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Case-insensitive search term that matches against name, username, or email fields. Uses ServiceNow's LIKE operator for partial matching.",
                  "title": "Query"
                }
              },
              "title": "ListUsersParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListUsersParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_usersArguments",
          "type": "object"
        }
      },
      {
        "name": "create_group",
        "description": "Create a new group in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateGroupParams": {
              "description": "Parameters for creating a group.",
              "properties": {
                "name": {
                  "description": "Name of the group",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the group",
                  "title": "Description"
                },
                "manager": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Manager of the group (sys_id or username)",
                  "title": "Manager"
                },
                "parent": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent group (sys_id or name)",
                  "title": "Parent"
                },
                "type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Type of the group",
                  "title": "Type"
                },
                "email": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Email address for the group",
                  "title": "Email"
                },
                "members": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "List of user sys_ids or usernames to add as members",
                  "title": "Members"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": true,
                  "description": "Whether the group is active",
                  "title": "Active"
                }
              },
              "required": [
                "name"
              ],
              "title": "CreateGroupParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateGroupParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_groupArguments",
          "type": "object"
        }
      },
      {
        "name": "update_group",
        "description": "Update an existing group in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateGroupParams": {
              "description": "Parameters for updating a group.",
              "properties": {
                "group_id": {
                  "description": "Group ID or sys_id to update",
                  "title": "Group Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Name of the group",
                  "title": "Name"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the group",
                  "title": "Description"
                },
                "manager": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Manager of the group (sys_id or username)",
                  "title": "Manager"
                },
                "parent": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent group (sys_id or name)",
                  "title": "Parent"
                },
                "type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Type of the group",
                  "title": "Type"
                },
                "email": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Email address for the group",
                  "title": "Email"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the group is active",
                  "title": "Active"
                }
              },
              "required": [
                "group_id"
              ],
              "title": "UpdateGroupParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateGroupParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_groupArguments",
          "type": "object"
        }
      },
      {
        "name": "add_group_members",
        "description": "Add members to an existing group in ServiceNow",
        "inputSchema": {
          "$defs": {
            "AddGroupMembersParams": {
              "description": "Parameters for adding members to a group.",
              "properties": {
                "group_id": {
                  "description": "Group ID or sys_id",
                  "title": "Group Id",
                  "type": "string"
                },
                "members": {
                  "description": "List of user sys_ids or usernames to add as members",
                  "items": {
                    "type": "string"
                  },
                  "title": "Members",
                  "type": "array"
                }
              },
              "required": [
                "group_id",
                "members"
              ],
              "title": "AddGroupMembersParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddGroupMembersParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_group_membersArguments",
          "type": "object"
        }
      },
      {
        "name": "remove_group_members",
        "description": "Remove members from an existing group in ServiceNow",
        "inputSchema": {
          "$defs": {
            "RemoveGroupMembersParams": {
              "description": "Parameters for removing members from a group.",
              "properties": {
                "group_id": {
                  "description": "Group ID or sys_id",
                  "title": "Group Id",
                  "type": "string"
                },
                "members": {
                  "description": "List of user sys_ids or usernames to remove as members",
                  "items": {
                    "type": "string"
                  },
                  "title": "Members",
                  "type": "array"
                }
              },
              "required": [
                "group_id",
                "members"
              ],
              "title": "RemoveGroupMembersParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/RemoveGroupMembersParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "remove_group_membersArguments",
          "type": "object"
        }
      },
      {
        "name": "list_groups",
        "description": "List groups from ServiceNow with optional filtering",
        "inputSchema": {
          "$defs": {
            "ListGroupsParams": {
              "description": "Parameters for listing groups.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of groups to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Case-insensitive search term that matches against group name or description fields. Uses ServiceNow's LIKE operator for partial matching.",
                  "title": "Query"
                },
                "type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by group type",
                  "title": "Type"
                }
              },
              "title": "ListGroupsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListGroupsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_groupsArguments",
          "type": "object"
        }
      }
    ]
  },
  "mcp-compass": {
    "name": "mcp-compass",
    "display_name": "Compass",
    "description": "Suggest the right MCP server for your needs",
    "repository": {
      "type": "git",
      "url": "https://github.com/liuyoshio/mcp-compass"
    },
    "homepage": "https://github.com/liuyoshio/mcp-compass",
    "author": {
      "name": "liuyoshio"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "compass",
      "service discovery"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@liuyoshio/mcp-compass"
        ]
      }
    },
    "tools": [
      {
        "name": "recommend-mcp-servers",
        "description": "\n          Use this tool when there is a need to findn external MCP tools.\n          It explores and recommends existing MCP servers from the \n          internet, based on the description of the MCP Server \n          needed. It returns a list of MCP servers with their IDs, \n          descriptions, GitHub URLs, and similarity scores.\n          ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "\n                Description for the MCP Server needed. \n                It should be specific and actionable, e.g.:\n                GOOD:\n                - 'MCP Server for AWS Lambda Python3.9 deployment'\n                - 'MCP Server for United Airlines booking API'\n                - 'MCP Server for Stripe refund webhook handling'\n\n                BAD:\n                - 'MCP Server for cloud' (too vague)\n                - 'MCP Server for booking' (which booking system?)\n                - 'MCP Server for payment' (which payment provider?)\n\n                Query should explicitly specify:\n                1. Target platform/vendor (e.g. AWS, Stripe, MongoDB)\n                2. Exact operation/service (e.g. Lambda deployment, webhook handling)\n                3. Additional context if applicable (e.g. Python, refund events)\n                "
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "alicloud-hologres": {
    "display_name": "Hologres MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/aliyun/alibabacloud-hologres-mcp-server"
    },
    "homepage": "https://github.com/aliyun/alibabacloud-hologres-mcp-server",
    "author": {
      "name": "aliyun"
    },
    "license": "Apache-2.0",
    "tags": [
      "hologres",
      "database",
      "SQL"
    ],
    "arguments": {
      "HOLOGRES_HOST": {
        "description": "Hologres database host",
        "required": true,
        "example": "host"
      },
      "HOLOGRES_PORT": {
        "description": "Hologres database port",
        "required": true,
        "example": "port"
      },
      "HOLOGRES_USER": {
        "description": "Hologres database user (access_id)",
        "required": true,
        "example": "access_id"
      },
      "HOLOGRES_PASSWORD": {
        "description": "Hologres database password (access_key)",
        "required": true,
        "example": "access_key"
      },
      "HOLOGRES_DATABASE": {
        "description": "Hologres database name",
        "required": true,
        "example": "database"
      }
    },
    "installations": {
      "local_file": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "hologres-mcp-server"
        ],
        "env": {
          "HOLOGRES_HOST": "host",
          "HOLOGRES_PORT": "port",
          "HOLOGRES_USER": "access_id",
          "HOLOGRES_PASSWORD": "access_key",
          "HOLOGRES_DATABASE": "database"
        },
        "description": "Run using local file"
      }
    },
    "examples": [],
    "name": "alicloud-hologres",
    "description": "Hologres MCP Server serves as a universal interface between AI Agents and Hologres databases. It enables seamless communication between AI Agents and Hologres, helping AI Agents retrieve Hologres database metadata and execute SQL operations.",
    "categories": [
      "Databases"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "execute_select_sql",
        "description": "Execute SELECT SQL to query data from Hologres database.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The (SELECT) SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "execute_dml_sql",
        "description": "Execute (INSERT, UPDATE, DELETE) SQL to insert, update, and delete data in Hologres databse.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The DML SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "execute_ddl_sql",
        "description": "Execute (CREATE, ALTER, DROP) SQL statements to CREATE, ALTER, or DROP tables, views, procedures, GUCs etc. in Hologres databse.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The DDL SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "gather_table_statistics",
        "description": "Execute the ANALYZE TABLE command to have Hologres collect table statistics, enabling QO to generate better query plans",
        "inputSchema": {
          "type": "object",
          "properties": {
            "schema": {
              "type": "string",
              "description": "Schema name"
            },
            "table": {
              "type": "string",
              "description": "Table name"
            }
          },
          "required": [
            "schema",
            "table"
          ]
        }
      },
      {
        "name": "get_query_plan",
        "description": "Get query plan for a SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to analyze"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_execution_plan",
        "description": "Get actual execution plan with runtime statistics for a SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to analyze"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "alphavantage": {
    "name": "alphavantage",
    "display_name": "Alphavantage",
    "description": "MCP server for stock market data API [AlphaVantage](https://www.alphavantage.co/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/calvernaz/alphavantage"
    },
    "homepage": "https://github.com/calvernaz/alphavantage",
    "author": {
      "name": "calvernaz"
    },
    "license": "Apache-2.0",
    "categories": [
      "Finance"
    ],
    "tags": [
      "alphavantage",
      "stock market"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/calvernaz/alphavantage.git",
          "alphavantage"
        ],
        "env": {
          "ALPHAVANTAGE_API_KEY": "${ALPHAVANTAGE_API_KEY}"
        }
      }
    },
    "arguments": {
      "ALPHAVANTAGE_API_KEY": {
        "description": "The API key to access the Alphavantage service.",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      }
    },
    "tools": [
      {
        "name": "stock_quote",
        "description": "Fetch a stock quote",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_intraday",
        "description": "Fetch a time series intraday",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "adjusted": {
              "type": "boolean"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            },
            "monthly": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "time_series_daily",
        "description": "Fetch a time series daily",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_daily_adjusted",
        "description": "Fetch a time series daily adjusted",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_weekly",
        "description": "Fetch a time series weekly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_weekly_adjusted",
        "description": "Fetch a time series weekly adjusted",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_monthly",
        "description": "Fetch a time series monthly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_monthly_adjusted",
        "description": "Fetch a time series monthly adjusted",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "realtime_bulk_quotes",
        "description": "Fetch real time bulk quotes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array"
            }
          },
          "required": [
            "symbols"
          ]
        }
      },
      {
        "name": "symbol_search",
        "description": "Search endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "market_status",
        "description": "Fetch market status",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "realtime_options",
        "description": "Fetch realtime options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            },
            "contract": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "historical_options",
        "description": "Fetch historical options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            },
            "contract": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "news_sentiment",
        "description": "Fetch news sentiment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tickers": {
              "type": "array"
            },
            "topics": {
              "type": "string"
            },
            "time_from": {
              "type": "string"
            },
            "time_to": {
              "type": "string"
            },
            "sort": {
              "type": "string"
            },
            "limit": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "tickers"
          ]
        }
      },
      {
        "name": "top_gainers_losers",
        "description": "Fetch top gainers and losers",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "insider_transactions",
        "description": "Fetch insider transactions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "analytics_fixed_window",
        "description": "Fetch analytics fixed window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array"
            },
            "interval": {
              "type": "string"
            },
            "series_range": {
              "type": "string"
            },
            "ohlc": {
              "type": "string"
            },
            "calculations": {
              "type": "array"
            }
          },
          "required": [
            "symbols",
            "series_range",
            "interval",
            "calculations"
          ]
        }
      },
      {
        "name": "analytics_sliding_window",
        "description": "Fetch analytics sliding window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array"
            },
            "interval": {
              "type": "string"
            },
            "series_range": {
              "type": "string"
            },
            "ohlc": {
              "type": "string"
            },
            "window_size": {
              "type": "number"
            },
            "calculations": {
              "type": "array"
            }
          },
          "required": [
            "symbols",
            "series_range",
            "interval",
            "calculations",
            "window_size"
          ]
        }
      },
      {
        "name": "company_overview",
        "description": "Fetch company overview",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "etf_profile",
        "description": "Fetch ETF profile",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "company_dividends",
        "description": "Fetch company dividends",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "company_splits",
        "description": "Fetch company splits",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "income_statement",
        "description": "Fetch company income statement",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "balance_sheet",
        "description": "Fetch company balance sheet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "cash_flow",
        "description": "Fetch company cash flow",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "listing_status",
        "description": "Fetch listing status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "date": {
              "type": "string"
            },
            "state": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "earnings_calendar",
        "description": "Fetch company earnings calendar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "horizon": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "ipo_calendar",
        "description": "Fetch IPO calendar",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "exchange_rate",
        "description": "Fetch exchange rate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_currency": {
              "type": "string"
            },
            "to_currency": {
              "type": "string"
            }
          },
          "required": [
            "from_currency",
            "to_currency"
          ]
        }
      },
      {
        "name": "fx_intraday",
        "description": "Fetch FX intraday",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_symbol": {
              "type": "string"
            },
            "to_symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "from_symbol",
            "to_symbol",
            "interval"
          ]
        }
      },
      {
        "name": "fx_daily",
        "description": "Fetch FX daily",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_symbol": {
              "type": "string"
            },
            "to_symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            }
          },
          "required": [
            "from_symbol",
            "to_symbol"
          ]
        }
      },
      {
        "name": "fx_weekly",
        "description": "Fetch FX weekly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_symbol": {
              "type": "string"
            },
            "to_symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "from_symbol",
            "to_symbol"
          ]
        }
      },
      {
        "name": "fx_monthly",
        "description": "Fetch FX monthly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_symbol": {
              "type": "string"
            },
            "to_symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "from_symbol",
            "to_symbol"
          ]
        }
      },
      {
        "name": "crypto_intraday",
        "description": "Fetch crypto intraday",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "market": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "market",
            "interval"
          ]
        }
      },
      {
        "name": "digital_currency_daily",
        "description": "Fetch digital currency daily",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "market": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "market"
          ]
        }
      },
      {
        "name": "digital_currency_weekly",
        "description": "Fetch digital currency weekly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "market": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "market"
          ]
        }
      },
      {
        "name": "digital_currency_monthly",
        "description": "Fetch digital currency monthly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "market": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "market"
          ]
        }
      },
      {
        "name": "wti_crude_oil",
        "description": "Fetch WTI crude oil",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "brent_crude_oil",
        "description": "Fetch Brent crude oil",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "natural_gas",
        "description": "Fetch natural gas",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "copper",
        "description": "Fetch copper",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "aluminum",
        "description": "Fetch aluminum",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "wheat",
        "description": "Fetch wheat",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "corn",
        "description": "Fetch corn",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "cotton",
        "description": "Fetch cotton",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "sugar",
        "description": "Fetch sugar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "coffee",
        "description": "Fetch coffee",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "all_commodities",
        "description": "Fetch all commodities",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "real_gdp",
        "description": "Fetch real GDP",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "real_gdp_per_capita",
        "description": "Fetch real GDP per capita",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "treasury_yield",
        "description": "Fetch treasury yield",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "maturity": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "federal_funds_rate",
        "description": "Fetch federal funds rate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "cpi",
        "description": "Fetch consumer price index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "inflation",
        "description": "Fetch inflation",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "retail_sales",
        "description": "Fetch retail sales",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "durables",
        "description": "Fetch durables",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "unemployment",
        "description": "Fetch unemployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "nonfarm_payroll",
        "description": "Fetch nonfarm payroll",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "sma",
        "description": "Fetch simple moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "ema",
        "description": "Fetch exponential moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "wma",
        "description": "Fetch weighted moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "dema",
        "description": "Fetch double exponential moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "trima",
        "description": "Fetch triangular moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "kama",
        "description": "Fetch Kaufman adaptive moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "mama",
        "description": "Fetch MESA adaptive moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastlimit": {
              "type": "number"
            },
            "slowlimit": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type",
            "fastlimit",
            "slowlimit"
          ]
        }
      },
      {
        "name": "vwap",
        "description": "Fetch volume weighted average price",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "t3",
        "description": "Fetch triple exponential moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "macd",
        "description": "Fetch moving average convergence divergence",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "signalperiod": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type"
          ]
        }
      },
      {
        "name": "macdext",
        "description": "Fetch moving average convergence divergence next",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "signalperiod": {
              "type": "number"
            },
            "fastmatype": {
              "type": "number"
            },
            "slowmatype": {
              "type": "number"
            },
            "signalmatype": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type"
          ]
        }
      },
      {
        "name": "stoch",
        "description": "Fetch stochastic oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "fastkperiod": {
              "type": "number"
            },
            "slowkperiod": {
              "type": "number"
            },
            "slowdperiod": {
              "type": "number"
            },
            "slowkmatype": {
              "type": "string"
            },
            "slowdmatype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "stochf",
        "description": "Fetch stochastic oscillator fast",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "fastkperiod": {
              "type": "number"
            },
            "fastdperiod": {
              "type": "number"
            },
            "fastdmatype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "rsi",
        "description": "Fetch relative strength index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "stochrsi",
        "description": "Fetch stochastic relative strength index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "fastkperiod": {
              "type": "number"
            },
            "fastdperiod": {
              "type": "number"
            },
            "fastdmatype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "willr",
        "description": "Fetch williams percent range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "adx",
        "description": "Fetch average directional movement index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "adxr",
        "description": "Fetch average directional movement index rating",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "apo",
        "description": "Fetch absolute price oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "matype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type",
            "fastperiod",
            "slowperiod"
          ]
        }
      },
      {
        "name": "ppo",
        "description": "Fetch percentage price oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "matype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type",
            "fastperiod",
            "slowperiod"
          ]
        }
      },
      {
        "name": "mom",
        "description": "Fetch momentum",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "bop",
        "description": "Fetch balance of power",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "cci",
        "description": "Fetch commodity channel index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "cmo",
        "description": "Fetch chande momentum oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "roc",
        "description": "Fetch rate of change",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "rocr",
        "description": "Fetch rate of change ratio",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "aroon",
        "description": "Fetch aroon",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "aroonosc",
        "description": "Fetch aroon oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "mfi",
        "description": "Fetch money flow index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "trix",
        "description": "Fetch triple exponential average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "ultosc",
        "description": "Fetch ultimate oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "timeperiod1": {
              "type": "number"
            },
            "timeperiod2": {
              "type": "number"
            },
            "timeperiod3": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "timeperiod1",
            "timeperiod2",
            "timeperiod3"
          ]
        }
      },
      {
        "name": "dx",
        "description": "Fetch directional movement index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "minus_di",
        "description": "Fetch minus directional indicator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "plus_di",
        "description": "Fetch plus directional indicator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "minus_dm",
        "description": "Fetch minus directional movement",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "plus_dm",
        "description": "Fetch plus directional movement",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "bbands",
        "description": "Fetch bollinger bands",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "nbdevup": {
              "type": "number"
            },
            "nbdevdn": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type",
            "nbdevup",
            "nbdevdn"
          ]
        }
      },
      {
        "name": "midpoint",
        "description": "Fetch midpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "midprice",
        "description": "Fetch midprice",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "sar",
        "description": "Fetch parabolic sar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "acceleration": {
              "type": "number"
            },
            "maximum": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "trange",
        "description": "Fetch true range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "atr",
        "description": "Fetch average true range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "natr",
        "description": "Fetch normalized average true range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "ad",
        "description": "Fetch accumulation/distribution line",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "adosc",
        "description": "Fetch accumulation/distribution oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "fastperiod",
            "slowperiod"
          ]
        }
      },
      {
        "name": "obv",
        "description": "Fetch on balance volume",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "ht_trendline",
        "description": "Fetch hilbert transform - trendline",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type"
          ]
        }
      },
      {
        "name": "ht_sine",
        "description": "Fetch hilbert transform - sine wave",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type"
          ]
        }
      },
      {
        "name": "ht_trendmode",
        "description": "Fetch hilbert transform - trend mode",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "ht_dcperiod",
        "description": "Fetch hilbert transform - dominant cycle period",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "ht_dcphase",
        "description": "Fetch hilbert transform - dominant cycle phase",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "ht_phasor",
        "description": "Fetch hilbert transform - phasor components",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      }
    ]
  },
  "drupal": {
    "name": "drupal",
    "display_name": "Drupal Server",
    "description": "Server for interacting with [Drupal](https://www.drupal.org/project/mcp) using STDIO transport layer.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Omedia/mcp-server-drupal"
    },
    "homepage": "https://github.com/Omedia/mcp-server-drupal",
    "author": {
      "name": "Omedia"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Drupal",
      "TypeScript"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "deno",
          "run",
          "-A",
          "jsr:@omedia/mcp-server-drupal@${VERSION}",
          "--drupal-url",
          "${DRUPAL_BASE_URL}"
        ],
        "env": {}
      }
    },
    "arguments": {
      "VERSION": {
        "description": "The version of the MCP server to be used. This must be provided to ensure compatibility with the installed Drupal version.",
        "required": true,
        "example": "1.0.0"
      },
      "DRUPAL_BASE_URL": {
        "description": "The base URL of the Drupal site that the MCP server will interact with.",
        "required": true,
        "example": "https://example.com"
      }
    }
  },
  "placid-app": {
    "name": "placid-app",
    "display_name": "Placid.app",
    "description": "Generate image and video creatives using Placid.app templates",
    "repository": {
      "type": "git",
      "url": "https://github.com/felores/placid-mcp-server"
    },
    "homepage": "https://github.com/felores/placid-mcp-server",
    "author": {
      "name": "felores"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Placid",
      "Templates",
      "Image Generation",
      "Video Generation"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@felores/placid-mcp-server"
        ],
        "env": {
          "PLACID_API_TOKEN": "${PLACID_API_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Generate Video Example",
        "description": "Example usage for generating a video using Placid templates.",
        "prompt": "{\"template_id\":\"template-uuid\",\"layers\":{\"MEDIA\":{\"video\":\"https://example.com/video.mp4\"},\"PHOTO\":{\"image\":\"https://example.com/photo.jpg\"},\"LOGO\":{\"image\":\"https://example.com/logo.png\"},\"HEADLINE\":{\"text\":\"My Video Title\"}},\"audio\":\"https://example.com/background.mp3\",\"audio_duration\":\"auto\"}"
      },
      {
        "title": "Generate Image Example",
        "description": "Example usage for generating an image using Placid templates.",
        "prompt": "{\"template_id\":\"template-uuid\",\"layers\":{\"headline\":{\"text\":\"Welcome to My App\"},\"background\":{\"image\":\"https://example.com/bg.jpg\"}}}"
      }
    ],
    "arguments": {
      "PLACID_API_TOKEN": {
        "description": "Your Placid API token used for authenticating requests to the Placid API.",
        "required": true,
        "example": "my-secret-api-token"
      }
    },
    "tools": [
      {
        "name": "placid_list_templates",
        "description": "Get a list of available Placid templates with optional filtering. Each template includes its title, ID, preview image URL, available layers, and tags.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection_id": {
              "type": "string",
              "description": "Optional: Filter templates by collection ID"
            },
            "custom_data": {
              "type": "string",
              "description": "Optional: Filter by custom reference data"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional: Filter templates by tags"
            }
          }
        }
      },
      {
        "name": "placid_generate_image",
        "description": "Generate an image using a template and provided assets",
        "inputSchema": {
          "type": "object",
          "required": [
            "template_id",
            "layers"
          ],
          "properties": {
            "template_id": {
              "type": "string",
              "description": "UUID of the template to use"
            },
            "layers": {
              "type": "object",
              "description": "Key-value pairs for dynamic content. Keys must match template layer names.",
              "additionalProperties": {
                "oneOf": [
                  {
                    "type": "object",
                    "properties": {
                      "text": {
                        "type": "string",
                        "description": "Content for text layers"
                      }
                    },
                    "required": [
                      "text"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "image": {
                        "type": "string",
                        "format": "uri",
                        "description": "URL for image/video layers"
                      }
                    },
                    "required": [
                      "image"
                    ]
                  }
                ]
              }
            }
          }
        }
      },
      {
        "name": "placid_generate_video",
        "description": "Generate a video using one or more templates and provided assets. Every 10 seconds of video uses 10 credits.",
        "inputSchema": {
          "type": "object",
          "required": [
            "template_id",
            "layers"
          ],
          "properties": {
            "template_id": {
              "type": "string",
              "description": "UUID of the template to use"
            },
            "layers": {
              "type": "object",
              "description": "Key-value pairs for dynamic content. Keys must match template layer names.",
              "additionalProperties": {
                "oneOf": [
                  {
                    "type": "object",
                    "properties": {
                      "text": {
                        "type": "string",
                        "description": "Content for text layers"
                      }
                    },
                    "required": [
                      "text"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "image": {
                        "type": "string",
                        "format": "uri",
                        "description": "URL for image layers"
                      }
                    },
                    "required": [
                      "image"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "video": {
                        "type": "string",
                        "format": "uri",
                        "description": "URL for video layers (.mp4)"
                      }
                    },
                    "required": [
                      "video"
                    ]
                  }
                ]
              }
            },
            "audio": {
              "type": "string",
              "description": "URL of mp3 audio file for this video"
            },
            "audio_duration": {
              "type": "string",
              "description": "Set to 'auto' to trim audio to video length"
            },
            "audio_trim_start": {
              "type": "string",
              "description": "Timestamp of the trim start point (e.g. '00:00:45' or '00:00:45.25')"
            },
            "audio_trim_end": {
              "type": "string",
              "description": "Timestamp of the trim end point (e.g. '00:00:55' or '00:00:55.25')"
            }
          }
        }
      }
    ]
  },
  "web-fetch": {
    "name": "web-fetch",
    "description": "A Model Context Protocol (MCP) server for fetching webpages including html/pdf/plain text type content.",
    "display_name": "Web Fetch",
    "repository": {
      "type": "git",
      "url": "https://github.com/pathintegral-institute/mcp.science"
    },
    "homepage": "https://github.com/pathintegral-institute/mcp.science/tree/main/servers/web-fetch",
    "author": {
      "name": "pathintegral-institute"
    },
    "license": "MIT",
    "tags": [
      "web",
      "fetch",
      "html",
      "pdf",
      "text"
    ],
    "arguments": {
      "user_agent": {
        "description": "Custom user-agent for fetching web content",
        "required": false,
        "example": "ModelContextProtocol/1.0 (User-Specified; +https://github.com/modelcontextprotocol/servers)"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pathintegral-institute/mcp.science#subdirectory=servers/web-fetch",
          "mcp-web-fetch"
        ],
        "description": "Run using uv (recommended)"
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "ghcr.io/mcp-servers/fetch:latest"
        ],
        "description": "Run using Docker"
      }
    },
    "examples": [
      {
        "title": "Fetch PDF content",
        "description": "Fetch PDF content from a URL",
        "prompt": "fetch web from url: https://proceedings.neurips.cc/paper_files/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf"
      },
      {
        "title": "Fetch HTML content",
        "description": "Fetch HTML content from a website",
        "prompt": "fetch web from url: https://example.com"
      },
      {
        "title": "Fetch raw content",
        "description": "Fetch raw content from a URL",
        "prompt": "fetch web from url: https://example.com/data.json with raw=true"
      },
      {
        "title": "Fetch with custom user-agent",
        "description": "Fetch content with a custom user-agent (requires server configuration)",
        "prompt": "fetch web from url: https://example.com using a mobile browser user-agent"
      }
    ],
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "fetch-web",
        "description": "Fetch URL and return content according to its content type. Returns parsed content by default or raw content if specified.",
        "prompt": "Fetch web from url: https://example.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to fetch",
              "format": "uri",
              "minLength": 1
            },
            "raw": {
              "type": "boolean",
              "description": "Whether to return raw content",
              "default": false
            }
          }
        },
        "required": [
          "url"
        ]
      }
    ],
    "is_official": true
  },
  "siri-shortcuts": {
    "name": "siri-shortcuts",
    "display_name": "Siri Shortcuts",
    "description": "MCP to interact with Siri Shortcuts on macOS. Exposes all Shortcuts as MCP tools.",
    "repository": {
      "type": "git",
      "url": "https://github.com/dvcrn/mcp-server-siri-shortcuts"
    },
    "homepage": "https://github.com/dvcrn/mcp-server-siri-shortcuts",
    "author": {
      "name": "dvcrn"
    },
    "license": "[NOT FOUND]",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "siri",
      "shortcuts",
      "automation"
    ],
    "examples": [
      {
        "title": "List all shortcuts",
        "description": "Fetches all available Siri shortcuts",
        "prompt": "list_shortcuts"
      },
      {
        "title": "Run a specific shortcut",
        "description": "Execute a shortcut with optional input",
        "prompt": "run_shortcut_My_Shortcut_1"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "mcp-server-siri-shortcuts"
        ]
      }
    },
    "tools": [
      {
        "name": "list_shortcuts",
        "description": "List all available Siri shortcuts",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "open_shortcut",
        "description": "Open a shortcut in the Shortcuts app",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the shortcut to open"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "run_shortcut",
        "description": "Run a shortcut with optional input and output parameters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name or identifier of the shortcut to run"
            },
            "input": {
              "type": "string",
              "description": "The input to pass to the shortcut. Can be text, or a filepath"
            }
          },
          "required": [
            "name"
          ]
        }
      }
    ]
  },
  "windows-cli": {
    "name": "windows-cli",
    "display_name": "Windows CLI",
    "description": "MCP server for secure command-line interactions on Windows systems, enabling controlled access to PowerShell, CMD, and Git Bash shells.",
    "repository": {
      "type": "git",
      "url": "https://github.com/SimonB97/win-cli-mcp-server"
    },
    "homepage": "https://github.com/SimonB97/win-cli-mcp-server",
    "author": {
      "name": "SimonB97"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "CLI",
      "Windows",
      "Security",
      "SSH"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@simonb97/server-win-cli",
          "--config",
          "${config}"
        ]
      }
    },
    "examples": [
      {
        "title": "Usage with Claude Desktop",
        "description": "Add MCP server configuration to Claude Desktop.",
        "prompt": "\n{\n  \"mcpServers\": {\n    \"windows-cli\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@simonb97/server-win-cli\"]\n    }\n  }\n}\n"
      }
    ],
    "arguments": {
      "config": {
        "description": "The path to your configuration file, which customizes the server behavior.",
        "required": true,
        "example": "path/to/your/config.json"
      }
    },
    "tools": [
      {
        "name": "execute_command",
        "description": "Execute a command in the specified shell (powershell, cmd, or gitbash)\n\nExample usage (PowerShell):\n```json\n{\n  \"shell\": \"powershell\",\n  \"command\": \"Get-Process | Select-Object -First 5\",\n  \"workingDir\": \"C:\\Users\\username\"\n}\n```\n\nExample usage (CMD):\n```json\n{\n  \"shell\": \"cmd\",\n  \"command\": \"dir /b\",\n  \"workingDir\": \"C:\\Projects\"\n}\n```\n\nExample usage (Git Bash):\n```json\n{\n  \"shell\": \"gitbash\",\n  \"command\": \"ls -la\",\n  \"workingDir\": \"/c/Users/username\"\n}\n```",
        "inputSchema": {
          "type": "object",
          "properties": {
            "shell": {
              "type": "string",
              "enum": [
                "powershell",
                "cmd",
                "gitbash"
              ],
              "description": "Shell to use for command execution"
            },
            "command": {
              "type": "string",
              "description": "Command to execute"
            },
            "workingDir": {
              "type": "string",
              "description": "Working directory for command execution (optional)"
            }
          },
          "required": [
            "shell",
            "command"
          ]
        }
      },
      {
        "name": "get_command_history",
        "description": "Get the history of executed commands\n\nExample usage:\n```json\n{\n  \"limit\": 5\n}\n```\n\nExample response:\n```json\n[\n  {\n    \"command\": \"Get-Process\",\n    \"output\": \"...\",\n    \"timestamp\": \"2024-03-20T10:30:00Z\",\n    \"exitCode\": 0\n  }\n]\n```",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of history entries to return (default: 10, max: 1000)"
            }
          }
        }
      },
      {
        "name": "ssh_execute",
        "description": "Execute a command on a remote host via SSH\n\nExample usage:\n```json\n{\n  \"connectionId\": \"raspberry-pi\",\n  \"command\": \"uname -a\"\n}\n```\n\nConfiguration required in config.json:\n```json\n{\n  \"ssh\": {\n    \"enabled\": true,\n    \"connections\": {\n      \"raspberry-pi\": {\n        \"host\": \"raspberrypi.local\",\n        \"port\": 22,\n        \"username\": \"pi\",\n        \"password\": \"raspberry\"\n      }\n    }\n  }\n}\n```",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection to use",
              "enum": []
            },
            "command": {
              "type": "string",
              "description": "Command to execute"
            }
          },
          "required": [
            "connectionId",
            "command"
          ]
        }
      },
      {
        "name": "ssh_disconnect",
        "description": "Disconnect from an SSH server\n\nExample usage:\n```json\n{\n  \"connectionId\": \"raspberry-pi\"\n}\n```\n\nUse this to cleanly close SSH connections when they're no longer needed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection to disconnect",
              "enum": []
            }
          },
          "required": [
            "connectionId"
          ]
        }
      },
      {
        "name": "create_ssh_connection",
        "description": "Create a new SSH connection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection"
            },
            "connectionConfig": {
              "type": "object",
              "properties": {
                "host": {
                  "type": "string",
                  "description": "Host of the SSH connection"
                },
                "port": {
                  "type": "number",
                  "description": "Port of the SSH connection"
                },
                "username": {
                  "type": "string",
                  "description": "Username for the SSH connection"
                },
                "password": {
                  "type": "string",
                  "description": "Password for the SSH connection"
                },
                "privateKeyPath": {
                  "type": "string",
                  "description": "Path to the private key for the SSH connection"
                }
              },
              "required": [
                "connectionId",
                "connectionConfig"
              ]
            }
          }
        }
      },
      {
        "name": "read_ssh_connections",
        "description": "Read all SSH connections",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "update_ssh_connection",
        "description": "Update an existing SSH connection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection to update"
            },
            "connectionConfig": {
              "type": "object",
              "properties": {
                "host": {
                  "type": "string",
                  "description": "Host of the SSH connection"
                },
                "port": {
                  "type": "number",
                  "description": "Port of the SSH connection"
                },
                "username": {
                  "type": "string",
                  "description": "Username for the SSH connection"
                },
                "password": {
                  "type": "string",
                  "description": "Password for the SSH connection"
                },
                "privateKeyPath": {
                  "type": "string",
                  "description": "Path to the private key for the SSH connection"
                }
              },
              "required": [
                "connectionId",
                "connectionConfig"
              ]
            }
          }
        }
      },
      {
        "name": "delete_ssh_connection",
        "description": "Delete an existing SSH connection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection to delete"
            }
          },
          "required": [
            "connectionId"
          ]
        }
      },
      {
        "name": "get_current_directory",
        "description": "Get the current working directory",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "make-mcp-server": {
    "display_name": "Make MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/integromat/make-mcp-server"
    },
    "homepage": "https://github.com/integromat/make-mcp-server",
    "author": {
      "name": "integromat"
    },
    "license": "MIT",
    "tags": [
      "make",
      "automation",
      "ai",
      "mcp",
      "scenarios"
    ],
    "arguments": {
      "MAKE_API_KEY": {
        "description": "API key generated in your Make profile",
        "required": true,
        "example": "<your-api-key>"
      },
      "MAKE_ZONE": {
        "description": "The zone your organization is hosted in",
        "required": true,
        "example": "eu2.make.com"
      },
      "MAKE_TEAM": {
        "description": "Team ID found in the URL of the Team page",
        "required": true,
        "example": "<your-team-id>"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@makehq/mcp-server"
        ],
        "env": {
          "MAKE_API_KEY": "<your-api-key>",
          "MAKE_ZONE": "<your-zone>",
          "MAKE_TEAM": "<your-team-id>"
        },
        "description": "Install and run using npm",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Using Make scenarios with Claude Desktop",
        "description": "Configure the Make MCP server in Claude Desktop to access your Make scenarios",
        "prompt": "I'd like to use my Make scenarios as tools. Can you help me set that up?"
      }
    ],
    "name": "make-mcp-server",
    "description": "A Model Context Protocol server that enables Make scenarios to be utilized as tools by AI assistants. This integration allows AI systems to trigger and interact with your Make automation workflows.",
    "categories": [
      "Productivity"
    ],
    "tools": [],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "x-twitter": {
    "name": "x-twitter",
    "display_name": "X (Twitter)",
    "description": "Create, manage and publish X/Twitter posts directly through Claude chat.",
    "repository": {
      "type": "git",
      "url": "https://github.com/vidhupv/x-mcp"
    },
    "homepage": "https://github.com/vidhupv/x-mcp",
    "author": {
      "name": "vidhupv"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Twitter",
      "X"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/vidhupv/x-mcp",
          "x-mcp"
        ],
        "env": {
          "TWITTER_API_KEY": "${TWITTER_API_KEY}",
          "TWITTER_API_SECRET": "${TWITTER_API_SECRET}",
          "TWITTER_ACCESS_TOKEN": "${TWITTER_ACCESS_TOKEN}",
          "TWITTER_ACCESS_TOKEN_SECRET": "${TWITTER_ACCESS_TOKEN_SECRET}"
        }
      }
    },
    "examples": [
      {
        "title": "Tweet",
        "description": "Example of sending a tweet through Claude chat.",
        "prompt": "Tweet 'Just learned how to tweet through AI - mind blown! \ud83e\udd16\u2728'"
      },
      {
        "title": "Create Thread",
        "description": "Create a thread about a specific topic.",
        "prompt": "Create a thread about the history of pizza"
      },
      {
        "title": "Show Drafts",
        "description": "Request to see draft tweets.",
        "prompt": "Show me my draft tweets"
      },
      {
        "title": "Publish Draft",
        "description": "Publish an existing draft.",
        "prompt": "Publish this draft!"
      },
      {
        "title": "Delete Draft",
        "description": "Delete a specific draft.",
        "prompt": "Delete that draft"
      }
    ],
    "arguments": {
      "TWITTER_API_KEY": {
        "description": "The API key for accessing Twitter's API.",
        "required": true,
        "example": "your_api_key"
      },
      "TWITTER_API_SECRET": {
        "description": "The API secret key for accessing Twitter's API.",
        "required": true,
        "example": "your_api_secret"
      },
      "TWITTER_ACCESS_TOKEN": {
        "description": "The access token for authorizing the application to access Twitter on behalf of the user.",
        "required": true,
        "example": "your_access_token"
      },
      "TWITTER_ACCESS_TOKEN_SECRET": {
        "description": "The access token secret for authorizing the application to access Twitter on behalf of the user.",
        "required": true,
        "example": "your_access_token_secret"
      }
    },
    "tools": [
      {
        "name": "create_draft_tweet",
        "description": "Create a draft tweet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content of the tweet"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "create_draft_thread",
        "description": "Create a draft tweet thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contents": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of tweet contents for the thread"
            }
          },
          "required": [
            "contents"
          ]
        }
      },
      {
        "name": "list_drafts",
        "description": "List all draft tweets and threads",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "publish_draft",
        "description": "Publish a draft tweet or thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "draft_id": {
              "type": "string",
              "description": "ID of the draft to publish"
            }
          },
          "required": [
            "draft_id"
          ]
        }
      },
      {
        "name": "delete_draft",
        "description": "Delete a draft tweet or thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "draft_id": {
              "type": "string",
              "description": "ID of the draft to delete"
            }
          },
          "required": [
            "draft_id"
          ]
        }
      }
    ]
  },
  "chatmcp": {
    "name": "chatmcp",
    "display_name": "Chat Desktop App",
    "description": "\u2013 An Open Source Cross-platform GUI Desktop application compatible with Linux, macOS, and Windows, enabling seamless interaction with MCP servers across dynamically selectable LLMs, by **[AIQL](https://github.com/AI-QL/chat-mcp)**",
    "repository": {
      "type": "git",
      "url": "https://github.com/AI-QL/chat-mcp"
    },
    "homepage": "https://github.com/AI-QL/chat-mcp",
    "author": {
      "name": "AIQL"
    },
    "license": "Apache-2.0",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "LLM",
      "Electron",
      "cross-platform"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/AI-QL/chat-mcp"
        ],
        "env": {
          "SEARCH_PATH": "${SEARCH_PATH}"
        }
      }
    },
    "arguments": {
      "SEARCH_PATH": {
        "description": "This environment variable specifies the system's executable search path, which determines where the operating system looks for executable files when running commands.",
        "required": false,
        "example": "C:\\Program Files\\nodejs;C:\\Windows\\System32"
      }
    }
  },
  "monday-com": {
    "name": "monday-com",
    "display_name": "Monday.com",
    "description": "MCP Server to interact with Monday.com boards and items.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sakce/mcp-server-monday"
    },
    "homepage": "https://github.com/sakce/mcp-server-monday",
    "author": {
      "name": "sakce"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "monday.com",
      "API"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-monday"
        ],
        "env": {
          "MONDAY_API_KEY": "${MONDAY_API_KEY}",
          "MONDAY_WORKSPACE_NAME": "${MONDAY_WORKSPACE_NAME}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "-e",
          "MONDAY_API_KEY=${MONDAY_API_KEY}",
          "-e",
          "MONDAY_WORKSPACE_NAME=${MONDAY_WORKSPACE_NAME}",
          "sakce/mcp-server-monday"
        ]
      }
    },
    "arguments": {
      "MONDAY_API_KEY": {
        "description": "API key for authenticating with the Monday.com API.",
        "required": true,
        "example": "your-monday-api-key"
      },
      "MONDAY_WORKSPACE_NAME": {
        "description": "The name of the Monday.com workspace you are working with.",
        "required": true,
        "example": "myworkspace"
      }
    },
    "tools": [
      {
        "name": "monday-create-item",
        "description": "Create a new item in a Monday.com Board. Optionally, specify the parent Item ID to create a Sub-item.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            },
            "itemTitle": {
              "type": "string",
              "description": "Name of the Monday.com Item or Sub-item that will be created."
            },
            "groupId": {
              "type": "string",
              "description": "Monday.com Board's Group ID to create the Item in. If set, parentItemId should not be set."
            },
            "parentItemId": {
              "type": "string",
              "description": "Monday.com Item ID to create the Sub-item under. If set, groupId should not be set."
            },
            "columnValues": {
              "type": "object",
              "description": "Dictionary of column values to set {column_id: value}"
            }
          },
          "required": [
            "boardId",
            "itemTitle"
          ]
        }
      },
      {
        "name": "monday-get-items-by-id",
        "description": "Fetch specific Monday.com item by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "ID of the Monday.com item to fetch."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-update-item",
        "description": "Update a Monday.com item's or sub-item's column values.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            },
            "itemId": {
              "type": "string",
              "description": "Monday.com Item or Sub-item ID to update the columns of."
            },
            "columnValues": {
              "type": "object",
              "description": "Dictionary of column values to update the Monday.com Item or Sub-item with. ({column_id: value})"
            }
          },
          "required": [
            "boardId",
            "itemId",
            "columnValues"
          ]
        }
      },
      {
        "name": "monday-get-board-columns",
        "description": "Get the Columns of a Monday.com Board.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "monday-get-board-groups",
        "description": "Get the Groups of a Monday.com Board.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "monday-create-update",
        "description": "Create an update (comment) on a Monday.com Item or Sub-item.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string"
            },
            "updateText": {
              "type": "string",
              "description": "Content to update the Item or Sub-item with."
            }
          },
          "required": [
            "itemId",
            "updateText"
          ]
        }
      },
      {
        "name": "monday-list-boards",
        "description": "Get all Boards from Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of Monday.com Boards to return."
            }
          }
        }
      },
      {
        "name": "monday-list-items-in-groups",
        "description": "List all items in the specified groups of a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            },
            "groupIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "limit": {
              "type": "integer"
            },
            "cursor": {
              "type": "string"
            }
          },
          "required": [
            "boardId",
            "groupIds",
            "limit"
          ]
        }
      },
      {
        "name": "monday-list-subitems-in-items",
        "description": "List all Sub-items of a list of Monday.com Items",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "itemIds"
          ]
        }
      },
      {
        "name": "monday-create-board",
        "description": "Create a new Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "board_name": {
              "type": "string",
              "description": "Name of the Monday.com board to create"
            },
            "board_kind": {
              "type": "string",
              "description": "Kind of the Monday.com board to create (public, private, shareable). Default is public."
            }
          },
          "required": [
            "board_name"
          ]
        }
      },
      {
        "name": "monday-create-board-group",
        "description": "Create a new group in a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the group will be created in."
            },
            "groupName": {
              "type": "string",
              "description": "Name of the group to create."
            }
          },
          "required": [
            "boardId",
            "groupName"
          ]
        }
      },
      {
        "name": "monday-move-item-to-group",
        "description": "Move an item to a group in a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Monday.com Item ID to move."
            },
            "groupId": {
              "type": "string",
              "description": "Monday.com Group ID to move the Item to."
            }
          },
          "required": [
            "itemId",
            "groupId"
          ]
        }
      },
      {
        "name": "monday-delete-item",
        "description": "Delete an item from a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Monday.com Item ID to delete."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-archive-item",
        "description": "Archive an item from a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Monday.com Item ID to archive."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-get-item-updates",
        "description": "Get updates for a specific item in Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "ID of the Monday.com item to get updates for."
            },
            "limit": {
              "type": "integer",
              "description": "Maximum number of updates to retrieve. Default is 25."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-get-docs",
        "description": "Get a list of documents from Monday.com, optionally filtered by folder",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of documents to retrieve. Default is 25."
            },
            "folder_id": {
              "type": "string",
              "description": "Optional folder ID to filter documents by."
            }
          }
        }
      },
      {
        "name": "monday-get-doc-content",
        "description": "Get the content of a specific document by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "doc_id": {
              "type": "string",
              "description": "ID of the Monday.com document to retrieve."
            }
          },
          "required": [
            "doc_id"
          ]
        }
      },
      {
        "name": "monday-create-doc",
        "description": "Create a new document in Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "Title of the document to create."
            },
            "content": {
              "type": "string",
              "description": "Content of the document to create."
            },
            "folder_id": {
              "type": "string",
              "description": "Optional folder ID to create the document in."
            }
          },
          "required": [
            "title",
            "content"
          ]
        }
      },
      {
        "name": "monday-add-doc-block",
        "description": "Add a block to a document",
        "inputSchema": {
          "type": "object",
          "properties": {
            "doc_id": {
              "type": "string",
              "description": "ID of the Monday.com document to add a block to."
            },
            "block_type": {
              "type": "string",
              "description": "Type of block to add (normal_text, bullet_list, numbered_list, heading, divider, etc.)."
            },
            "content": {
              "type": "string",
              "description": "Content of the block to add."
            },
            "after_block_id": {
              "type": "string",
              "description": "Optional ID of the block to add this block after."
            }
          },
          "required": [
            "doc_id",
            "block_type",
            "content"
          ]
        }
      },
      {
        "name": "monday-get-item-files",
        "description": "Get files (PDFs, documents, images, etc.) attached to a Monday.com item",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "ID of the Monday.com item to get files from."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-get-update-files",
        "description": "Get files (PDFs, documents, images, etc.) attached to a specific update in Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "updateId": {
              "type": "string",
              "description": "ID of the Monday.com update to get files from."
            }
          },
          "required": [
            "updateId"
          ]
        }
      }
    ]
  },
  "crypto-feargreed-mcp": {
    "name": "crypto-feargreed-mcp",
    "display_name": "Crypto Fear & Greed Index",
    "description": "Providing real-time and historical Crypto Fear & Greed Index data.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kukapay/crypto-feargreed-mcp"
    },
    "homepage": "https://github.com/kukapay/crypto-feargreed-mcp",
    "author": {
      "name": "KukaPay",
      "url": "https://github.com/kukapay"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Fear & Greed",
      "Crypto Index",
      "Analytics"
    ],
    "examples": [
      {
        "title": "Get Current Index",
        "description": "What is the current Crypto Fear & Greed Index?",
        "prompt": "What's the current Crypto Fear & Greed Index?"
      },
      {
        "title": "Analyze Trend",
        "description": "Show the Fear & Greed Index trend for a specific number of days.",
        "prompt": "Show me the Crypto Fear & Greed Index trend for the last 30 days."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kukapay/crypto-feargreed-mcp",
          "main.py"
        ]
      }
    },
    "tools": [
      {
        "name": "get_current_fng_tool",
        "description": "Get the current Fear and Greed Index value.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "get_historical_fng_tool",
        "description": "Get historical Fear and Greed Index data for the specified number of days.",
        "inputSchema": {
          "days": {
            "type": "integer",
            "description": "Number of days for historical data"
          }
        },
        "required": [
          "days"
        ]
      },
      {
        "name": "analyze_fng_trend",
        "description": "Analyze the Fear and Greed Index trend over the specified number of days.",
        "inputSchema": {
          "days": {
            "type": "integer",
            "description": "Number of days for trend analysis"
          }
        },
        "required": [
          "days"
        ]
      }
    ]
  },
  "mcp-local-rag": {
    "name": "mcp-local-rag",
    "display_name": "Local RAG",
    "description": "\"primitive\" RAG-like web search model context protocol (MCP) server that runs locally using Google's MediaPipe Text Embedder and DuckDuckGo Search. \u2728 no APIs required \u2728.",
    "repository": {
      "type": "git",
      "url": "https://github.com/nkapila6/mcp-local-rag"
    },
    "license": "MIT",
    "author": {
      "name": "nkapila6"
    },
    "homepage": "https://github.com/nkapila6/mcp-local-rag",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "RAG",
      "Search"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--python=3.10",
          "--from",
          "git+https://github.com/nkapila6/mcp-local-rag",
          "mcp-local-rag"
        ]
      }
    },
    "tools": [
      {
        "name": "rag_search",
        "description": "\n    Search the web for a given query. Give back context to the LLM\n    with a RAG-like similarity sort.\n\n    Args:\n        query (str): The query to search for.\n        num_results (int): Number of results to return.\n        top_k (int): Use top \"k\" results for content.\n\n    Returns:\n        Dict of strings containing best search based on input query. Formatted in markdown.\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "num_results": {
              "default": 10,
              "title": "Num Results",
              "type": "integer"
            },
            "top_k": {
              "default": 5,
              "title": "Top K",
              "type": "integer"
            }
          },
          "required": [
            "query"
          ],
          "title": "rag_searchArguments",
          "type": "object"
        }
      }
    ]
  },
  "rememberizer-ai": {
    "name": "rememberizer-ai",
    "display_name": "Rememberizer",
    "description": "An MCP server designed for interacting with the Rememberizer data source, facilitating enhanced knowledge retrieval.",
    "repository": {
      "type": "git",
      "url": "https://github.com/skydeckai/mcp-server-rememberizer"
    },
    "homepage": "https://github.com/skydeckai/mcp-server-rememberizer",
    "author": {
      "name": "skydeckai"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Rememberizer",
      "Document Management",
      "Knowledge Management",
      "API"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-rememberizer"
        ],
        "env": {
          "REMEMBERIZER_API_TOKEN": "${REMEMBERIZER_API_TOKEN}"
        }
      }
    },
    "arguments": {
      "REMEMBERIZER_API_TOKEN": {
        "description": "Your Rememberizer API token, required for accessing the Rememberizer API.",
        "required": true,
        "example": "your_rememberizer_api_token"
      }
    },
    "tools": [
      {
        "name": "rememberizer_account_information",
        "description": "Get information about your Rememberizer.ai personal/team knowledge repository account. This includes account holder name and email address.",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "retrieve_semantically_similar_internal_knowledge",
        "description": "Send a block of text and retrieve cosine similar matches from your connected Rememberizer personal/team internal knowledge and memory repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "match_this": {
              "type": "string",
              "description": "Up to a 400-word sentence for which you wish to find semantically similar chunks of knowledge."
            },
            "n_results": {
              "type": "integer",
              "description": "Number of semantically similar chunks of text to return. Use 'n_results=3' for up to 5, and 'n_results=10' for more information. If you do not receive enough information, consider trying again with a larger 'n_results' value."
            },
            "from_datetime_ISO8601": {
              "type": "string",
              "description": "Start date in ISO 8601 format with timezone (e.g., 2023-01-01T00:00:00Z). Use this to filter results from a specific date."
            },
            "to_datetime_ISO8601": {
              "type": "string",
              "description": "End date in ISO 8601 format with timezone (e.g., 2024-01-01T00:00:00Z). Use this to filter results until a specific date."
            }
          },
          "required": [
            "match_this"
          ]
        }
      },
      {
        "name": "smart_search_internal_knowledge",
        "description": "Search for documents in Rememberizer in its personal/team internal knowledge and memory repository using a simple query that returns the results of an agentic search. The search may include sources such as Slack discussions, Gmail, Dropbox documents, Google Drive documents, and uploaded files. Consider using the tool list_internal_knowledge_systems to find out which are available. Use the tool list_internal_knowledge_systems to find out which sources are available. \n\nYou can specify a from_datetime_ISO8601 and a to_datetime_ISO8601, and you should look at the context of your request to make sure you put reasonable parameters around this by, for example, converting a reference to recently to a start date two weeks before today, or converting yesterday to a timeframe during the last day. But do be aware of the effect of time zone differences in the source data and for the requestor.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Up to a 400-word sentence for which you wish to find semantically similar chunks of knowledge."
            },
            "user_context": {
              "type": "string",
              "description": "The additional context for the query. You might need to summarize the conversation up to this point for better context-awared results."
            },
            "n_results": {
              "type": "integer",
              "description": "Number of semantically similar chunks of text to return. Use 'n_results=3' for up to 5, and 'n_results=10' for more information. If you do not receive enough information, consider trying again with a larger 'n_results' value."
            },
            "from_datetime_ISO8601": {
              "type": "string",
              "description": "Start date in ISO 8601 format with timezone (e.g., 2023-01-01T00:00:00Z). Use this to filter results from a specific date."
            },
            "to_datetime_ISO8601": {
              "type": "string",
              "description": "End date in ISO 8601 format with timezone (e.g., 2024-01-01T00:00:00Z). Use this to filter results until a specific date."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "list_internal_knowledge_systems",
        "description": "List the sources of personal/team internal knowledge. These may include Slack discussions, Gmail, Dropbox documents, Google Drive documents, and uploaded files.",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "list_personal_team_knowledge_documents",
        "description": "Retrieves a paginated list of all documents in your personal/team knowledge system. Sources could include Slack discussions, Gmail, Dropbox documents, Google Drive documents, and uploaded files. Consider using the tool list_internal_knowledge_systems to find out which are available. \n\nUse this tool to browse through available documents and their metadata.\n\nExamples:\n- List first 100 documents: {\"page\": 1, \"page_size\": 100}\n- Get next page: {\"page\": 2, \"page_size\": 100}\n- Get maximum allowed documents: {\"page\": 1, \"page_size\": 1000}\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "description": "Page number for pagination (starts at 1)",
              "minimum": 1,
              "default": 1
            },
            "page_size": {
              "type": "integer",
              "description": "Number of documents per page (1-1000)",
              "minimum": 1,
              "maximum": 1000,
              "default": 100
            }
          }
        }
      },
      {
        "name": "remember_this",
        "description": "Save a piece of text information in your Rememberizer.ai knowledge system so that it may be recalled in future through tools retrieve_semantically_similar_internal_knowledge or smart_search_internal_knowledge.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the information. This is used to identify the information in the future."
            },
            "content": {
              "type": "string",
              "description": "The information you wish to memorize."
            }
          }
        }
      }
    ]
  },
  "octagon-mcp-server": {
    "display_name": "Octagon MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/OctagonAI/octagon-mcp-server"
    },
    "homepage": "https://docs.octagonagents.com",
    "author": {
      "name": "OctagonAI"
    },
    "license": "MIT",
    "tags": [
      "market intelligence",
      "financial analysis",
      "SEC filings",
      "earnings calls",
      "stock market data",
      "private company research",
      "funding rounds",
      "M&A",
      "IPO",
      "web scraping"
    ],
    "arguments": {
      "OCTAGON_API_KEY": {
        "description": "Your Octagon API key",
        "required": true,
        "example": "your_octagon_api_key"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "octagon-mcp"
        ],
        "env": {
          "OCTAGON_API_KEY": "your_octagon_api_key"
        },
        "description": "Run directly with npx",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "SEC Filing Analysis",
        "description": "Extract information from SEC filings",
        "prompt": "What was Apple's gross margin percentage from their latest 10-Q filing?"
      },
      {
        "title": "Earnings Call Analysis",
        "description": "Analyze earnings call transcripts",
        "prompt": "What did NVIDIA's CEO say about AI chip demand in their latest earnings call?"
      },
      {
        "title": "Financial Metrics",
        "description": "Retrieve financial metrics and ratios",
        "prompt": "Calculate the price-to-earnings ratio for Tesla over the last 4 quarters"
      },
      {
        "title": "Stock Market Data",
        "description": "Access stock market data",
        "prompt": "How has Apple's stock performed compared to the S&P 500 over the last 6 months?"
      },
      {
        "title": "Private Company Research",
        "description": "Research private company information",
        "prompt": "What is the employee count and funding history for Anthropic?"
      }
    ],
    "name": "octagon-mcp-server",
    "description": "A Model Context Protocol (MCP) server implementation that integrates with Octagon Market Intelligence API.",
    "categories": [
      "Analytics"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "octagon-sec-agent",
        "description": "[PUBLIC MARKET INTELLIGENCE] A specialized agent for SEC filings analysis and financial data extraction. Covers over 8,000 public companies from SEC EDGAR with comprehensive coverage of financial statements from annual and quarterly reports (10-K, 10-Q, 20-F), offering filings (S-1), amendments, and event filings (8-K). Updated daily with historical data dating back to 2018 for time-series analysis. Best for extracting financial and segment metrics, management discussion, footnotes, risk factors, and quantitative data from SEC filings. Example queries: 'What was Apple's R&D expense as a percentage of revenue in their latest fiscal year?', 'Find the risk factors related to supply chain in Tesla's latest 10-K', 'Extract quarterly revenue growth rates for Microsoft over the past 2 years'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-transcripts-agent",
        "description": "[PUBLIC MARKET INTELLIGENCE] A specialized agent for analyzing earnings call transcripts and management commentary. Covers over 8,000 public companies with continuous daily updates for real-time insights. Historical data dating back to 2018 enables robust time-series analysis. Extract information from earnings call transcripts, including executive statements, financial guidance, analyst questions, and forward-looking statements. Best for analyzing management sentiment, extracting guidance figures, and identifying key business trends. Example queries: 'What did Amazon's CEO say about AWS growth expectations in the latest earnings call?', 'Summarize key financial metrics mentioned in Tesla's Q2 2023 earnings call', 'What questions did analysts ask about margins during Netflix's latest earnings call?'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-financials-agent",
        "description": "[PUBLIC MARKET INTELLIGENCE] Specialized agent for financial statement analysis and ratio calculations. Capabilities: Analyze financial statements, calculate financial metrics, compare ratios, and evaluate performance indicators. Best for: Deep financial analysis and comparison of company financial performance. Example queries: 'Compare the gross margins, operating margins, and net margins of Apple, Microsoft, and Google over the last 3 years', 'Analyze Tesla's cash flow statements from 2021 to 2023 and calculate free cash flow trends', 'Calculate and explain key financial ratios for Amazon including P/E, EV/EBITDA, and ROIC'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-stock-data-agent",
        "description": "[PUBLIC MARKET INTELLIGENCE] Specialized agent for stock market data and equity investment analysis. Capabilities: Analyze stock price movements, trading volumes, market trends, valuation metrics, and technical indicators. Best for: Stock market research, equity analysis, and trading pattern identification. Example queries: 'How has Apple's stock performed compared to the S&P 500 over the last 6 months?', 'Analyze the trading volume patterns for Tesla stock before and after earnings releases', 'What were the major price movements for NVIDIA in 2023 and what were the catalysts?'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-companies-agent",
        "description": "[PRIVATE MARKET INTELLIGENCE] A specialized database agent for looking up company information and financials. Capabilities: Query comprehensive company financial information and business intelligence from Octagon's company database. Best for: Finding basic information about companies, their financial metrics, and industry benchmarks. NOTE: For better and more accurate results, provide the company's website URL instead of just the company name. Example queries: 'What is the employee trends for Stripe (stripe.com)?', 'List the top 5 companies in the AI sector by revenue growth', 'Who are the top competitors to Databricks (databricks.com)?'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-funding-agent",
        "description": "[PRIVATE MARKET INTELLIGENCE] A specialized database agent for company funding transactions and venture capital research. Capabilities: Extract information about funding rounds, investors, valuations, and investment trends. Best for: Researching startup funding history, investor activity, and venture capital patterns. NOTE: For better and more accurate results, provide the company's website URL instead of just the company name. Example queries: 'What was Anthropic's latest funding round size, valuation, and key investors (anthropic.com)?', 'How much has OpenAI raised in total funding and at what valuation (openai.com)?', 'Who were the lead investors in Databricks' Series G round and what was the post-money valuation (databricks.com)?'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-deals-agent",
        "description": "[PRIVATE MARKET INTELLIGENCE] A specialized database agent for M&A and IPO transaction analysis. Capabilities: Retrieve information about mergers, acquisitions, initial public offerings, and other financial transactions. Best for: Research on corporate transactions, IPO valuations, and M&A activity. NOTE: For better and more accurate results, provide the company's website URL instead of just the company name. Example queries: 'What was the acquisition price when Microsoft (microsoft.com) acquired GitHub (github.com)?', 'List the valuation multiples for AI companies in 2024', 'List all the acquisitions and price, valuation by Salesforce (salesforce.com) in 2023?'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-investors-agent",
        "description": "[PRIVATE MARKET INTELLIGENCE] A specialized database agent for looking up information on investors. Capabilities: Retrieve information about investors, their investment criteria, and past activities. Best for: Research on investors and details about their investment activities. NOTE: For better and more accurate results, provide the investor's website URL instead of just the investor name. Example queries: 'What is the latest investment criteria of Insight Partners (insightpartners.com)?', 'How many investments did Andreessen Horowitz (a16z.com) make in the last 6 months', 'What is the typical check size for QED Investors (qedinvestors.com)'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-scraper-agent",
        "description": "[PUBLIC & PRIVATE MARKET INTELLIGENCE] Specialized agent for financial data extraction from investor websites. Capabilities: Extract structured financial data from investor relations websites, tables, and online financial sources. Best for: Gathering financial data from websites that don't have accessible APIs. Example queries: 'Extract all data fields from zillow.com/san-francisco-ca/', 'Extract all data fields from www.carvana.com/cars/'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-deep-research-agent",
        "description": "[PUBLIC & PRIVATE MARKET INTELLIGENCE] A comprehensive agent that can utilize multiple sources for deep research analysis. Capabilities: Aggregate research across multiple data sources, synthesize information, and provide comprehensive investment research. Best for: Investment research questions requiring up-to-date aggregated information from the web. Example queries: 'Research the financial impact of Apple's privacy changes on digital advertising companies' revenue and margins', 'Analyze the competitive landscape in the cloud computing sector, focusing on AWS, Azure, and Google Cloud margin and growth trends', 'Investigate the factors driving electric vehicle adoption and their impact on battery supplier financials'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "octagon-debts-agent",
        "description": "[PRIVATE MARKET INTELLIGENCE] A specialized database agent for analyzing private debts and lenders. Capabilities: Retrieve information about private debts and lenders. Best for: Research on borrowers, and lenders and details about the private debt facilities. Example queries: 'List all the debt activities from borrower American Tower', 'Compile all the debt activities from lender ING Group in Q4 2024'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Your natural language query or request for the agent"
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "langflow-doc-qa-server": {
    "name": "langflow-doc-qa-server",
    "display_name": "Langflow Document Q&A",
    "description": "A Model Context Protocol server for document Q&A powered by Langflow. It demonstrates core MCP concepts by providing a simple interface to query documents through a Langflow backend.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/Langflow-DOC-QA-SERVER"
    },
    "homepage": "https://github.com/GongRzhe/Langflow-DOC-QA-SERVER",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Langflow",
      "Document Q&A"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/GongRzhe/Langflow-DOC-QA-SERVER"
        ],
        "env": {
          "API_ENDPOINT": "${API_ENDPOINT}"
        }
      }
    },
    "arguments": {
      "API_ENDPOINT": {
        "description": "The endpoint URL for the Langflow API service.",
        "required": false,
        "example": "http://127.0.0.1:7860/api/v1/run/<flow-id>?stream=false"
      }
    },
    "tools": [
      {
        "name": "query_docs",
        "description": "Query the document Q&A system with a prompt",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query prompt to search for in the documents"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "ssh-exec": {
    "name": "ssh-exec",
    "description": "A Model Context Protocol (MCP) server for executing command-line operations on remote servers via SSH.",
    "display_name": "SSH Execution",
    "repository": {
      "type": "git",
      "url": "https://github.com/pathintegral-institute/mcp.science"
    },
    "homepage": "https://github.com/pathintegral-institute/mcp.science/tree/main/servers/ssh-exec",
    "author": {
      "name": "pathintegral-institute"
    },
    "license": "MIT",
    "tags": [
      "ssh",
      "command execution",
      "remote systems"
    ],
    "arguments": {
      "SSH_HOST": {
        "description": "SSH host to connect to",
        "required": true,
        "example": "your-server.com"
      },
      "SSH_PORT": {
        "description": "SSH port",
        "required": false,
        "example": "22"
      },
      "SSH_USERNAME": {
        "description": "SSH username",
        "required": true,
        "example": "your_username"
      },
      "SSH_PRIVATE_KEY": {
        "description": "SSH private key content (not path)",
        "required": false,
        "example": "$(cat ~/.ssh/id_rsa)"
      },
      "SSH_PASSWORD": {
        "description": "SSH password",
        "required": false,
        "example": "[NOT GIVEN]"
      },
      "SSH_ALLOWED_COMMANDS": {
        "description": "Comma-separated list of commands that are allowed to be executed",
        "required": false,
        "example": "ls,ps,cat"
      },
      "SSH_ALLOWED_PATHS": {
        "description": "Comma-separated list of paths that are allowed for command execution",
        "required": false,
        "example": "/tmp,/home"
      },
      "SSH_COMMANDS_BLACKLIST": {
        "description": "Comma-separated list of commands that are not allowed",
        "required": false,
        "example": "rm,mv,dd,mkfs,fdisk,format"
      },
      "SSH_ARGUMENTS_BLACKLIST": {
        "description": "Comma-separated list of arguments that are not allowed",
        "required": false,
        "example": "-rf,-fr,--force"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pathintegral-institute/mcp.science#subdirectory=servers/ssh-exec",
          "mcp-ssh-exec"
        ],
        "env": {
          "SSH_HOST": "your-server.com",
          "SSH_PORT": "22",
          "SSH_USERNAME": "your_username",
          "SSH_PRIVATE_KEY": "$(cat ~/.ssh/id_rsa)",
          "SSH_ALLOWED_COMMANDS": "ls,ps,cat",
          "SSH_ALLOWED_PATHS": "/tmp,/home",
          "SSH_COMMANDS_BLACKLIST": "rm,mv,dd,mkfs,fdisk,format",
          "SSH_ARGUMENTS_BLACKLIST": "-rf,-fr,--force"
        },
        "description": "Run server using uv"
      }
    },
    "examples": [
      {
        "title": "Execute a command",
        "description": "Execute a command on the remote system",
        "prompt": "Execute 'ls -la /tmp' on the remote server"
      }
    ],
    "categories": [
      "System Tools"
    ],
    "tools": [
      {
        "name": "ssh_exec",
        "description": "Execute a command on the remote system",
        "inputSchema": {
          "properties": {
            "command": {
              "description": "Command for SSH server to execute",
              "title": "Command",
              "type": "string"
            },
            "arguments": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Arguments to pass to the command",
              "title": "Arguments"
            },
            "timeout": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Timeout in seconds for command execution",
              "title": "Timeout"
            }
          },
          "required": [
            "command"
          ],
          "title": "ssh_execArguments",
          "type": "object"
        }
      }
    ],
    "is_official": true
  },
  "github": {
    "name": "github",
    "display_name": "GitHub",
    "description": "MCP Server for the GitHub API, enabling file operations, repository management, search functionality, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/github#readme",
    "author": {
      "name": "MCP Team"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "github",
      "code",
      "repository",
      "git"
    ],
    "arguments": {
      "GITHUB_PERSONAL_ACCESS_TOKEN": {
        "description": "Personal Access Token for GitHub to authenticate API requests",
        "required": true,
        "example": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-github"
        ],
        "package": "@modelcontextprotocol/server-github",
        "env": {
          "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_PERSONAL_ACCESS_TOKEN}"
        },
        "description": "Install and run using NPX",
        "recommended": true
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "GITHUB_PERSONAL_ACCESS_TOKEN",
          "mcp/github"
        ],
        "env": {
          "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_PERSONAL_ACCESS_TOKEN}"
        },
        "description": "Run with Docker"
      }
    },
    "examples": [
      {
        "title": "Search GitHub repositories",
        "description": "Find repositories related to machine learning",
        "prompt": "Find GitHub repositories about machine learning with more than 1000 stars."
      },
      {
        "title": "View repository contents",
        "description": "Browse files in a GitHub repository",
        "prompt": "Show me the main Python files in the Hugging Face transformers repository."
      }
    ],
    "tools": [
      {
        "name": "create_or_update_file",
        "description": "Create or update a single file in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "path": {
              "type": "string",
              "description": "Path where to create/update the file"
            },
            "content": {
              "type": "string",
              "description": "Content of the file"
            },
            "message": {
              "type": "string",
              "description": "Commit message"
            },
            "branch": {
              "type": "string",
              "description": "Branch to create/update the file in"
            },
            "sha": {
              "type": "string",
              "description": "SHA of the file being replaced (required when updating existing files)"
            }
          },
          "required": [
            "owner",
            "repo",
            "path",
            "content",
            "message",
            "branch"
          ]
        }
      },
      {
        "name": "search_repositories",
        "description": "Search for GitHub repositories",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query (see GitHub search syntax)"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination (default: 1)"
            },
            "perPage": {
              "type": "number",
              "description": "Number of results per page (default: 30, max: 100)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "create_repository",
        "description": "Create a new GitHub repository in your account",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Repository name"
            },
            "description": {
              "type": "string",
              "description": "Repository description"
            },
            "private": {
              "type": "boolean",
              "description": "Whether the repository should be private"
            },
            "autoInit": {
              "type": "boolean",
              "description": "Initialize with README.md"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_file_contents",
        "description": "Get the contents of a file or directory from a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "path": {
              "type": "string",
              "description": "Path to the file or directory"
            },
            "branch": {
              "type": "string",
              "description": "Branch to get contents from"
            }
          },
          "required": [
            "owner",
            "repo",
            "path"
          ]
        }
      },
      {
        "name": "push_files",
        "description": "Push multiple files to a GitHub repository in a single commit",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "branch": {
              "type": "string",
              "description": "Branch to push to (e.g., 'main' or 'master')"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string"
                  },
                  "content": {
                    "type": "string"
                  }
                },
                "required": [
                  "path",
                  "content"
                ],
                "additionalProperties": false
              },
              "description": "Array of files to push"
            },
            "message": {
              "type": "string",
              "description": "Commit message"
            }
          },
          "required": [
            "owner",
            "repo",
            "branch",
            "files",
            "message"
          ]
        }
      },
      {
        "name": "create_issue",
        "description": "Create a new issue in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "body": {
              "type": "string"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "milestone": {
              "type": "number"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "owner",
            "repo",
            "title"
          ]
        }
      },
      {
        "name": "create_pull_request",
        "description": "Create a new pull request in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "title": {
              "type": "string",
              "description": "Pull request title"
            },
            "body": {
              "type": "string",
              "description": "Pull request body/description"
            },
            "head": {
              "type": "string",
              "description": "The name of the branch where your changes are implemented"
            },
            "base": {
              "type": "string",
              "description": "The name of the branch you want the changes pulled into"
            },
            "draft": {
              "type": "boolean",
              "description": "Whether to create the pull request as a draft"
            },
            "maintainer_can_modify": {
              "type": "boolean",
              "description": "Whether maintainers can modify the pull request"
            }
          },
          "required": [
            "owner",
            "repo",
            "title",
            "head",
            "base"
          ]
        }
      },
      {
        "name": "fork_repository",
        "description": "Fork a GitHub repository to your account or specified organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "organization": {
              "type": "string",
              "description": "Optional: organization to fork to (defaults to your personal account)"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "create_branch",
        "description": "Create a new branch in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "branch": {
              "type": "string",
              "description": "Name for the new branch"
            },
            "from_branch": {
              "type": "string",
              "description": "Optional: source branch to create from (defaults to the repository's default branch)"
            }
          },
          "required": [
            "owner",
            "repo",
            "branch"
          ]
        }
      },
      {
        "name": "list_commits",
        "description": "Get list of commits of a branch in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "sha": {
              "type": "string"
            },
            "page": {
              "type": "number"
            },
            "perPage": {
              "type": "number"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "list_issues",
        "description": "List issues in a GitHub repository with filtering options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "direction": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "page": {
              "type": "number"
            },
            "per_page": {
              "type": "number"
            },
            "since": {
              "type": "string"
            },
            "sort": {
              "type": "string",
              "enum": [
                "created",
                "updated",
                "comments"
              ]
            },
            "state": {
              "type": "string",
              "enum": [
                "open",
                "closed",
                "all"
              ]
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "update_issue",
        "description": "Update an existing issue in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "issue_number": {
              "type": "number"
            },
            "title": {
              "type": "string"
            },
            "body": {
              "type": "string"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "milestone": {
              "type": "number"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "state": {
              "type": "string",
              "enum": [
                "open",
                "closed"
              ]
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number"
          ]
        }
      },
      {
        "name": "add_issue_comment",
        "description": "Add a comment to an existing issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "issue_number": {
              "type": "number"
            },
            "body": {
              "type": "string"
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number",
            "body"
          ]
        }
      },
      {
        "name": "search_code",
        "description": "Search for code across GitHub repositories",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string"
            },
            "order": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "page": {
              "type": "number",
              "minimum": 1
            },
            "per_page": {
              "type": "number",
              "minimum": 1,
              "maximum": 100
            }
          },
          "required": [
            "q"
          ]
        }
      },
      {
        "name": "search_issues",
        "description": "Search for issues and pull requests across GitHub repositories",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string"
            },
            "order": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "page": {
              "type": "number",
              "minimum": 1
            },
            "per_page": {
              "type": "number",
              "minimum": 1,
              "maximum": 100
            },
            "sort": {
              "type": "string",
              "enum": [
                "comments",
                "reactions",
                "reactions-+1",
                "reactions--1",
                "reactions-smile",
                "reactions-thinking_face",
                "reactions-heart",
                "reactions-tada",
                "interactions",
                "created",
                "updated"
              ]
            }
          },
          "required": [
            "q"
          ]
        }
      },
      {
        "name": "search_users",
        "description": "Search for users on GitHub",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string"
            },
            "order": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "page": {
              "type": "number",
              "minimum": 1
            },
            "per_page": {
              "type": "number",
              "minimum": 1,
              "maximum": 100
            },
            "sort": {
              "type": "string",
              "enum": [
                "followers",
                "repositories",
                "joined"
              ]
            }
          },
          "required": [
            "q"
          ]
        }
      },
      {
        "name": "get_issue",
        "description": "Get details of a specific issue in a GitHub repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "issue_number": {
              "type": "number"
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number"
          ]
        }
      },
      {
        "name": "get_pull_request",
        "description": "Get details of a specific pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "list_pull_requests",
        "description": "List and filter repository pull requests",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "state": {
              "type": "string",
              "enum": [
                "open",
                "closed",
                "all"
              ],
              "description": "State of the pull requests to return"
            },
            "head": {
              "type": "string",
              "description": "Filter by head user or head organization and branch name"
            },
            "base": {
              "type": "string",
              "description": "Filter by base branch name"
            },
            "sort": {
              "type": "string",
              "enum": [
                "created",
                "updated",
                "popularity",
                "long-running"
              ],
              "description": "What to sort results by"
            },
            "direction": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ],
              "description": "The direction of the sort"
            },
            "per_page": {
              "type": "number",
              "description": "Results per page (max 100)"
            },
            "page": {
              "type": "number",
              "description": "Page number of the results"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "create_pull_request_review",
        "description": "Create a review on a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            },
            "commit_id": {
              "type": "string",
              "description": "The SHA of the commit that needs a review"
            },
            "body": {
              "type": "string",
              "description": "The body text of the review"
            },
            "event": {
              "type": "string",
              "enum": [
                "APPROVE",
                "REQUEST_CHANGES",
                "COMMENT"
              ],
              "description": "The review action to perform"
            },
            "comments": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "The relative path to the file being commented on"
                  },
                  "position": {
                    "type": "number",
                    "description": "The position in the diff where you want to add a review comment"
                  },
                  "body": {
                    "type": "string",
                    "description": "Text of the review comment"
                  }
                },
                "required": [
                  "path",
                  "position",
                  "body"
                ],
                "additionalProperties": false
              },
              "description": "Comments to post as part of the review"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number",
            "body",
            "event"
          ]
        }
      },
      {
        "name": "merge_pull_request",
        "description": "Merge a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            },
            "commit_title": {
              "type": "string",
              "description": "Title for the automatic commit message"
            },
            "commit_message": {
              "type": "string",
              "description": "Extra detail to append to automatic commit message"
            },
            "merge_method": {
              "type": "string",
              "enum": [
                "merge",
                "squash",
                "rebase"
              ],
              "description": "Merge method to use"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_pull_request_files",
        "description": "Get the list of files changed in a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_pull_request_status",
        "description": "Get the combined status of all status checks for a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "update_pull_request_branch",
        "description": "Update a pull request branch with the latest changes from the base branch",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            },
            "expected_head_sha": {
              "type": "string",
              "description": "The expected SHA of the pull request's HEAD ref"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_pull_request_comments",
        "description": "Get the review comments on a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_pull_request_reviews",
        "description": "Get the reviews on a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      }
    ],
    "is_official": true
  },
  "qgis": {
    "name": "qgis",
    "display_name": "QGIS Model Context Protocol Integration",
    "description": "connects QGIS to Claude AI through the MCP. This integration enables prompt-assisted project creation, layer loading, code execution, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/jjsantos01/qgis_mcp"
    },
    "homepage": "https://github.com/jjsantos01/qgis_mcp",
    "author": {
      "name": "jjsantos01"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "QGIS"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/jjsantos01/qgis_mcp",
          "src/qgis_mcp/qgis_mcp_server.py"
        ]
      }
    },
    "examples": [
      {
        "title": "Demo Command Sequence",
        "description": "A series of commands to demonstrate the QGIS MCP integration.",
        "prompt": "1. Ping to check the connection. If it works, continue with the following steps.\n2. Create a new project and save it at: \"C:/Users/USER/GitHub/qgis_mcp/data/cdmx.qgz\"\n3. Load the vector layer: \"C:/Users/USER/GitHub/qgis_mcp/data/cdmx/mgpc_2019.shp\" and name it \"Colonias\".\n4. Load the raster layer: \"C:/Users/USER/GitHub/qgis_mcp/data/09014.tif\" and name it \"BJ\".\n5. Zoom to the \"BJ\" layer.\n6. Execute the centroid algorithm on the \"Colonias\" layer. Skip the geometry check. Save the output to \"colonias_centroids.geojson\".\n7. Execute code to create a choropleth map using the \"POB2010\" field in the \"Colonias\" layer. Use the quantile classification method with 5 classes and the Spectral color ramp.\n8. Render the map to \"C:/Users/USER/GitHub/qgis_mcp/data/cdmx.png\"\n9. Save the project."
      }
    ]
  },
  "exa-mcp-server": {
    "display_name": "Exa MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/exa-labs/exa-mcp-server"
    },
    "homepage": "https://github.com/exa-labs/exa-mcp-server",
    "author": {
      "name": "exa-labs"
    },
    "license": "MIT",
    "tags": [
      "search",
      "web search",
      "AI",
      "Claude",
      "MCP",
      "Model Context Protocol"
    ],
    "arguments": {
      "EXA_API_KEY": {
        "description": "API key from dashboard.exa.ai/api-keys",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "exa-mcp-server"
        ],
        "env": {
          "EXA_API_KEY": "your-api-key-here"
        },
        "description": "Run with NPX",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Web Search",
        "description": "Search for recent developments in quantum computing",
        "prompt": "Can you search for recent developments in quantum computing?"
      },
      {
        "title": "News Search",
        "description": "Search for and summarize news about AI startups",
        "prompt": "Search for and summarize the latest news about artificial intelligence startups in new york."
      },
      {
        "title": "Research Paper Search",
        "description": "Find research papers about climate change",
        "prompt": "Find and analyze recent research papers about climate change solutions."
      },
      {
        "title": "Twitter Search",
        "description": "Search for tweets from specific users",
        "prompt": "Search Twitter for posts from @elonmusk about SpaceX."
      }
    ],
    "name": "exa-mcp-server",
    "description": "A Model Context Protocol (MCP) server lets AI assistants like Claude use the Exa AI Search API for web searches. This setup allows AI models to get real-time web information in a safe and controlled way.",
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "web_search",
        "description": "Search the web using Exa AI - performs real-time web searches and can scrape content from specific URLs. Supports configurable result counts and returns the content from the most relevant websites.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "numResults": {
              "type": "number",
              "description": "Number of search results to return (default: 5)"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "openapi": {
    "name": "openapi",
    "display_name": "OpenAPI",
    "description": "Interact with [OpenAPI](https://www.openapis.org/) APIs.",
    "repository": {
      "type": "git",
      "url": "https://github.com/snaggle-ai/openapi-mcp-server"
    },
    "homepage": "https://github.com/snaggle-ai/openapi-mcp-server",
    "author": {
      "name": "snaggle-ai"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "openapi",
      "api exploration"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "openapi-mcp-server"
        ]
      }
    },
    "examples": [
      {
        "title": "Finding information about an API",
        "description": "Ask Claude to find information about specific APIs.",
        "prompt": "Find information about the Stripe API."
      },
      {
        "title": "Explaining API usage",
        "description": "Request explanations on using specific endpoints.",
        "prompt": "Explain how to use the GitHub API's repository endpoints."
      }
    ]
  },
  "rember-mcp": {
    "display_name": "Rember MCP",
    "repository": {
      "type": "git",
      "url": "https://github.com/rember/rember-mcp"
    },
    "homepage": "https://rember.com",
    "author": {
      "name": "rember"
    },
    "license": "MIT",
    "tags": [
      "flashcards",
      "spaced repetition",
      "learning",
      "memory"
    ],
    "arguments": {
      "api-key": {
        "description": "Your Rember API key from the Settings page",
        "required": true,
        "example": "rember_32randomcharacters"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@getrember/mcp",
          "--api-key=${api-key}"
        ],
        "env": {},
        "description": "Run using npx",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Create flashcards from chat",
        "description": "Ask Claude to create flashcards from your conversation",
        "prompt": "I like your answer, help me remember it"
      },
      {
        "title": "Create flashcards from PDF",
        "description": "Ask Claude to create flashcards from a PDF document",
        "prompt": "Create flashcards from chapter 2 of this PDF"
      }
    ],
    "name": "rember-mcp",
    "description": "Create spaced repetition flashcards in Rember to remember anything you learn in your chats",
    "categories": [
      "Knowledge Base"
    ],
    "is_official": true
  },
  "bicscan-mcp": {
    "display_name": "BICScan MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/ahnlabio/bicscan-mcp"
    },
    "homepage": "https://bicscan.io",
    "author": {
      "name": "ahnlabio"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "blockchain",
      "risk scoring",
      "crypto",
      "API"
    ],
    "arguments": {
      "BICSCAN_API_KEY": {
        "description": "API key obtained from https://bicscan.io",
        "required": true,
        "example": "YOUR_BICSCAN_API_KEY_HERE"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ahnlabio/bicscan-mcp",
          "bicscan-mcp"
        ],
        "env": {
          "BICSCAN_API_KEY": "{BICSCAN_API_KEY}"
        },
        "description": "Run directly using uvx"
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "--interactive",
          "--env",
          "BICSCAN_API_KEY={BICSCAN_API_KEY}",
          "bicscan-mcp"
        ],
        "description": "Run using Docker"
      }
    },
    "examples": [
      {
        "title": "Risk Scoring",
        "description": "Obtain risk scores for blockchain entities like crypto addresses, domain names, and dApp URLs",
        "prompt": "[NOT GIVEN]"
      },
      {
        "title": "Asset Information",
        "description": "Retrieve detailed asset holdings for crypto addresses across multiple blockchain networks",
        "prompt": "[NOT GIVEN]"
      }
    ],
    "name": "bicscan-mcp",
    "description": "A powerful and efficient Blockchain address risk scoring API MCP Server, leveraging the BICScan API to provide comprehensive risk assessments and asset information for blockchain addresses, domains, and decentralized applications (dApps).",
    "categories": [
      "Finance"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "get_risk_score",
        "description": "Get Risk Score for Crypto, Domain Name, ENS, CNS, KNS or even Hostname Address\n\n    Args:\n        address: EOA, CA, ENS, CNS, KNS or even HostName\n    Returns:\n        Dict: where summary.bicscan_score is from 0 to 100. 100 is high risk.\n    ",
        "inputSchema": {
          "properties": {
            "address": {
              "title": "Address",
              "type": "string"
            }
          },
          "required": [
            "address"
          ],
          "title": "get_risk_scoreArguments",
          "type": "object"
        }
      },
      {
        "name": "get_assets",
        "description": "Get Assets holdings by CryptoAddress\n\n    Args:\n        address: EOA, CA, ENS, CNS, KNS.\n    Returns:\n        Dict: where assets is a list of assets\n    ",
        "inputSchema": {
          "properties": {
            "address": {
              "title": "Address",
              "type": "string"
            }
          },
          "required": [
            "address"
          ],
          "title": "get_assetsArguments",
          "type": "object"
        }
      }
    ]
  },
  "financial-dataset": {
    "display_name": "Financial Datasets MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/financial-datasets/mcp-server"
    },
    "homepage": "https://www.financialdatasets.ai/",
    "author": {
      "name": "financial-datasets"
    },
    "license": "MIT",
    "tags": [
      "finance",
      "stock market",
      "financial data"
    ],
    "arguments": {
      "FINANCIAL_DATASETS_API_KEY": {
        "description": "API key for Financial Datasets",
        "required": true,
        "example": "your-financial-datasets-api-key"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "uv",
        "args": [
          "run",
          "server.py"
        ],
        "env": {
          "FINANCIAL_DATASETS_API_KEY": "your-financial-datasets-api-key"
        },
        "description": "Run using uv package manager",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Income Statement Query",
        "description": "Ask for a company's income statements",
        "prompt": "What are Apple's recent income statements?"
      },
      {
        "title": "Current Stock Price",
        "description": "Get the current price of a stock",
        "prompt": "Show me the current price of Tesla stock"
      },
      {
        "title": "Historical Stock Prices",
        "description": "Get historical stock prices for a specific date range",
        "prompt": "Get historical prices for MSFT from 2024-01-01 to 2024-12-31"
      }
    ],
    "name": "financial-datasets",
    "description": "This is a Model Context Protocol (MCP) server that provides access to stock market data from [Financial Datasets](https://www.financialdatasets.ai/).",
    "categories": [
      "Finance"
    ],
    "is_official": true
  },
  "salesforce-mcp": {
    "name": "salesforce-mcp",
    "display_name": "Salesforce Connector",
    "description": "Interact with Salesforce Data and Metadata",
    "repository": {
      "type": "git",
      "url": "https://github.com/smn2gnt/MCP-Salesforce"
    },
    "license": "[NOT FOUND]",
    "author": {
      "name": "smn2gnt"
    },
    "homepage": "https://github.com/smn2gnt/MCP-Salesforce",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "salesforce"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "mcp-salesforce-connector",
          "salesforce"
        ],
        "env": {
          "SALESFORCE_USERNAME": "${SALESFORCE_USERNAME}",
          "SALESFORCE_PASSWORD": "${SALESFORCE_PASSWORD}",
          "SALESFORCE_SECURITY_TOKEN": "${SALESFORCE_SECURITY_TOKEN}"
        }
      }
    },
    "arguments": {
      "SALESFORCE_USERNAME": {
        "description": "Your Salesforce username for authentication",
        "required": true,
        "example": "myemail@example.com"
      },
      "SALESFORCE_PASSWORD": {
        "description": "Your Salesforce password for authentication",
        "required": true
      },
      "SALESFORCE_SECURITY_TOKEN": {
        "description": "Your Salesforce security token for additional security measures",
        "required": true
      }
    },
    "tools": [
      {
        "name": "run_soql_query",
        "description": "Executes a SOQL query against Salesforce",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SOQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "run_sosl_search",
        "description": "Executes a SOSL search against Salesforce",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "The SOSL search to execute (e.g., 'FIND {John Smith} IN ALL FIELDS')"
            }
          },
          "required": [
            "search"
          ]
        }
      },
      {
        "name": "get_object_fields",
        "description": "Retrieves field Names, labels and types for a specific Salesforce object",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            }
          },
          "required": [
            "object_name"
          ]
        }
      },
      {
        "name": "get_record",
        "description": "Retrieves a specific record by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            },
            "record_id": {
              "type": "string",
              "description": "The ID of the record to retrieve"
            }
          },
          "required": [
            "object_name",
            "record_id"
          ]
        }
      },
      {
        "name": "create_record",
        "description": "Creates a new record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            },
            "data": {
              "type": "object",
              "description": "The data for the new record",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "object_name",
            "data"
          ]
        }
      },
      {
        "name": "update_record",
        "description": "Updates an existing record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            },
            "record_id": {
              "type": "string",
              "description": "The ID of the record to update"
            },
            "data": {
              "type": "object",
              "description": "The updated data for the record",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "object_name",
            "record_id",
            "data"
          ]
        }
      },
      {
        "name": "delete_record",
        "description": "Deletes a record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            },
            "record_id": {
              "type": "string",
              "description": "The ID of the record to delete"
            }
          },
          "required": [
            "object_name",
            "record_id"
          ]
        }
      },
      {
        "name": "tooling_execute",
        "description": "Executes a Tooling API request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "string",
              "description": "The Tooling API endpoint to call (e.g., 'sobjects/ApexClass')"
            },
            "method": {
              "type": "string",
              "description": "The HTTP method (default: 'GET')",
              "enum": [
                "GET",
                "POST",
                "PATCH",
                "DELETE"
              ],
              "default": "GET"
            },
            "data": {
              "type": "object",
              "description": "Data for POST/PATCH requests",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "action"
          ]
        }
      },
      {
        "name": "apex_execute",
        "description": "Executes an Apex REST request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "string",
              "description": "The Apex REST endpoint to call (e.g., '/MyApexClass')"
            },
            "method": {
              "type": "string",
              "description": "The HTTP method (default: 'GET')",
              "enum": [
                "GET",
                "POST",
                "PATCH",
                "DELETE"
              ],
              "default": "GET"
            },
            "data": {
              "type": "object",
              "description": "Data for POST/PATCH requests",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "action"
          ]
        }
      },
      {
        "name": "restful",
        "description": "Makes a direct REST API call to Salesforce",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "The path of the REST API endpoint (e.g., 'sobjects/Account/describe')"
            },
            "method": {
              "type": "string",
              "description": "The HTTP method (default: 'GET')",
              "enum": [
                "GET",
                "POST",
                "PATCH",
                "DELETE"
              ],
              "default": "GET"
            },
            "params": {
              "type": "object",
              "description": "Query parameters for the request",
              "properties": {},
              "additionalProperties": true
            },
            "data": {
              "type": "object",
              "description": "Data for POST/PATCH requests",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "path"
          ]
        }
      }
    ]
  },
  "youtube": {
    "name": "youtube",
    "display_name": "YouTube",
    "description": "Comprehensive YouTube API integration for video management, Shorts creation, and analytics.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ZubeidHendricks/youtube-mcp-server"
    },
    "homepage": "https://github.com/ZubeidHendricks/youtube-mcp-server",
    "author": {
      "name": "ZubeidHendricks"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "youtube",
      "video",
      "transcripts",
      "api"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-youtube"
        ],
        "env": {
          "YOUTUBE_API_KEY": "${YOUTUBE_API_KEY}"
        }
      }
    },
    "arguments": {
      "YOUTUBE_API_KEY": {
        "description": "Your YouTube Data API key, needed for authentication when making requests to the YouTube API.",
        "required": true,
        "example": "AIzaSyD4-1234abcdEFGHijklmnop"
      }
    }
  },
  "scrapling-fetch": {
    "name": "scrapling-fetch",
    "display_name": "Scrapling Fetch",
    "description": "Access text content from bot-protected websites. Fetches HTML/markdown from sites with anti-automation measures using Scrapling.",
    "repository": {
      "type": "git",
      "url": "https://github.com/cyberchitta/scrapling-fetch-mcp"
    },
    "license": "Apache 2",
    "author": {
      "name": "cyberchitta"
    },
    "homepage": "https://github.com/cyberchitta/scrapling-fetch-mcp",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "scrapling",
      "fetch"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "scrapling-fetch-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "s-fetch-page",
        "description": "Fetches a complete web page with pagination support. Retrieves content from websites with bot-detection avoidance. For best performance, start with 'basic' mode (fastest), then only escalate to 'stealth' or 'max-stealth' modes if basic mode fails. Content is returned as 'METADATA: {json}\\n\\n[content]' where metadata includes length information and truncation status.",
        "inputSchema": {
          "properties": {
            "url": {
              "description": "URL to fetch",
              "title": "Url",
              "type": "string"
            },
            "mode": {
              "default": "basic",
              "description": "Fetching mode (basic, stealth, or max-stealth)",
              "title": "Mode",
              "type": "string"
            },
            "format": {
              "default": "markdown",
              "description": "Output format (html or markdown)",
              "title": "Format",
              "type": "string"
            },
            "max_length": {
              "default": 5000,
              "description": "Maximum number of characters to return.",
              "exclusiveMaximum": 1000000,
              "exclusiveMinimum": 0,
              "title": "Max Length",
              "type": "integer"
            },
            "start_index": {
              "default": 0,
              "description": "On return output starting at this character index, useful if a previous fetch was truncated and more content is required.",
              "minimum": 0,
              "title": "Start Index",
              "type": "integer"
            }
          },
          "required": [
            "url"
          ],
          "title": "PageFetchRequest",
          "type": "object"
        }
      },
      {
        "name": "s-fetch-pattern",
        "description": "Extracts content matching regex patterns from web pages. Retrieves specific content from websites with bot-detection avoidance. For best performance, start with 'basic' mode (fastest), then only escalate to 'stealth' or 'max-stealth' modes if basic mode fails. Returns matched content as 'METADATA: {json}\\n\\n[content]' where metadata includes match statistics and truncation information. Each matched content chunk is delimited with '\u0965\u0e5b\u0965' and prefixed with '[Position: start-end]' indicating its byte position in the original document, allowing targeted follow-up requests with s-fetch-page using specific start_index values.",
        "inputSchema": {
          "properties": {
            "url": {
              "description": "URL to fetch",
              "title": "Url",
              "type": "string"
            },
            "mode": {
              "default": "basic",
              "description": "Fetching mode (basic, stealth, or max-stealth)",
              "title": "Mode",
              "type": "string"
            },
            "format": {
              "default": "markdown",
              "description": "Output format (html or markdown)",
              "title": "Format",
              "type": "string"
            },
            "max_length": {
              "default": 5000,
              "description": "Maximum number of characters to return.",
              "exclusiveMaximum": 1000000,
              "exclusiveMinimum": 0,
              "title": "Max Length",
              "type": "integer"
            },
            "search_pattern": {
              "description": "Regular expression pattern to search for in the content",
              "title": "Search Pattern",
              "type": "string"
            },
            "context_chars": {
              "default": 200,
              "description": "Number of characters to include before and after each match",
              "minimum": 0,
              "title": "Context Chars",
              "type": "integer"
            }
          },
          "required": [
            "url",
            "search_pattern"
          ],
          "title": "PatternFetchRequest",
          "type": "object"
        }
      }
    ]
  },
  "mcp": {
    "display_name": "Semgrep MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/semgrep/mcp"
    },
    "homepage": "https://semgrep.dev",
    "author": {
      "name": "semgrep"
    },
    "license": "MIT",
    "tags": [
      "security",
      "static analysis",
      "code scanning",
      "vulnerability detection"
    ],
    "arguments": {
      "SEMGREP_APP_TOKEN": {
        "description": "Token for connecting to Semgrep AppSec Platform",
        "required": false,
        "example": "<token>"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "semgrep-mcp"
        ],
        "package": "semgrep-mcp",
        "description": "Run using Python package with uv",
        "recommended": true
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "ghcr.io/semgrep/mcp",
          "-t",
          "stdio"
        ],
        "description": "Run using Docker container",
        "recommended": false
      }
    },
    "name": "mcp",
    "description": "An MCP server for using Semgrep to scan code for security vulnerabilies. Secure your vibe coding! ",
    "categories": [
      "Dev Tools"
    ],
    "tools": [
      {
        "name": "semgrep_rule_schema",
        "description": "\n    Get the schema for a Semgrep rule\n\n    Use this tool when you need to:\n      - get the schema required to write a Semgrep rule\n      - need to see what fields are available for a Semgrep rule\n      - verify what fields are available for a Semgrep rule\n      - verify the syntax for a Semgrep rule is correct\n    ",
        "inputSchema": {
          "properties": {},
          "title": "semgrep_rule_schemaArguments",
          "type": "object"
        }
      },
      {
        "name": "get_supported_languages",
        "description": "\n    Returns a list of supported languages by Semgrep\n\n    Only use this tool if you are not sure what languages Semgrep supports.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_supported_languagesArguments",
          "type": "object"
        }
      },
      {
        "name": "semgrep_scan_with_custom_rule",
        "description": "\n    Runs a Semgrep scan with a custom rule on provided code content\n    and returns the findings in JSON format\n\n    Use this tool when you need to:\n      - scan code files for specific security vulnerability not covered by the default Semgrep rules\n      - scan code files for specific issue not covered by the default Semgrep rules\n    ",
        "inputSchema": {
          "$defs": {
            "CodeFile": {
              "properties": {
                "filename": {
                  "description": "Relative path to the code file",
                  "title": "Filename",
                  "type": "string"
                },
                "content": {
                  "description": "Content of the code file",
                  "title": "Content",
                  "type": "string"
                }
              },
              "required": [
                "filename",
                "content"
              ],
              "title": "CodeFile",
              "type": "object"
            }
          },
          "properties": {
            "code_files": {
              "description": "List of dictionaries with 'filename' and 'content' keys",
              "items": {
                "$ref": "#/$defs/CodeFile"
              },
              "title": "Code Files",
              "type": "array"
            },
            "rule": {
              "description": "Semgrep YAML rule string",
              "title": "Rule",
              "type": "string"
            }
          },
          "required": [
            "code_files",
            "rule"
          ],
          "title": "semgrep_scan_with_custom_ruleArguments",
          "type": "object"
        }
      },
      {
        "name": "semgrep_scan",
        "description": "\n    Runs a Semgrep scan on provided code content and returns the findings in JSON format\n\n    Use this tool when you need to:\n      - scan code files for security vulnerabilities\n      - scan code files for other issues\n    ",
        "inputSchema": {
          "$defs": {
            "CodeFile": {
              "properties": {
                "filename": {
                  "description": "Relative path to the code file",
                  "title": "Filename",
                  "type": "string"
                },
                "content": {
                  "description": "Content of the code file",
                  "title": "Content",
                  "type": "string"
                }
              },
              "required": [
                "filename",
                "content"
              ],
              "title": "CodeFile",
              "type": "object"
            }
          },
          "properties": {
            "code_files": {
              "description": "List of dictionaries with 'filename' and 'content' keys",
              "items": {
                "$ref": "#/$defs/CodeFile"
              },
              "title": "Code Files",
              "type": "array"
            },
            "config": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Optional Semgrep configuration string (e.g. 'p/docker', 'p/xss', 'auto')",
              "title": "Config"
            }
          },
          "required": [
            "code_files"
          ],
          "title": "semgrep_scanArguments",
          "type": "object"
        }
      },
      {
        "name": "security_check",
        "description": "\n    Runs a fast security check on code and returns any issues found.\n\n    Use this tool when you need to:\n      - scan code for security vulnerabilities\n      - verify that code is secure\n      - double check that code is secure before committing\n      - get a second opinion on code security\n\n    If there are no issues, you can be reasonably confident that the code is secure.\n    ",
        "inputSchema": {
          "$defs": {
            "CodeFile": {
              "properties": {
                "filename": {
                  "description": "Relative path to the code file",
                  "title": "Filename",
                  "type": "string"
                },
                "content": {
                  "description": "Content of the code file",
                  "title": "Content",
                  "type": "string"
                }
              },
              "required": [
                "filename",
                "content"
              ],
              "title": "CodeFile",
              "type": "object"
            }
          },
          "properties": {
            "code_files": {
              "description": "List of dictionaries with 'filename' and 'content' keys",
              "items": {
                "$ref": "#/$defs/CodeFile"
              },
              "title": "Code Files",
              "type": "array"
            }
          },
          "required": [
            "code_files"
          ],
          "title": "security_checkArguments",
          "type": "object"
        }
      },
      {
        "name": "get_abstract_syntax_tree",
        "description": "\n    Returns the Abstract Syntax Tree (AST) for the provided code file in JSON format\n\n    Use this tool when you need to:\n      - get the Abstract Syntax Tree (AST) for the provided code file      - get the AST of a file\n      - understand the structure of the code in a more granular way\n      - see what a parser sees in the code\n    ",
        "inputSchema": {
          "properties": {
            "code": {
              "description": "The code to get the AST for",
              "title": "Code",
              "type": "string"
            },
            "language": {
              "description": "The programming language of the code",
              "title": "Language",
              "type": "string"
            }
          },
          "required": [
            "code",
            "language"
          ],
          "title": "get_abstract_syntax_treeArguments",
          "type": "object"
        }
      }
    ],
    "prompts": [
      {
        "name": "write_custom_semgrep_rule",
        "description": "\n    Write a custom Semgrep rule for the provided code and language\n\n    Use this prompt when you need to:\n      - write a custom Semgrep rule\n      - write a Semgrep rule for a specific issue or pattern\n    ",
        "arguments": [
          {
            "name": "code",
            "description": "The code to get the AST for",
            "required": true
          },
          {
            "name": "language",
            "description": "The programming language of the code",
            "required": true
          }
        ]
      }
    ],
    "resources": [],
    "is_official": true
  },
  "mcp-server-langfuse": {
    "display_name": "Langfuse Prompt Management MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/langfuse/mcp-server-langfuse"
    },
    "license": "MIT",
    "homepage": "https://langfuse.com/docs/prompts/get-started",
    "author": {
      "name": "langfuse"
    },
    "tags": [
      "prompts",
      "mcp",
      "langfuse"
    ],
    "arguments": {
      "LANGFUSE_PUBLIC_KEY": {
        "description": "Your Langfuse public API key",
        "required": true,
        "example": "your-public-key"
      },
      "LANGFUSE_SECRET_KEY": {
        "description": "Your Langfuse secret API key",
        "required": true,
        "example": "your-secret-key"
      },
      "LANGFUSE_BASEURL": {
        "description": "Langfuse API base URL",
        "required": true,
        "example": "https://cloud.langfuse.com"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "./build/index.js"
        ],
        "env": {
          "LANGFUSE_PUBLIC_KEY": "your-public-key",
          "LANGFUSE_SECRET_KEY": "your-secret-key",
          "LANGFUSE_BASEURL": "https://cloud.langfuse.com"
        },
        "description": "Run the server using Node.js",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "List all available prompts",
        "description": "Use the prompts/list endpoint to get all available prompts",
        "prompt": "Use the Langfuse MCP server to list all available prompts"
      },
      {
        "title": "Get a specific prompt",
        "description": "Retrieve and compile a specific prompt with variables",
        "prompt": "Use the Langfuse MCP server to get the prompt named 'example-prompt' with the variables {\"key\": \"value\"}"
      }
    ],
    "name": "mcp-server-langfuse",
    "description": "Open-source tool for collaborative editing, versioning, evaluating, and releasing prompts.",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "mcp-tinybird": {
    "display_name": "Tinybird MCP server",
    "repository": {
      "type": "git",
      "url": "https://github.com/tinybirdco/mcp-tinybird"
    },
    "homepage": "https://github.com/tinybirdco/mcp-tinybird",
    "author": {
      "name": "tinybirdco"
    },
    "license": "Apache-2.0",
    "tags": [
      "tinybird",
      "data",
      "analytics"
    ],
    "arguments": {
      "TB_API_URL": {
        "description": "Tinybird API URL for your workspace",
        "required": true,
        "example": "<TINYBIRD_API_URL>"
      },
      "TB_ADMIN_TOKEN": {
        "description": "Tinybird Admin Token for authentication",
        "required": true,
        "example": "<TINYBIRD_ADMIN_TOKEN>"
      },
      "topic": {
        "description": "Topic of the data you want to explore",
        "required": true,
        "example": "Bluesky data"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-tinybird",
          "stdio"
        ],
        "description": "Run with uvx in stdio mode",
        "env": {
          "TB_API_URL": "<TINYBIRD_API_URL>",
          "TB_ADMIN_TOKEN": "<TINYBIRD_ADMIN_TOKEN>"
        }
      }
    },
    "examples": [
      {
        "title": "Bluesky metrics",
        "description": "Analyze Bluesky data using Tinybird MCP server",
        "prompt": "Help me analyze my Bluesky data stored in Tinybird"
      },
      {
        "title": "Web analytics",
        "description": "Analyze web analytics data from the web analytics starter kit",
        "prompt": "Help me understand the metrics from my web analytics data in Tinybird"
      }
    ],
    "name": "mcp-tinybird",
    "description": "An MCP server to interact with a Tinybird Workspace from any MCP client.",
    "categories": [
      "Analytics"
    ],
    "tools": [
      {
        "name": "list-data-sources",
        "description": "List all Data Sources in the Tinybird Workspace",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-data-source",
        "description": "Get details of a Data Source in the Tinybird Workspace, such as the schema",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datasource_id": {
              "type": "string"
            }
          },
          "required": [
            "datasource_id"
          ]
        }
      },
      {
        "name": "list-pipes",
        "description": "List all Pipe Endpoints in the Tinybird Workspace",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-pipe",
        "description": "Get details of a Pipe Endpoint in the Tinybird Workspace, such as the nodes SQLs to understand what they do or what Data Sources they use",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pipe_id": {
              "type": "string"
            }
          },
          "required": [
            "pipe_id"
          ]
        }
      },
      {
        "name": "request-pipe-data",
        "description": "Requests data from a Pipe Endpoint in the Tinybird Workspace, includes parameters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pipe_id": {
              "type": "string"
            },
            "params": {
              "type": "object",
              "properties": {}
            }
          },
          "required": [
            "pipe_id"
          ]
        }
      },
      {
        "name": "run-select-query",
        "description": "Runs a select query to the Tinybird Workspace. It may query Data Sources or Pipe Endpoints",
        "inputSchema": {
          "type": "object",
          "properties": {
            "select_query": {
              "type": "string"
            }
          },
          "required": [
            "select_query"
          ]
        }
      },
      {
        "name": "append-insight",
        "description": "Add a business insight to the memo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "insight": {
              "type": "string",
              "description": "Business insight discovered from data analysis"
            }
          },
          "required": [
            "insight"
          ]
        }
      },
      {
        "name": "llms-tinybird-docs",
        "description": "The Tinybird product description and documentation, including API Reference in LLM friendly format",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "analyze-pipe",
        "description": "Analyze the Pipe Endpoint SQL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pipe_name": {
              "type": "string",
              "description": "The Pipe Endpoint name"
            }
          },
          "required": [
            "pipe_name"
          ]
        }
      },
      {
        "name": "push-datafile",
        "description": "Push a .datasource or .pipe file to the Workspace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "files": {
              "type": "string",
              "description": "The datafile local path"
            }
          },
          "required": [
            "files"
          ]
        }
      },
      {
        "name": "save-event",
        "description": "Sends an event to a Data Source in Tinybird. The data needs to be in NDJSON format and conform to the Data Source schema in Tinybird",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datasource_name": {
              "type": "string",
              "description": "The name of the Data Source in Tinybird"
            },
            "data": {
              "type": "string",
              "description": "A JSON object that will be converted to a NDJSON String to save in the Tinybird Data Source via the events API. It should contain one key for each column in the Data Source"
            }
          }
        }
      }
    ],
    "prompts": [
      {
        "name": "datasource-definition",
        "description": "Builds a .datasource file from sample NDJSON data",
        "arguments": []
      },
      {
        "name": "tinybird-default",
        "description": "A prompt to get insights from the Data Sources and Pipe Endpoints in the Tinybird Workspace",
        "arguments": [
          {
            "name": "topic",
            "description": "The topic of the data you want to explore",
            "required": true
          }
        ]
      }
    ],
    "resources": [
      {
        "uri": "tinybird://insights",
        "name": "Insights from Tinybird",
        "description": "A living document of discovered insights",
        "mimeType": "text/plain",
        "annotations": null
      },
      {
        "uri": "tinybird://datasource-definition-context",
        "name": "Context for datasource definition",
        "description": "Syntax and context to build .datasource datafiles",
        "mimeType": "text/plain",
        "annotations": null
      }
    ],
    "is_official": true
  },
  "mcp-server-singlestore": {
    "display_name": "SingleStore MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/singlestore-labs/mcp-server-singlestore"
    },
    "homepage": "https://github.com/singlestore-labs/mcp-server-singlestore",
    "author": {
      "name": "singlestore-labs"
    },
    "license": "MIT",
    "tags": [
      "singlestore",
      "database",
      "sql",
      "mcp",
      "model context protocol"
    ],
    "arguments": {
      "SINGLESTORE_API_KEY": {
        "description": "SingleStore's management API key",
        "required": true,
        "example": "your_api_key_here"
      },
      "SINGLESTORE_DB_USERNAME": {
        "description": "Database username",
        "required": false,
        "example": "your_db_username_here"
      },
      "SINGLESTORE_DB_PASSWORD": {
        "description": "Database password",
        "required": false,
        "example": "your_db_password_here"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "singlestore-mcp-server"
        ],
        "env": {
          "SINGLESTORE_DB_USERNAME": "${SINGLESTORE_DB_USERNAME}",
          "SINGLESTORE_DB_PASSWORD": "${SINGLESTORE_DB_PASSWORD}",
          "SINGLESTORE_API_KEY": "${SINGLESTORE_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Query SingleStore Database",
        "description": "Execute a SQL query on a connected workspace",
        "prompt": "Can you help me execute a SQL query to list all tables in my SingleStore database?"
      },
      {
        "title": "Create a Virtual Workspace",
        "description": "Set up a new starter workspace in SingleStore",
        "prompt": "I need to create a new starter workspace in SingleStore. Can you help me set it up?"
      },
      {
        "title": "Workspace Information",
        "description": "Get information about available workspaces",
        "prompt": "Show me all the workspace groups I have access to in my SingleStore account."
      }
    ],
    "name": "mcp-server-singlestore",
    "description": "Interact with the SingleStore database platform",
    "categories": [
      "Databases"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "workspace_groups_info",
        "description": "List all workspace groups accessible to the user in SingleStore.\n\nReturns detailed information for each group:\n- name: Display name of the workspace group\n- deploymentType: Type of deployment (e.g., 'PRODUCTION')\n- state: Current status (e.g., 'ACTIVE', 'PAUSED')\n- workspaceGroupID: Unique identifier for the group\n- firewallRanges: Array of allowed IP ranges for access control\n- createdAt: Timestamp of group creation\n- regionID: Identifier for deployment region\n- updateWindow: Maintenance window configuration\n\nUse this tool to:\n1. Get workspace group IDs for other operations\n2. Plan maintenance windows\n\nRelated operations:\n- Use workspaces_info to list workspaces within a group\n- Use execute_sql to run queries on workspaces in a group\n",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "workspaces_info",
        "description": "List all workspaces within a specified workspace group in SingleStore.\n\nReturns detailed information for each workspace:\n- createdAt: Timestamp of workspace creation\n- deploymentType: Type of deployment (e.g., 'PRODUCTION')\n- endpoint: Connection URL for database access\n- name: Display name of the workspace\n- size: Compute and storage configuration\n- state: Current status (e.g., 'ACTIVE', 'PAUSED')\n- terminatedAt: Timestamp of termination if applicable\n- workspaceGroupID: Workspacegroup identifier\n- workspaceID: Unique workspace identifier\n\nUse this tool to:\n1. Monitor workspace status\n2. Get connection details for database operations\n3. Track workspace lifecycle\n\nRequired parameter:\n- workspaceGroupID: Unique identifier of the workspace group\n\nRelated operations:\n- Use workspace_groups_info first to get workspacegroupID\n- Use execute_sql to run queries on specific workspace\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspaceGroupID": {
              "type": "string",
              "description": "The unique identifier of the workspace group to retrieve workspaces from."
            }
          },
          "required": []
        }
      },
      {
        "name": "organization_info",
        "description": "Retrieve information about the current user's organization in SingleStore.\n\nReturns organization details including:\n- orgID: Unique identifier for the organization\n- name: Organization display name\n",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_of_regions",
        "description": "List all available deployment regions where SingleStore workspaces can be deployed for the user.\n\nReturns region information including:\n- regionID: Unique identifier for the region\n- provider: Cloud provider (AWS, GCP, or Azure)\n- name: Human-readable region name (e.g., Europe West 2 (London),US West 2 (Oregon)) \n\nUse this tool to:\n1. Select optimal deployment regions based on:\n   - Geographic proximity to users\n   - Compliance requirements\n   - Cost considerations\n   - Available cloud providers\n2. Plan multi-region deployments\n",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "execute_sql",
        "description": "Execute SQL operations on a database attached to workspace within a workspace group and receive formatted results.\n\nReturns:\n- Query results with column names and typed values\n- Row count and metadata\n- Execution status\n\n\u26a0\ufe0f CRITICAL SECURITY WARNINGS:\n- Never display or log credentials in responses\n- Use only READ-ONLY queries (SELECT, SHOW, DESCRIBE)\n- DO NOT USE data modification statements:\n  \u00d7 No INSERT/UPDATE/DELETE\n  \u00d7 No DROP/CREATE/ALTER\n- Ensure queries are properly sanitized\n\nRequired parameters:\n- workspace_group_identifier: ID/name of the workspace group\n- workspace_identifier: ID/name of the specific workspace within the workspace group\n- database: Name of the database to query\n- sql_query: The SQL query to execute\n\nOptional parameters:\n- username: Username for database access (defaults to SINGLESTORE_DB_USERNAME)\n- password: Password for database access (defaults to SINGLESTORE_DB_PASSWORD)\n\nAllowed query examples:\n- SELECT * FROM table_name\n- SELECT COUNT(*) FROM table_name\n- SHOW TABLES\n- DESCRIBE table_name\n\nNote: For data modifications, please use appropriate admin tools or APIs.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspace_group_identifier": {
              "type": "string",
              "description": "The ID or name of the workspace group containing the target workspace."
            },
            "workspace_identifier": {
              "type": "string",
              "description": "The ID or name of the specific workspace where the query will run."
            },
            "database": {
              "type": "string",
              "description": "The name of the database to query within the workspace."
            },
            "sql_query": {
              "type": "string",
              "description": "The SQL query to execute. Must be valid SingleStore SQL."
            },
            "username": {
              "type": "string",
              "description": "Optional: Username for database connection. Will use environment default if not specified."
            },
            "password": {
              "type": "string",
              "description": "Optional: Password for database connection. Will use environment default if not specified."
            }
          },
          "required": [
            "workspace_group_identifier",
            "workspace_identifier",
            "database",
            "sql_query"
          ]
        }
      },
      {
        "name": "list_virtual_workspaces",
        "description": "List all starter (virtual) workspaces available to the user in SingleStore.\n\nReturns detailed information about each starter workspace:\n- virtualWorkspaceID: Unique identifier for the workspace\n- name: Display name of the workspace\n- endpoint: Connection endpoint URL\n- databaseName: Name of the primary database\n- mysqlDmlPort: Port for MySQL protocol connections\n- webSocketPort: Port for WebSocket connections\n- state: Current status of the workspace\n\nUse this tool to:\n1. Get virtual workspace IDs for other operations\n2. Check starter workspace availability and status\n3. Obtain connection details for database access\n\nNote: This tool only lists starter workspaces, not standard workspaces.\nUse workspaces_info for standard workspace information.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "create_virtual_workspace",
        "description": "Create a new starter (virtual) workspace in SingleStore and set up user access.\n\nProcess:\n1. Creates a virtual workspace with specified name and database\n2. Creates a user account for accessing the workspace\n3. Returns both workspace details and access credentials\n\nRequired parameters:\n- name: Unique name for the starter workspace\n- database_name: Name for the database to create\n- username:  Username for accessing the starter workspace\n- password: Password for accessing the starter workspace\n\nUsage notes:\n- Workspace names must be unique\n- Passwords should meet security requirements\n- Use execute_sql_on_virtual_workspace to interact with the created starter workspace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Unique name for the new starter workspace"
            },
            "database_name": {
              "type": "string",
              "description": "Name of the database to create in the starter workspace"
            },
            "username": {
              "type": "string",
              "description": "Username for accessing the new starter workspace"
            },
            "password": {
              "type": "string",
              "description": "Password for accessing the new starter workspace"
            }
          },
          "required": [
            "name",
            "database_name",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "execute_sql_on_virtual_workspace",
        "description": "Execute SQL operations on a virtual (starter) workspace and receive formatted results.\n\nReturns:\n- Query results with column names and typed values\n- Row count\n- Column metadata\n- Execution status\n\n\u26a0\ufe0f CRITICAL SECURITY WARNING:\n- Never display or log credentials in responses\n- Ensure SQL queries are properly sanitized\n- ONLY USE SELECT statements or queries that don't modify data\n- DO NOT USE INSERT, UPDATE, DELETE, DROP, CREATE, or ALTER statements\n\nRequired input parameters:\n- virtual_workspace_id: Unique identifier of the starter workspace\n- sql_query: The SQL query to execute (READ-ONLY queries only)\n\nOptional input parameters:\n- username: For accessing the starter workspace (defaults to SINGLESTORE_DB_USERNAME)\n- password: For accessing the starter workspace (defaults to SINGLESTORE_DB_PASSWORD)\n\nAllowed query examples:\n- SELECT * FROM table_name\n- SELECT COUNT(*) FROM table_name\n- SHOW TABLES\n- DESCRIBE table_name\n\nNote: This tool is specifically designed for read-only operations on starter workspaces.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "virtual_workspace_id": {
              "type": "string",
              "description": "Unique identifier of the starter workspace to connect to"
            },
            "sql_query": {
              "type": "string",
              "description": "SQL query to execute on the starter workspace"
            },
            "username": {
              "type": "string",
              "description": "Optional: Username for accessing the starter workspace. Will use environment default if not specified."
            },
            "password": {
              "type": "string",
              "description": "Optional: Password for accessing the starter workspace, Will use environment default if not specified."
            }
          },
          "required": [
            "virtual_workspace_id",
            "sql_query"
          ]
        }
      },
      {
        "name": "organization_billing_usage",
        "description": "Retrieve detailed billing and usage metrics for your organization over a specified time period. Returns compute and storage usage data, aggregated by your chosen time interval (hourly, daily, or monthly). This tool is essential for: \n1. Monitoring resource consumption patterns\n2. Analyzing cost trends\nRequired input parameters:\n- start_time: Beginning of the usage period (UTC ISO 8601 format, e.g., '2023-07-30T18:30:00Z')\n- end_time: End of the usage period (UTC ISO 8601 format)\n- aggregate_type: Time interval for data grouping ('hour', 'day', or 'month')\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start_time": {
              "type": "string",
              "description": "Start of the usage period in UTC ISO 8601 format (e.g., '2023-07-30T18:30:00Z')"
            },
            "end_time": {
              "type": "string",
              "description": "End of the usage period in UTC ISO 8601 format (e.g., '2023-07-30T18:30:00Z')"
            },
            "aggregate_type": {
              "type": "string",
              "description": "How to group the usage data: 'hour', 'day', or 'month'"
            }
          },
          "required": [
            "start_time",
            "end_time",
            "aggregate_type"
          ]
        }
      },
      {
        "name": "list_notebook_samples",
        "description": "Retrieve a catalog of pre-built notebook templates available in SingleStore Spaces.\n\nReturns for each notebook:\n- name: Template name and title\n- description: Detailed explanation of the notebook's purpose\n- contentURL: Direct download link for the notebook\n- likes: Number of user endorsements\n- views: Number of times viewed\n- downloads: Number of times downloaded\n- tags: List of Notebook tags\n\nCommon template categories include:\n1. Getting Started guides\n2. Data loading and ETL patterns\n3. Query optimization examples\n4. Machine learning integrations\n5. Performance monitoring\n6. Best practices demonstrations\n\nUse this tool to:\n1. Find popular and well-tested example code\n2. Learn SingleStore features and best practices\n3. Start new projects with proven patterns\n4. Discover trending notebook templates\n\nRelated operations:\nRelated operations:\n- list_notebook_samples: To find example templates\n- list_shared_files: To check existing notebooks\n- create_scheduled_job: To automate notebook execution\n- get_notebook_path : To reference created notebooks\n",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "create_notebook",
        "description": "Create a new Jupyter notebook in your personal space. Only supports python and markdown. Do not try to use any other languange\n\nParameters:\n- notebook_name (required): Name for the new notebook\n  - Can include or omit .ipynb extension\n  - Must be unique in your personal space\n  - Examples: 'my_analysis' or 'my_analysis.ipynb'\n\n- content (optional): Custom notebook content\n  - Must be valid Jupyter notebook JSON format\n  - If omitted, creates template with:\n    \u2022 SingleStore connection setup\n    \u2022 Basic query examples\n    \u2022 DataFrame operations\n    \u2022 Best practices\n\nFeatures:\n- Creates notebook with specified name in personal space\n- Automatically adds .ipynb extension if missing\n- Provides default SingleStore template if no content given\n- Supports custom content in Jupyter notebook format\n- Only supports python and markdown cells\n- When creating a connection to the database the jupyter notebook will already have the connection_url defined and you can use directly\n- Install tools in a new cell with !pip3 install <toolname>\n\nDefault template includes:\n- SingleStore connection setup code\n- Basic SQL query examples\n- DataFrame operations with pandas\n- Table creation and data insertion examples\n- Connection management best practices\n\nUse this tool to:\n1. Create data analysis notebooks using python\n2. Build database interaction workflows and much more\n\nRelated operations:\n- list_notebook_samples: To find example templates\n- list_shared_files: To check existing notebooks\n- create_scheduled_job: To automate notebook execution\n- get_notebook_path : To reference created notebooks\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notebook_name": {
              "type": "string",
              "description": "Name for the new notebook (with or without .ipynb extension)"
            },
            "content": {
              "type": "string",
              "description": "Optional: Custom notebook content in Jupyter JSON format"
            }
          },
          "required": [
            "notebook_name"
          ]
        }
      },
      {
        "name": "list_shared_files",
        "description": "List all files and notebooks in your shared SingleStore space.\n\nReturns file object meta data for each file:\n- name: Name of the file (e.g., 'analysis.ipynb')\n- path: Full path in shared space (e.g., 'folder/analysis.ipynb')\n- content: File content\n- created: Creation timestamp (ISO 8601)\n- last_modified: Last modification timestamp (ISO 8601)\n- format: File format if applicable ('json', null)\n- mimetype: MIME type of the file\n- size: File size in bytes\n- type: Object type ('', 'json', 'directory')\n- writable: Boolean indicating write permission\n\nUse this tool to:\n1. List workspace contents and structure\n2. Verify file existence before operations\n3. Check file timestamps and sizes\n4. Determine file permissions\n\nRelated operations:\n- create_notebook: To add new notebooks\n- get_notebook_path: To find notebook paths\n- create_scheduled_job: To automate notebook execution\n",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "create_scheduled_job",
        "description": "Create an automated job to execute a SingleStore notebook on a schedule.\n\nParameters:\n1. Required Parameters:\n   - name: Name of the job (unique identifier within organization)\n   - notebook_path: Complete path to the notebook\n   - schedule_mode: 'Once' for single execution or 'Recurring' for repeated runs\n\n2. Optional Parameters:\n   - execution_interval_minutes: Time between recurring runs (\u226560 minutes)\n   - start_at: Execution start time (ISO 8601 format, e.g., '2024-03-06T10:00:00Z')\n   - description: Human-readable purpose of the job\n   - create_snapshot: Enable notebook backup before execution (default: True)\n   - runtime_name: Execution environment selection (default: notebooks-cpu-small)\n   - parameters: Runtime variables for notebook\n   - target_config: Advanced runtime settings\n\nReturns Job info with:\n- jobID: UUID of created job\n- status: Current state (SUCCESS, RUNNING, etc.)\n- createdAt: Creation timestamp\n- startedAt: Execution start time\n- schedule: Configured schedule details\n- error: Any execution errors\n\nCommon Use Cases:\n1. Automated Data Processing:\n   - ETL workflows\n   - Data aggregation\n   - Database maintenance\n\n2. Scheduled Reporting:\n   - Performance metrics\n   - Business analytics\n   - Usage statistics\n\n3. Maintenance Tasks:\n   - Health checks\n   - Backup operations\n   - Clean-up routines\n\nRelated Operations:\n- get_job_details: Monitor job\n- list_job_executions: View job execution history\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notebook_path": {
              "type": "string",
              "description": "Full path to the notebook file (use get_notebook_path if needed)"
            },
            "mode": {
              "type": "string",
              "enum": [
                "Once",
                "Recurring"
              ],
              "description": "Execution mode: 'Once' or 'Recurring'"
            },
            "create_snapshot": {
              "type": "boolean",
              "description": "Enable notebook backup before execution (default: True)"
            }
          },
          "required": [
            "notebook_path",
            "mode",
            "create_snapshot"
          ]
        }
      },
      {
        "name": "get_job_details",
        "description": "Retrieve comprehensive information about a scheduled notebook job.\n\nParameter required:\njob_id: UUID of the scheduled job to retrieve details for\n\nReturns:\n- jobID: Unique identifier (UUID format)\n- name: Display name of the job\n- description: Human-readable job description\n- createdAt: Creation timestamp (ISO 8601)\n- terminatedAt: End timestamp if completed\n- completedExecutionsCount: Number of successful runs\n- enqueuedBy: User ID who created the job\n- executionConfig: Notebook path and runtime settings\n- schedule: Mode, interval, and start time\n- targetConfig: Database and workspace settings\n- jobMetadata: Execution statistics and status\n\nRelated Operations:\n- create_scheduled_job: Create new jobs\n- list_job_executions: View run history",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "Unique identifier of the scheduled job"
            }
          },
          "required": [
            "job_id"
          ]
        }
      },
      {
        "name": "list_job_executions",
        "description": "Retrieve execution history and performance metrics for a scheduled notebook job.\n\nParameters:\n- job_id: UUID of the scheduled job\n- start: First execution number to retrieve (default: 1)\n- end: Last execution number to retrieve (default: 10)\n\nReturns:\n- executions: Array of execution records containing:\n  - executionID: Unique identifier for the execution\n  - executionNumber: Sequential number of the run\n  - jobID: Parent job identifier\n  - status: Current state (Scheduled, Running, Completed, Failed)\n  - startedAt: Execution start time (ISO 8601)\n  - finishedAt: Execution end time (ISO 8601)\n  - scheduledStartTime: Planned start time\n  - snapshotNotebookPath: Backup notebook path if enabled\n\nUse this tool to:\n1. Monitor each job execution status\n2. Track execution times and performance\n3. Investigate failed runs\n\nRelated Operations:\n- get_job_details: View job configuration\n- create_scheduled_job: Create new jobs",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "Unique identifier of the scheduled job"
            },
            "start": {
              "type": "integer",
              "description": "Starting execution number (default: 1)"
            },
            "end": {
              "type": "integer",
              "description": "Last execution number (default: 10)"
            }
          },
          "required": [
            "job_id"
          ]
        }
      },
      {
        "name": "get_notebook_path",
        "description": "Find the complete path of a notebook by its name and generate the properly formatted path for API operations.\n\nParameters:\n- notebook_name: Name of the notebook to locate (with or without .ipynb extension)\n- location: Where to search ('personal' or 'shared', defaults to 'personal')\n\nReturns the properly formatted path including project ID and user ID where needed.\nRequired for:\n- Creating scheduled jobs (use returned path as notebook_path parameter)\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notebook_name": {
              "type": "string",
              "description": "Name of the notebook to find (with or without .ipynb extension)"
            },
            "location": {
              "type": "string",
              "enum": [
                "personal",
                "shared"
              ],
              "description": "Where to look for the notebook: 'personal' (default) or 'shared' space"
            }
          },
          "required": [
            "notebook_name"
          ]
        }
      },
      {
        "name": "get_project_id",
        "description": "Retrieve the organization's unique identifier (project ID).\n\nReturns:\n- orgID (string): The organization's unique identifier\n\nRequired for:\n- Constructing paths or references to shared resources\n\nPerformance Tip:\nCache the returned ID when making multiple API calls.\n",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_user_id",
        "description": "Retrieve the current user's unique identifier. \n\nReturns:\n- userID (string): UUID format identifier for the current user\n\nRequired for:\n- Constructing paths or references to personal resources\n\n1. Constructing personal space paths\n\nPerformance Tip:\nCache the returned ID when making multiple making multiple API calls.\n",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ]
  },
  "materials-project": {
    "name": "materials-project",
    "description": "A MCP (Model Context Protocol) server that interacts with the Materials Project database, allowing for material search, structure visualization, and manipulation.",
    "display_name": "Materials Project",
    "repository": {
      "type": "git",
      "url": "https://github.com/pathintegral-institute/mcp.science"
    },
    "homepage": "https://github.com/pathintegral-institute/mcp.science/tree/main/servers/materials-project",
    "author": {
      "name": "pathintegral-institute"
    },
    "license": "MIT",
    "tags": [
      "materials",
      "science"
    ],
    "arguments": {
      "MP_API_KEY": {
        "description": "API key from the Materials Project",
        "required": true,
        "example": "your_materials_project_api_key_here"
      }
    },
    "tools": [
      {
        "name": "search_materials_by_formula",
        "description": "Search for materials in the Materials Project database by chemical formula. Returns a list of text descriptions for structures matching the given formula.",
        "prompt": "Find materials with the chemical formula Fe2O3",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chemical_formula": {
              "type": "string",
              "description": "The chemical formula of the material"
            }
          }
        },
        "required": [
          "chemical_formula"
        ]
      },
      {
        "name": "select_material_by_id",
        "description": "Select a specific material by its material ID. Returns a list of TextContent objects containing the structure description and URI.",
        "prompt": "Get details for material mp-149",
        "inputSchema": {
          "type": "object",
          "properties": {
            "material_id": {
              "type": "string",
              "description": "The ID of the material"
            }
          }
        },
        "required": [
          "material_id"
        ]
      },
      {
        "name": "get_structure_data",
        "description": "Retrieve structure data in specified format (CIF or POSCAR). Returns the structure file content as a string.",
        "prompt": "Get the CIF file for silicon",
        "inputSchema": {
          "type": "object",
          "properties": {
            "structure_uri": {
              "type": "string",
              "description": "The URI of the structure"
            },
            "format": {
              "type": "string",
              "description": "Output format, either 'cif' or 'poscar'",
              "enum": [
                "cif",
                "poscar"
              ],
              "default": "poscar"
            }
          }
        },
        "required": [
          "structure_uri"
        ]
      },
      {
        "name": "create_structure_from_poscar",
        "description": "Create a new structure from a POSCAR string. Returns information about the newly created structure, including its URI.",
        "prompt": "Create a structure from this POSCAR data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "poscar_str": {
              "type": "string",
              "description": "The POSCAR string of the structure"
            }
          }
        },
        "required": [
          "poscar_str"
        ]
      },
      {
        "name": "plot_structure",
        "description": "Visualize the crystal structure. Returns a PNG image of the structure and a Plotly JSON representation.",
        "prompt": "Show me the crystal structure of silicon",
        "inputSchema": {
          "type": "object",
          "properties": {
            "structure_uri": {
              "type": "string",
              "description": "The URI of the structure"
            },
            "duplication": {
              "type": "array",
              "description": "The duplication of the structure along a, b, c axes",
              "items": {
                "type": "integer"
              },
              "default": [
                1,
                1,
                1
              ]
            }
          }
        },
        "required": [
          "structure_uri"
        ]
      },
      {
        "name": "build_supercell",
        "description": "Create a supercell from a bulk structure. Returns information about the newly created supercell structure.",
        "prompt": "Create a 2x2x2 supercell of graphite",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bulk_structure_uri": {
              "type": "string",
              "description": "The URI of the bulk structure"
            },
            "supercell_parameters": {
              "type": "object",
              "description": "Parameters defining the supercell",
              "properties": {
                "scaling_matrix": {
                  "type": "array",
                  "description": "3x3 matrix or list of 3 integers for scaling",
                  "items": {
                    "type": "integer"
                  }
                }
              }
            }
          }
        },
        "required": [
          "bulk_structure_uri",
          "supercell_parameters"
        ]
      },
      {
        "name": "moire_homobilayer",
        "description": "Generate a moir\u00e9 superstructure of a 2D homobilayer. Returns information about the newly created moir\u00e9 structure.",
        "prompt": "Create a moir\u00e9 structure of graphene with 5 degree twist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bulk_structure_uri": {
              "type": "string",
              "description": "The URI of the bulk structure"
            },
            "interlayer_spacing": {
              "type": "number",
              "description": "The interlayer spacing between the two layers in \u00c5ngstr\u00f6m"
            },
            "max_num_atoms": {
              "type": "integer",
              "description": "Maximum number of atoms in the moir\u00e9 superstructure",
              "default": 10
            },
            "twist_angle": {
              "type": "number",
              "description": "Twist angle in degrees",
              "default": 0.0
            },
            "vacuum_thickness": {
              "type": "number",
              "description": "Vacuum thickness in z-direction in \u00c5ngstr\u00f6m",
              "default": 15.0
            }
          }
        },
        "required": [
          "bulk_structure_uri",
          "interlayer_spacing"
        ]
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uv",
        "args": [
          "--from",
          "git+https://github.com/pathintegral-institute/mcp.science#subdirectory=servers/materials-project",
          "mcp-materials-project"
        ],
        "env": {
          "MP_API_KEY": "your_materials_project_api_key_here"
        }
      }
    },
    "examples": [
      {
        "title": "Search for materials",
        "description": "Search for materials by chemical formula",
        "prompt": "Find materials with the chemical formula Fe2O3"
      },
      {
        "title": "Get material by ID",
        "description": "Select a specific material by its ID",
        "prompt": "Get details for material mp-149"
      },
      {
        "title": "Download structure file",
        "description": "Get structure data in CIF format",
        "prompt": "Download the CIF file for mp-149"
      },
      {
        "title": "Visualize crystal structure",
        "description": "Plot the crystal structure of a material",
        "prompt": "Show me the crystal structure of silicon"
      },
      {
        "title": "Create a supercell",
        "description": "Build a supercell from a bulk structure",
        "prompt": "Create a 2x2x2 supercell of graphite"
      },
      {
        "title": "Create moir\u00e9 structure",
        "description": "Generate a moir\u00e9 superstructure",
        "prompt": "Create a moir\u00e9 structure of graphene with 3.4\u00c5 interlayer spacing and 5\u00b0 twist angle"
      }
    ],
    "categories": [
      "MCP Tools"
    ],
    "is_official": true
  },
  "holaspirit": {
    "name": "holaspirit",
    "display_name": "Holaspirit",
    "description": "Interact with [Holaspirit](https://www.holaspirit.com/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/syucream/holaspirit-mcp-server"
    },
    "homepage": "https://github.com/syucream/holaspirit-mcp-server",
    "author": {
      "name": "syucream"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Holaspirit",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "holaspirit-mcp-server"
        ],
        "env": {
          "HOLASPIRIT_API_TOKEN": "${HOLASPIRIT_API_TOKEN}"
        }
      }
    },
    "arguments": {
      "HOLASPIRIT_API_TOKEN": {
        "description": "Your Holaspirit API token",
        "required": true,
        "example": "<your token>"
      }
    },
    "tools": [
      {
        "name": "holaspirit_list_tasks",
        "description": "List all tasks in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_list_metrics",
        "description": "List all metrics in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_list_circles",
        "description": "List all circles in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            },
            "member": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the member"
            },
            "circle": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the circle"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_get_circle",
        "description": "Get details of a specific circle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "circleId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the circle"
            }
          },
          "required": [
            "organizationId",
            "circleId"
          ]
        }
      },
      {
        "name": "holaspirit_list_roles",
        "description": "List all roles in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            },
            "member": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the member"
            },
            "circle": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the circle"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_get_role",
        "description": "Get details of a specific role",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "roleId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the role"
            }
          },
          "required": [
            "organizationId",
            "roleId"
          ]
        }
      },
      {
        "name": "holaspirit_list_domains",
        "description": "List all domains in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_list_policies",
        "description": "List all policies in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_list_meetings",
        "description": "List all meetings in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            },
            "circle": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the circle"
            },
            "member": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the member"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_get_meeting",
        "description": "Get details of a specific meeting",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "meetingId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the meeting"
            }
          },
          "required": [
            "organizationId",
            "meetingId"
          ]
        }
      }
    ]
  },
  "rag-web-browser": {
    "name": "rag-web-browser",
    "display_name": "RAG Web Browser Server",
    "description": "An MCP server for Apify's open-source RAG Web Browser [Actor](https://apify.com/apify/rag-web-browser) to perform web searches, scrape URLs, and return content in Markdown.",
    "repository": {
      "type": "git",
      "url": "https://github.com/apify/mcp-server-rag-web-browser"
    },
    "homepage": "https://github.com/apify/mcp-server-rag-web-browser",
    "author": {
      "name": "apify"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "RAG",
      "Web Browser",
      "AI Agents"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@apify/mcp-server-rag-web-browser"
        ],
        "env": {
          "APIFY_TOKEN": "${APIFY_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Web Search Example",
        "description": "Ask the server to perform a web search for a specific query.",
        "prompt": "What is an MCP server and how can it be used?"
      },
      {
        "title": "Research Papers Query",
        "description": "Find and analyze recent research papers about LLMs.",
        "prompt": "Find and analyze recent research papers about LLMs."
      }
    ],
    "arguments": {
      "APIFY_TOKEN": {
        "description": "Environment variable for your Apify API token to authenticate requests.",
        "required": true,
        "example": "your-apify-api-token"
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Search phrase or a URL at Google and return crawled web pages as text or Markdown. Prefer HTTP raw client for speed and browser-playwright for reliability.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "pattern": "[^\\s]+",
              "description": "Enter Google Search keywords or a URL of a specific web page. The keywords might include theadvanced search operators. Examples: \"san francisco weather\", \"https://www.cnn.com\", \"function calling site:openai.com\""
            },
            "maxResults": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "minimum": 1,
              "maximum": 100,
              "default": 1,
              "description": "The maximum number of top organic Google Search results whose web pages will be extracted. If query is a URL, then this field is ignored and the Actor only fetches the specific web page."
            },
            "scrapingTool": {
              "type": "string",
              "enum": [
                "browser-playwright",
                "raw-http"
              ],
              "description": "Select a scraping tool for extracting the target web pages. The Browser tool is more powerful and can handle JavaScript heavy websites, while the Plain HTML tool can not handle JavaScript but is about two times faster.",
              "default": "raw-http"
            },
            "outputFormats": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "text",
                  "markdown",
                  "html"
                ]
              },
              "description": "Select one or more formats to which the target web pages will be extracted.",
              "default": [
                "markdown"
              ]
            },
            "requestTimeoutSecs": {
              "type": "integer",
              "minimum": 1,
              "maximum": 300,
              "default": 40,
              "description": "The maximum time in seconds available for the request, including querying Google Search and scraping the target web pages."
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "aws-kb-retrieval": {
    "name": "aws-kb-retrieval",
    "display_name": "AWS Knowledge Base Retrieval",
    "description": "Retrieval from AWS Knowledge Base using Bedrock Agent Runtime",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/aws-kb-retrieval-server",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Knowledge Base",
      "Retrieval",
      "AWS",
      "Bedrock Agent Runtime"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-aws-kb-retrieval"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_REGION": "${AWS_REGION}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "AWS_ACCESS_KEY_ID",
          "-e",
          "AWS_SECRET_ACCESS_KEY",
          "-e",
          "AWS_REGION",
          "mcp/aws-kb-retrieval-server"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_REGION": "${AWS_REGION}"
        }
      }
    },
    "arguments": {
      "AWS_ACCESS_KEY_ID": {
        "description": "The access key ID for your AWS account used for authentication.",
        "required": true,
        "example": "YOUR_ACCESS_KEY_HERE"
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "The secret access key for your AWS account used for authentication.",
        "required": true,
        "example": "YOUR_SECRET_ACCESS_KEY_HERE"
      },
      "AWS_REGION": {
        "description": "The AWS region where your resources are located.",
        "required": true,
        "example": "us-east-1"
      }
    },
    "tools": [
      {
        "name": "retrieve_from_aws_kb",
        "description": "Performs retrieval from the AWS Knowledge Base using the provided query and Knowledge Base ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to perform retrieval on"
            },
            "knowledgeBaseId": {
              "type": "string",
              "description": "The ID of the AWS Knowledge Base"
            },
            "n": {
              "type": "number",
              "default": 3,
              "description": "Number of results to retrieve"
            }
          },
          "required": [
            "query",
            "knowledgeBaseId"
          ]
        }
      }
    ],
    "is_official": true
  },
  "xiyan-mcp-server": {
    "name": "xiyan-mcp-server",
    "display_name": "XiYan MCP Server",
    "description": "An MCP server that supports fetching data from a database using natural language queries, powered by XiyanSQL as the text-to-SQL LLM.",
    "repository": {
      "type": "git",
      "url": "https://github.com/XGenerationLab/xiyan_mcp_server"
    },
    "homepage": "https://github.com/XGenerationLab/xiyan_mcp_server",
    "author": {
      "name": "XGenerationLab"
    },
    "license": "Apache-2.0",
    "categories": [
      "Databases"
    ],
    "tags": [
      "database",
      "sql",
      "database"
    ],
    "installations": {
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "xiyan_mcp_server"
        ],
        "env": {
          "YML": "${YML}"
        }
      }
    },
    "arguments": {
      "YML": {
        "description": "The path to the YAML configuration file required for setting up the server environment variables.",
        "required": true,
        "example": "path/to/yml"
      }
    },
    "tools": [
      {
        "name": "get_data",
        "description": "Fetch the data from database through a natural language query\n\n    Args:\n        query: The query in natual language\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "get_dataArguments",
          "type": "object"
        }
      }
    ]
  },
  "terminal-control": {
    "name": "terminal-control",
    "display_name": "Terminal Controller",
    "description": "A MCP server that enables secure terminal command execution, directory navigation, and file system operations through a standardized interface.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/terminal-controller-mcp"
    },
    "homepage": "https://github.com/GongRzhe/terminal-controller-mcp",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "terminal",
      "command execution",
      "file management",
      "cross-platform"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "terminal-controller"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "terminal_controller"
        ]
      }
    },
    "examples": [
      {
        "title": "Run Command Example",
        "description": "Run the command `ls -la` in the current directory",
        "prompt": "Run the command `ls -la` in the current directory"
      },
      {
        "title": "Navigate Directory Example",
        "description": "Navigate to my Documents folder",
        "prompt": "Navigate to my Documents folder"
      },
      {
        "title": "Show Downloads Example",
        "description": "Show me the contents of my Downloads directory",
        "prompt": "Show me the contents of my Downloads directory"
      },
      {
        "title": "Recent Commands Example",
        "description": "Show me my recent command history",
        "prompt": "Show me my recent command history"
      }
    ],
    "arguments": {
      "terminal_controller": {
        "description": "The Python module that contains the implementation of the Terminal Controller's functionalities.",
        "required": true,
        "example": "terminal_controller"
      }
    },
    "tools": [
      {
        "name": "execute_command",
        "description": "\n    Execute terminal command and return results\n    \n    Args:\n        command: Command line command to execute\n        timeout: Command timeout in seconds, default is 30 seconds\n    \n    Returns:\n        Output of the command execution\n    ",
        "inputSchema": {
          "properties": {
            "command": {
              "title": "Command",
              "type": "string"
            },
            "timeout": {
              "default": 30,
              "title": "Timeout",
              "type": "integer"
            }
          },
          "required": [
            "command"
          ],
          "title": "execute_commandArguments",
          "type": "object"
        }
      },
      {
        "name": "get_command_history",
        "description": "\n    Get recent command execution history\n    \n    Args:\n        count: Number of recent commands to return\n    \n    Returns:\n        Formatted command history record\n    ",
        "inputSchema": {
          "properties": {
            "count": {
              "default": 10,
              "title": "Count",
              "type": "integer"
            }
          },
          "title": "get_command_historyArguments",
          "type": "object"
        }
      },
      {
        "name": "get_current_directory",
        "description": "\n    Get current working directory\n    \n    Returns:\n        Path of current working directory\n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_current_directoryArguments",
          "type": "object"
        }
      },
      {
        "name": "change_directory",
        "description": "\n    Change current working directory\n    \n    Args:\n        path: Directory path to switch to\n    \n    Returns:\n        Operation result information\n    ",
        "inputSchema": {
          "properties": {
            "path": {
              "title": "Path",
              "type": "string"
            }
          },
          "required": [
            "path"
          ],
          "title": "change_directoryArguments",
          "type": "object"
        }
      },
      {
        "name": "list_directory",
        "description": "\n    List files and subdirectories in the specified directory\n    \n    Args:\n        path: Directory path to list contents, default is current directory\n    \n    Returns:\n        List of directory contents\n    ",
        "inputSchema": {
          "properties": {
            "path": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Path"
            }
          },
          "title": "list_directoryArguments",
          "type": "object"
        }
      }
    ]
  },
  "mcp-neo4j-cypher": {
    "display_name": "Neo4j MCP",
    "repository": {
      "type": "git",
      "url": "https://github.com/neo4j-contrib/mcp-neo4j"
    },
    "homepage": "https://github.com/neo4j-contrib/mcp-neo4j",
    "author": {
      "name": "neo4j-contrib"
    },
    "license": "MIT",
    "tags": [
      "neo4j",
      "mcp",
      "cypher",
      "knowledge graph"
    ],
    "arguments": {
      "NEO4J_URI": {
        "description": "Neo4j database URL",
        "required": true,
        "example": "https://<username>:<password>@<instance>.databases.neo4j.com:7687"
      },
      "NEO4J_USERNAME": {
        "description": "Neo4j username",
        "required": true,
        "example": "<username>"
      },
      "NEO4J_PASSWORD": {
        "description": "Neo4j password",
        "required": true,
        "example": "<password>"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-neo4j-cypher",
          "--db-url",
          "${NEO4J_URI}",
          "--username",
          "${NEO4J_USERNAME}",
          "--password",
          "${NEO4J_PASSWORD}"
        ]
      }
    },
    "examples": [
      {
        "title": "Database Schema Query",
        "description": "Get information about what's in the graph database",
        "prompt": "What is in this graph?"
      },
      {
        "title": "Data Visualization",
        "description": "Generate charts from graph data",
        "prompt": "Render a chart from the top products sold by frequency, total and average volume"
      },
      {
        "title": "Instance Management",
        "description": "List Neo4j Aura instances",
        "prompt": "List my instances"
      },
      {
        "title": "Instance Creation",
        "description": "Create a new Neo4j Aura instance",
        "prompt": "Create a new instance named mcp-test for Aura Professional with 4GB and Graph Data Science enabled"
      },
      {
        "title": "Knowledge Storage",
        "description": "Store information in the knowledge graph",
        "prompt": "Store the fact that I worked on the Neo4j MCP Servers today with Andreas and Oskar"
      }
    ],
    "name": "mcp-neo4j",
    "description": "This server enables running Cypher graph queries, analyzing complex domain data, and automatically generating business insights that can be enhanced with Claude's analysis when an Anthropic API key is provided.",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "tavily-search": {
    "name": "tavily-search",
    "display_name": "Tavily Search",
    "description": "An MCP server for Tavily's search & news API, with explicit site inclusions/exclusions",
    "repository": {
      "type": "git",
      "url": "https://github.com/RamXX/mcp-tavily"
    },
    "homepage": "https://github.com/RamXX/mcp-tavily",
    "author": {
      "name": "RamXX"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "AI",
      "Search"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-tavily"
        ],
        "env": {
          "TAVILY_API_KEY": "your_api_key_here"
        }
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp-tavily"
        ],
        "env": {
          "TAVILY_API_KEY": "your_api_key_here"
        }
      }
    },
    "examples": [
      {
        "title": "Regular Web Search",
        "description": "Perform a standard web search using Tavily's capabilities.",
        "prompt": "Tell me about Anthropic's newly released MCP protocol"
      },
      {
        "title": "Domain Filtering Report",
        "description": "Generate a report filtering specific domains.",
        "prompt": "Tell me about redwood trees. Please use MLA format in markdown syntax and include the URLs in the citations. Exclude Wikipedia sources."
      },
      {
        "title": "Direct Answer Search",
        "description": "Use answer search mode for getting direct answers.",
        "prompt": "I want a concrete answer backed by current web sources: What is the average lifespan of redwood trees?"
      },
      {
        "title": "News Search",
        "description": "Retrieve recent news articles on specific topics.",
        "prompt": "Give me the top 10 AI-related news in the last 5 days."
      }
    ],
    "arguments": {
      "TAVILY_API_KEY": {
        "description": "Your Tavily API key for accessing Tavily's search API functionalities.",
        "required": true,
        "example": "your_api_key_here"
      }
    }
  },
  "devhub-cms-mcp": {
    "display_name": "DevHub CMS MCP",
    "repository": {
      "type": "git",
      "url": "https://github.com/devhub/devhub-cms-mcp"
    },
    "homepage": "https://github.com/devhub/devhub-cms-mcp",
    "author": {
      "name": "devhub"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "cms",
      "content management",
      "devhub"
    ],
    "arguments": {
      "DEVHUB_API_KEY": {
        "description": "Your DevHub API key",
        "required": true,
        "example": "YOUR_KEY_HERE"
      },
      "DEVHUB_API_SECRET": {
        "description": "Your DevHub API secret",
        "required": true,
        "example": "YOUR_SECRET_HERE"
      },
      "DEVHUB_BASE_URL": {
        "description": "Your DevHub base URL",
        "required": true,
        "example": "https://yourbrand.cloudfrontend.net"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "devhub-cms-mcp"
        ],
        "env": {
          "DEVHUB_API_KEY": "YOUR_KEY_HERE",
          "DEVHUB_API_SECRET": "YOUR_SECRET_HERE",
          "DEVHUB_BASE_URL": "https://yourbrand.cloudfrontend.net"
        },
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Get business information",
        "description": "Retrieve all businesses within the DevHub account",
        "prompt": "Can you list all the businesses in my DevHub account?"
      },
      {
        "title": "Create a blog post",
        "description": "Create a new blog post for a specific site",
        "prompt": "Create a new blog post titled 'Summer Specials' for my site with content about our seasonal offerings."
      }
    ],
    "name": "devhub-cms-mcp",
    "description": "Manage and utilize website content within the DevHub CMS platform",
    "categories": [
      "Productivity"
    ],
    "tools": [
      {
        "name": "get_hours_of_operation",
        "description": "Get the hours of operation for a DevHub location\n\n    Returns a list of items representing days of the week\n\n    Except for the special case formatting, this object is a list of 7 items which represent each day.\n\n    Each day can can have one-four time ranges. For example, two time ranges denotes a \"lunch-break\". No time ranges denotes closed.\n\n    Examples:\n    9am-5pm [[\"09:00:00\", \"17:00:00\"]]\n    9am-12pm and 1pm-5pm [[\"09:00:00\", \"12:00:00\"], [\"13:00:00\", \"17:00:00\"]]\n    Closed - an empty list []\n\n    Args:\n        location_id: DevHub Location ID\n        hours_type: Defaults to 'primary' unless the user specifies a different type\n    ",
        "inputSchema": {
          "properties": {
            "location_id": {
              "title": "Location Id",
              "type": "integer"
            },
            "hours_type": {
              "default": "primary",
              "title": "Hours Type",
              "type": "string"
            }
          },
          "required": [
            "location_id"
          ],
          "title": "get_hours_of_operationArguments",
          "type": "object"
        }
      },
      {
        "name": "get_businesses",
        "description": "Get all businesses within the DevHub account\n\n    Returns a list of businesses with the following fields:\n    - id: Business ID that can be used in the other tools\n    - business_name: Business name\n\n    If only one business exists in the account, you can assume that the user wants to use that business for any business_id related tools.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_businessesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_locations",
        "description": "Get all locations for a business\n\n    Returns a list of locations with the following fields:\n    - id: Location ID that can be used in the other tools\n    - location_name: Location name\n    - location_url: Location URL in DevHub\n    - street: Street address\n    - city: City\n    - state: State\n    - country: Country\n    - postal_code: Postal code\n    - lat: Latitude\n    - lon: Longitude\n    ",
        "inputSchema": {
          "properties": {
            "business_id": {
              "title": "Business Id",
              "type": "integer"
            }
          },
          "required": [
            "business_id"
          ],
          "title": "get_locationsArguments",
          "type": "object"
        }
      },
      {
        "name": "update_hours",
        "description": "Update the hours of operation for a DevHub location\n\n    Send a list of items representing days of the week\n\n    Except for the special case formatting, this object is a list of 7 items which represent each day.\n\n    Each day can can have one-four time ranges. For example, two time ranges denotes a \"lunch-break\". No time ranges denotes closed.\n\n    Examples:\n    9am-5pm [[\"09:00:00\", \"17:00:00\"]]\n    9am-12pm and 1pm-5pm [[\"09:00:00\", \"12:00:00\"], [\"13:00:00\", \"17:00:00\"]]\n    Closed - an empty list []\n\n    Args:\n        location_id: DevHub Location ID\n        new_hours: Structured format of the new hours\n        hours_type: Defaults to 'primary' unless the user specifies a different type\n    ",
        "inputSchema": {
          "properties": {
            "location_id": {
              "title": "Location Id",
              "type": "integer"
            },
            "new_hours": {
              "items": {},
              "title": "New Hours",
              "type": "array"
            },
            "hours_type": {
              "default": "primary",
              "title": "Hours Type",
              "type": "string"
            }
          },
          "required": [
            "location_id",
            "new_hours"
          ],
          "title": "update_hoursArguments",
          "type": "object"
        }
      },
      {
        "name": "site_from_url",
        "description": "Get the DevHub site ID from a URL.\n\n    Can prompt the user for the URL instead of passing a site_id.\n\n    Returns details about the Site matches the URL that can be used in the other tools.\n    - Site ID: ID of the DevHub site\n    - Site URL: URL of the DevHub site\n    - Site Location IDs: List of location IDs associated with the site\n\n    Args:\n        url: URL of the DevHub site, all lowercase and ends with a slash\n    ",
        "inputSchema": {
          "properties": {
            "url": {
              "title": "Url",
              "type": "string"
            }
          },
          "required": [
            "url"
          ],
          "title": "site_from_urlArguments",
          "type": "object"
        }
      },
      {
        "name": "upload_image",
        "description": "Upload an image to the DevHub media gallery\n\n    Supports webp, jpeg and png images\n\n    Args:\n        base64_image_content: Base 64 encoded content of the image file\n        filename: Filename including the extension\n    ",
        "inputSchema": {
          "properties": {
            "base64_image_content": {
              "title": "Base64 Image Content",
              "type": "string"
            },
            "filename": {
              "title": "Filename",
              "type": "string"
            }
          },
          "required": [
            "base64_image_content",
            "filename"
          ],
          "title": "upload_imageArguments",
          "type": "object"
        }
      },
      {
        "name": "get_blog_post",
        "description": "Get a single blog post\n\n    Args:\n        post_id: Blog post id\n    ",
        "inputSchema": {
          "properties": {
            "post_id": {
              "title": "Post Id",
              "type": "integer"
            }
          },
          "required": [
            "post_id"
          ],
          "title": "get_blog_postArguments",
          "type": "object"
        }
      },
      {
        "name": "create_blog_post",
        "description": "Create a new blog post\n\n    Args:\n        site_id: Website ID where the post will be published. Prompt the user for this ID.\n        title: Blog post title\n        content: HTML content of blog post. Should not include a <h1> tag, only h2+\n    ",
        "inputSchema": {
          "properties": {
            "site_id": {
              "title": "Site Id",
              "type": "integer"
            },
            "title": {
              "title": "Title",
              "type": "string"
            },
            "content": {
              "title": "Content",
              "type": "string"
            }
          },
          "required": [
            "site_id",
            "title",
            "content"
          ],
          "title": "create_blog_postArguments",
          "type": "object"
        }
      },
      {
        "name": "update_blog_post",
        "description": "Update a single blog post\n\n    Args:\n        post_id: Blog post ID\n        title: Blog post title\n        content: HTML content of blog post. Should not include a <h1> tag, only h2+\n    ",
        "inputSchema": {
          "properties": {
            "post_id": {
              "title": "Post Id",
              "type": "integer"
            },
            "title": {
              "default": null,
              "title": "Title",
              "type": "string"
            },
            "content": {
              "default": null,
              "title": "Content",
              "type": "string"
            }
          },
          "required": [
            "post_id"
          ],
          "title": "update_blog_postArguments",
          "type": "object"
        }
      },
      {
        "name": "get_nearest_location",
        "description": "Get the nearest DevHub location\n\n    Args:\n        business_id: DevHub Business ID associated with the location. Prompt the user for this ID\n        latitude: Latitude of the location\n        longitude: Longitude of the location\n    ",
        "inputSchema": {
          "properties": {
            "business_id": {
              "title": "Business Id",
              "type": "integer"
            },
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            }
          },
          "required": [
            "business_id",
            "latitude",
            "longitude"
          ],
          "title": "get_nearest_locationArguments",
          "type": "object"
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "gmail": {
    "name": "gmail",
    "display_name": "Gmail AutoAuth",
    "description": "A Model Context Protocol (MCP) server for Gmail integration in Claude Desktop with auto authentication support.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/Gmail-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/Gmail-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "gmail",
      "autoauth",
      "claude"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@gongrzhe/server-gmail-autoauth-mcp"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-v",
          "mcp-gmail:/gmail-server",
          "-e",
          "${GMAIL_CREDENTIALS_PATH}=/gmail-server/credentials.json",
          "mcp/gmail"
        ]
      }
    },
    "arguments": {
      "GMAIL_CREDENTIALS_PATH": {
        "description": "The path to the Gmail credentials file that the server will use for OAuth authentication.",
        "required": true,
        "example": "/gmail-server/credentials.json"
      }
    },
    "tools": [
      {
        "name": "send_email",
        "description": "Sends a new email.",
        "inputSchema": {
          "to": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of recipient email addresses"
          },
          "subject": {
            "type": "string",
            "description": "Email subject"
          },
          "body": {
            "type": "string",
            "description": "Email body content"
          },
          "cc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of CC recipients",
            "optional": true
          },
          "bcc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of BCC recipients",
            "optional": true
          }
        },
        "required": [
          "to",
          "subject",
          "body"
        ]
      },
      {
        "name": "draft_email",
        "description": "Draft a new email.",
        "inputSchema": {
          "to": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of recipient email addresses"
          },
          "subject": {
            "type": "string",
            "description": "Email subject"
          },
          "body": {
            "type": "string",
            "description": "Email body content"
          },
          "cc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of CC recipients",
            "optional": true
          },
          "bcc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of BCC recipients",
            "optional": true
          }
        },
        "required": [
          "to",
          "subject",
          "body"
        ]
      },
      {
        "name": "read_email",
        "description": "Retrieves the content of a specific email.",
        "inputSchema": {
          "messageId": {
            "type": "string",
            "description": "ID of the email message to retrieve"
          }
        },
        "required": [
          "messageId"
        ]
      },
      {
        "name": "search_emails",
        "description": "Searches for emails using Gmail search syntax.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Gmail search query (e.g., 'from:example@gmail.com')"
          },
          "maxResults": {
            "type": "number",
            "description": "Maximum number of results to return",
            "optional": true
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "modify_email",
        "description": "Modifies email labels (move to different folders).",
        "inputSchema": {
          "messageId": {
            "type": "string",
            "description": "ID of the email message to modify"
          },
          "labelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of label IDs to apply",
            "optional": true
          },
          "addLabelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of label IDs to add to the message",
            "optional": true
          },
          "removeLabelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of label IDs to remove from the message",
            "optional": true
          }
        },
        "required": [
          "messageId"
        ]
      },
      {
        "name": "delete_email",
        "description": "Permanently deletes an email.",
        "inputSchema": {
          "messageId": {
            "type": "string",
            "description": "ID of the email message to delete"
          }
        },
        "required": [
          "messageId"
        ]
      },
      {
        "name": "list_email_labels",
        "description": "Retrieves all available Gmail labels.",
        "inputSchema": {},
        "required": []
      }
    ]
  },
  "vectorize-mcp-server": {
    "display_name": "Vectorize MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/vectorize-io/vectorize-mcp-server"
    },
    "homepage": "https://vectorize.io/",
    "author": {
      "name": "vectorize-io"
    },
    "license": "MIT",
    "tags": [
      "vector retrieval",
      "text extraction"
    ],
    "arguments": {
      "VECTORIZE_ORG_ID": {
        "description": "Vectorize Organization ID",
        "required": true,
        "example": "your-org-id"
      },
      "VECTORIZE_TOKEN": {
        "description": "Vectorize Token",
        "required": true,
        "example": "your-token"
      },
      "VECTORIZE_PIPELINE_ID": {
        "description": "Vectorize Pipeline ID",
        "required": true,
        "example": "your-pipeline-id"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@vectorize-io/vectorize-mcp-server@latest"
        ],
        "package": "@vectorize-io/vectorize-mcp-server",
        "env": {
          "VECTORIZE_ORG_ID": "${VECTORIZE_ORG_ID}",
          "VECTORIZE_TOKEN": "${VECTORIZE_TOKEN}",
          "VECTORIZE_PIPELINE_ID": "${VECTORIZE_PIPELINE_ID}"
        },
        "description": "Run with npx",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Retrieve documents",
        "description": "Perform vector search and retrieve documents",
        "prompt": "{\"name\":\"retrieve\",\"arguments\":{\"question\":\"Financial health of the company\",\"k\":5}}"
      },
      {
        "title": "Text extraction and chunking",
        "description": "Extract text from a document and chunk it into Markdown format",
        "prompt": "{\"name\":\"extract\",\"arguments\":{\"base64document\":\"base64-encoded-document\",\"contentType\":\"application/pdf\"}}"
      },
      {
        "title": "Deep Research",
        "description": "Generate a Private Deep Research from your pipeline",
        "prompt": "{\"name\":\"deep-research\",\"arguments\":{\"query\":\"Generate a financial status report about the company\",\"webSearch\":true}}"
      }
    ],
    "name": "vectorize-mcp-server",
    "description": "A Model Context Protocol (MCP) server implementation that integrates with [Vectorize](https://vectorize.io/) for advanced Vector retrieval and text extraction.",
    "categories": [
      "Databases"
    ],
    "tools": [
      {
        "name": "retrieve",
        "description": "Retrieve documents from the configured pipeline.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "question": {
              "type": "string",
              "description": "The term to search for."
            },
            "k": {
              "type": "number",
              "description": "The number of documents to retrieve.",
              "default": 4
            }
          },
          "required": [
            "question"
          ]
        }
      },
      {
        "name": "extract",
        "description": "Perform text extraction and chunking on a document.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base64Document": {
              "type": "string",
              "description": "Document encoded in base64."
            },
            "contentType": {
              "type": "string",
              "description": "Document content type."
            }
          },
          "required": [
            "base64Document",
            "contentType"
          ]
        }
      },
      {
        "name": "deep-research",
        "description": "Generate a deep research on the configured pipeline.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The deep research query."
            },
            "webSearch": {
              "type": "boolean",
              "description": "Whether to perform a web search."
            }
          },
          "required": [
            "query",
            "webSearch"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "verodat-mcp-server": {
    "display_name": "Verodat MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/Verodat/verodat-mcp-server"
    },
    "homepage": "https://verodat.io",
    "author": {
      "name": "Verodat"
    },
    "license": "LICENSE",
    "tags": [
      "MCP",
      "AI",
      "Data Management",
      "Claude Desktop"
    ],
    "arguments": {
      "VERODAT_AI_API_KEY": {
        "description": "Your Verodat AI API key",
        "required": true,
        "example": "your-verodat-ai-api-key"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "description": "Run with custom command",
        "command": "node",
        "args": [
          "path/to/verodat-mcp-server/build/src/index.js"
        ],
        "env": {
          "VERODAT_AI_API_KEY": "${VERODAT_AI_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "List accounts",
        "description": "List all accessible Verodat accounts",
        "prompt": "get-accounts"
      },
      {
        "title": "List workspaces",
        "description": "List workspaces in an account",
        "prompt": "get-workspaces"
      },
      {
        "title": "Execute AI query",
        "description": "Run AI queries on datasets",
        "prompt": "execute-ai-query"
      }
    ],
    "name": "verodat-mcp-server",
    "description": "A Model Context Protocol (MCP) server implementation for [Verodat](https://verodat.io), enabling seamless integration of Verodat's data management capabilities with AI systems like Claude Desktop.",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "wxflows": {
    "display_name": "wxflows MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/IBM/wxflows/tree/main/examples/mcp"
    },
    "homepage": "https://github.com/IBM/wxflows/",
    "author": {
      "name": "IBM"
    },
    "license": "MIT",
    "tags": [
      "mcp",
      "ai",
      "tools",
      "watsonx"
    ],
    "arguments": {
      "WXFLOWS_APIKEY": {
        "description": "API key for wxflows service",
        "required": true,
        "example": "YOUR_WXFLOWS_APIKEY"
      },
      "WXFLOWS_ENDPOINT": {
        "description": "Endpoint URL for wxflows service",
        "required": true,
        "example": "YOUR_WXFLOWS_ENDPOINT"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "build/index.js"
        ],
        "env": {
          "WXFLOWS_APIKEY": "YOUR_WXFLOWS_APIKEY",
          "WXFLOWS_ENDPOINT": "YOUR_WXFLOWS_ENDPOINT"
        },
        "description": "Run the MCP server using Node.js",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Search for books",
        "description": "Use the google_books tool to search for books",
        "prompt": "Find me books about artificial intelligence"
      },
      {
        "title": "Look up information on Wikipedia",
        "description": "Use the wikipedia tool to search for information",
        "prompt": "Find information about machine learning on Wikipedia"
      }
    ],
    "name": "wxflows",
    "description": "data-color-mode=\"auto\" data-light-theme=\"light\" data-dark-theme=\"dark\"",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "kubernetes-and-openshift": {
    "name": "kubernetes-and-openshift",
    "display_name": "Kubernetes and OpenShift",
    "description": "A powerful Kubernetes MCP server with additional support for OpenShift. Besides providing CRUD operations for any Kubernetes resource, this server provides specialized tools to interact with your cluster.",
    "repository": {
      "type": "git",
      "url": "https://github.com/manusa/kubernetes-mcp-server"
    },
    "homepage": "https://github.com/manusa/kubernetes-mcp-server",
    "author": {
      "name": "manusa"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Kubernetes",
      "Server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "kubernetes-mcp-server@latest"
        ]
      }
    }
  },
  "python-code-execution": {
    "name": "python-code-execution",
    "display_name": "Python Code Execution",
    "description": "A secure sandboxed Python code execution environment for MCP (Model-Client-Program) architecture.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pathintegral-institute/mcp.science"
    },
    "homepage": "https://github.com/pathintegral-institute/mcp.science/tree/main/servers/python-code-execution",
    "author": {
      "name": "pathintegral-institute"
    },
    "license": "MIT",
    "tags": [
      "python",
      "code-execution"
    ],
    "arguments": {},
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pathintegral-institute/mcp.science@main#subdirectory=servers/python-code-execution",
          "mcp-python-code-execution"
        ],
        "description": "Run using uv (recommended)"
      }
    },
    "examples": [
      {
        "title": "Execute simple Python code",
        "description": "Run a simple Python calculation",
        "prompt": "Execute this Python code: `print(\"Hello World\")`"
      }
    ],
    "categories": [
      "Dev Tools"
    ],
    "tools": [
      {
        "name": "python_code_execution",
        "description": "Execute Python code in a secure sandbox with restricted imports and resource limits. Supports visualization with matplotlib and numerical computation with numpy.",
        "prompt": "Execute this Python code: print('Hello, world!')",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "Python code to execute",
              "minLength": 1
            },
            "show_output": {
              "type": "boolean",
              "description": "Whether to show the output of the code execution",
              "default": true
            }
          }
        },
        "required": [
          "code"
        ]
      }
    ],
    "is_official": true
  },
  "mysql": {
    "name": "mysql",
    "display_name": "MySQL Database Integration",
    "description": "MySQL database integration in Python with configurable access controls and schema inspection",
    "repository": {
      "type": "git",
      "url": "https://github.com/designcomputer/mysql_mcp_server"
    },
    "homepage": "https://github.com/designcomputer/mysql_mcp_server",
    "author": {
      "name": "designcomputer"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "MySQL",
      "Database Access"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mysql_mcp_server"
        ],
        "env": {
          "MYSQL_HOST": "${MYSQL_HOST}",
          "MYSQL_PORT": "${MYSQL_PORT}",
          "MYSQL_USER": "${MYSQL_USER}",
          "MYSQL_PASSWORD": "${MYSQL_PASSWORD}",
          "MYSQL_DATABASE": "${MYSQL_DATABASE}"
        }
      }
    },
    "arguments": {
      "MYSQL_HOST": {
        "description": "Database host",
        "required": true,
        "example": "localhost"
      },
      "MYSQL_PORT": {
        "description": "Database port (defaults to 3306 if not specified)",
        "required": false,
        "example": "3306"
      },
      "MYSQL_USER": {
        "description": "Username for database access",
        "required": true,
        "example": "your_username"
      },
      "MYSQL_PASSWORD": {
        "description": "Password for the database user",
        "required": true,
        "example": "your_password"
      },
      "MYSQL_DATABASE": {
        "description": "Database name to connect to",
        "required": true,
        "example": "your_database"
      }
    },
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute an SQL query on the MySQL server",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "mindmap": {
    "name": "mindmap",
    "display_name": "Mindmap",
    "description": "A server that generates mindmaps from input containing markdown code.",
    "repository": {
      "type": "git",
      "url": "https://github.com/YuChenSSR/mindmap-mcp-server"
    },
    "homepage": "https://github.com/YuChenSSR/mindmap-mcp-server",
    "author": {
      "name": "YuChenSSR"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "mindmap",
      "markdown",
      "interactive"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mindmap-mcp-server",
          "--return-type",
          "html"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "-v",
          "/path/to/output/folder:/output",
          "ychen94/mindmap-converter-mcp:latest"
        ]
      }
    },
    "examples": [
      {
        "title": "Basic Mindmap Generation",
        "description": "Generate a mindmap from Markdown input.",
        "prompt": "give a mindmap for the following markdown code, using a mindmap tool:\n```\n# Project Planning\n## Research\n### Market Analysis\n### Competitor Review\n## Design\n### Wireframes\n### Mockups\n## Development\n### Frontend\n### Backend\n## Testing\n### Unit Tests\n### User Testing\n```\n"
      },
      {
        "title": "Save Mindmap to File",
        "description": "Save the generated mindmap as an HTML file and open it in the browser.",
        "prompt": "give a mindmap for the following markdown input_code using a mindmap tool,\nafter that,use iterm to open the generated html file.\ninput_code:\n```\nmarkdown content\n```\n"
      },
      {
        "title": "Elephant in Refrigerator Mindmap",
        "description": "Create a mindmap about the process of putting an elephant into a refrigerator.",
        "prompt": "Think about the process of putting an elephant into a refrigerator, and provide a mind map. Open it with a terminal."
      }
    ],
    "tools": [
      {
        "name": "convert_markdown_to_mindmap",
        "description": "Convert Markdown content to a mindmap mind map.\n    \n    Args:\n        markdown_content: The Markdown content to convert\n    \n    Returns:\n        Either the HTML content or the file path to the generated HTML, \n        depending on the --return-type server argument\n    ",
        "inputSchema": {
          "properties": {
            "markdown_content": {
              "title": "Markdown Content",
              "type": "string"
            }
          },
          "required": [
            "markdown_content"
          ],
          "title": "convert_markdown_to_mindmapArguments",
          "type": "object"
        }
      }
    ]
  },
  "mcp-server-raygun": {
    "display_name": "Raygun MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/MindscapeHQ/mcp-server-raygun"
    },
    "homepage": "https://github.com/MindscapeHQ/mcp-server-raygun",
    "author": {
      "name": "MindscapeHQ"
    },
    "license": "MIT",
    "tags": [
      "raygun",
      "crash reporting",
      "real user monitoring",
      "error management",
      "performance monitoring"
    ],
    "arguments": {
      "RAYGUN_PAT_TOKEN": {
        "description": "Your Raygun PAT token",
        "required": true,
        "example": "your-pat-token-here"
      },
      "SOURCEMAP_ALLOWED_DIRS": {
        "description": "Comma-separated list of directories allowed for source map operations",
        "required": false
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@raygun.io/mcp-server-raygun"
        ],
        "package": "@raygun.io/mcp-server-raygun",
        "env": {
          "RAYGUN_PAT_TOKEN": "your-pat-token-here"
        },
        "description": "Install and run using npm",
        "recommended": true
      },
      "custom": {
        "type": "custom",
        "command": "/path/to/server-raygun/build/index.js",
        "args": [],
        "env": {
          "RAYGUN_PAT_TOKEN": "your-pat-token-ken"
        },
        "description": "Run from a local build",
        "recommended": false
      }
    },
    "examples": [],
    "name": "mcp-server-raygun",
    "description": "MCP Server for Raygun's API V3 endpoints for interacting with your Crash Reporting and Real User Monitoring applications. This server provides comprehensive access to Raygun's API features through the Model Context Protocol.",
    "categories": [
      "Dev Tools"
    ],
    "tools": [
      {
        "name": "list_applications",
        "description": "List all applications under the users account on Raygun",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "description": "Limits the number of items in the response"
            },
            "offset": {
              "type": "number",
              "description": "Number of items to skip before returning results"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "name",
                  "name desc",
                  "apikey",
                  "apikey desc"
                ]
              },
              "description": "Order items by property values"
            }
          }
        }
      },
      {
        "name": "get_application",
        "description": "Get application by identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      },
      {
        "name": "get_application_by_api_key",
        "description": "Get application by API key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "apiKey": {
              "type": "string",
              "description": "Application api key"
            }
          },
          "required": [
            "apiKey"
          ]
        }
      },
      {
        "name": "regenerate_application_api_key",
        "description": "Regenerate application API key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      },
      {
        "name": "list_customers",
        "description": "List customers for an application",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "description": "Limits the number of items in the response"
            },
            "offset": {
              "type": "number",
              "description": "Number of items to skip before returning results"
            },
            "applicationIdentifier": {
              "type": "string"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "isAnonymous",
                  "isAnonymous desc",
                  "firstSeenAt",
                  "firstSeenAt desc",
                  "lastSeenAt",
                  "lastSeenAt desc"
                ]
              },
              "description": "Order items by property values"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      },
      {
        "name": "list_deployments",
        "description": "List deployments for an application",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "description": "Limits the number of items in the response"
            },
            "offset": {
              "type": "number",
              "description": "Number of items to skip before returning results"
            },
            "applicationIdentifier": {
              "type": "string"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "version",
                  "version desc",
                  "emailAddress",
                  "emailAddress desc",
                  "ownerName",
                  "ownerName desc",
                  "comment",
                  "comment desc",
                  "deployedAt",
                  "deployedAt desc"
                ]
              },
              "description": "Order items by property values"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      },
      {
        "name": "get_deployment",
        "description": "Get deployment by identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "deploymentIdentifier": {
              "type": "string",
              "description": "Deployment identifier"
            }
          },
          "required": [
            "applicationIdentifier",
            "deploymentIdentifier"
          ]
        }
      },
      {
        "name": "delete_deployment",
        "description": "Delete deployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "deploymentIdentifier": {
              "type": "string",
              "description": "Deployment identifier"
            }
          },
          "required": [
            "applicationIdentifier",
            "deploymentIdentifier"
          ]
        }
      },
      {
        "name": "update_deployment",
        "description": "Update deployment details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "deploymentIdentifier": {
              "type": "string",
              "description": "Deployment identifier"
            },
            "version": {
              "type": "string",
              "minLength": 1,
              "maxLength": 128
            },
            "ownerName": {
              "type": "string",
              "maxLength": 128
            },
            "emailAddress": {
              "type": "string",
              "format": "email",
              "maxLength": 128
            },
            "comment": {
              "type": "string"
            },
            "scmIdentifier": {
              "type": "string",
              "maxLength": 256
            },
            "scmType": {
              "type": "string",
              "enum": [
                "gitHub",
                "gitLab",
                "azureDevOps",
                "bitbucket"
              ]
            },
            "deployedAt": {
              "type": "string",
              "format": "date-time"
            }
          },
          "required": [
            "applicationIdentifier",
            "deploymentIdentifier"
          ]
        }
      },
      {
        "name": "reprocess_deployment_commits",
        "description": "Reprocess deployment commits",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "deploymentIdentifier": {
              "type": "string",
              "description": "Deployment identifier"
            }
          },
          "required": [
            "applicationIdentifier",
            "deploymentIdentifier"
          ]
        }
      },
      {
        "name": "list_error_groups",
        "description": "List error groups for an application",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "description": "Limits the number of items in the response"
            },
            "offset": {
              "type": "number",
              "description": "Number of items to skip before returning results"
            },
            "applicationIdentifier": {
              "type": "string"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "message",
                  "message desc",
                  "status",
                  "status desc",
                  "lastOccurredAt",
                  "lastOccurredAt desc",
                  "createdAt",
                  "createdAt desc"
                ]
              },
              "description": "Order items by property values"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      },
      {
        "name": "get_error_group",
        "description": "Get error group by identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "errorGroupIdentifier": {
              "type": "string",
              "description": "Error group identifier"
            }
          },
          "required": [
            "applicationIdentifier",
            "errorGroupIdentifier"
          ]
        }
      },
      {
        "name": "resolve_error_group",
        "description": "Set the status of the error group to resolved",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "errorGroupIdentifier": {
              "type": "string",
              "description": "Error group identifier"
            },
            "version": {
              "type": "string",
              "description": "The version that this error was resolved in"
            },
            "discardFromPreviousVersions": {
              "type": "boolean",
              "default": true,
              "description": "When true, occurrences from previous versions will be discarded"
            }
          },
          "required": [
            "applicationIdentifier",
            "errorGroupIdentifier",
            "version"
          ]
        }
      },
      {
        "name": "activate_error_group",
        "description": "Set the status of the error group to active",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "errorGroupIdentifier": {
              "type": "string",
              "description": "Error group identifier"
            }
          },
          "required": [
            "applicationIdentifier",
            "errorGroupIdentifier"
          ]
        }
      },
      {
        "name": "ignore_error_group",
        "description": "Set the status of the error group to ignored",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "errorGroupIdentifier": {
              "type": "string",
              "description": "Error group identifier"
            }
          },
          "required": [
            "applicationIdentifier",
            "errorGroupIdentifier"
          ]
        }
      },
      {
        "name": "permanently_ignore_error_group",
        "description": "Set the status of the error group to permanently ignored",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "errorGroupIdentifier": {
              "type": "string",
              "description": "Error group identifier"
            },
            "discardNewOccurrences": {
              "type": "boolean",
              "description": "When true, new occurrences of this error will not be stored or count towards your error quota"
            }
          },
          "required": [
            "applicationIdentifier",
            "errorGroupIdentifier",
            "discardNewOccurrences"
          ]
        }
      },
      {
        "name": "list_pages",
        "description": "List pages for an application",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "description": "Limits the number of items in the response"
            },
            "offset": {
              "type": "number",
              "description": "Number of items to skip before returning results"
            },
            "applicationIdentifier": {
              "type": "string"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "lastSeenAt",
                  "lastSeenAt desc",
                  "uri",
                  "uri desc",
                  "name",
                  "name desc"
                ]
              },
              "description": "Order items by property values"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      },
      {
        "name": "get_page_metrics_time_series",
        "description": "Get time-series metrics for pages",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string"
            },
            "start": {
              "type": "string",
              "format": "date-time"
            },
            "end": {
              "type": "string",
              "format": "date-time"
            },
            "granularity": {
              "type": "string",
              "pattern": "^\\d+[mhd]$",
              "description": "Time granularity in format like '1h', '30m', '1d'"
            },
            "aggregation": {
              "type": "string",
              "enum": [
                "count",
                "average",
                "median",
                "sum",
                "min",
                "max",
                "p95",
                "p99"
              ]
            },
            "metrics": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "pageViews",
                  "loadTime",
                  "firstPaint",
                  "firstContentfulPaint",
                  "firstInputDelay",
                  "largestContentfulPaint",
                  "cumulativeLayoutShift",
                  "interactionToNextPaint"
                ]
              }
            },
            "filter": {
              "type": "string",
              "description": "Case-sensitive filter in the format 'pageIdentifier = abc123' or 'pageIdentifier IN (abc123, def456)'"
            }
          },
          "required": [
            "applicationIdentifier",
            "start",
            "end",
            "granularity",
            "aggregation",
            "metrics"
          ]
        }
      },
      {
        "name": "get_page_metrics_histogram",
        "description": "Get histogram metrics for pages",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string"
            },
            "start": {
              "type": "string",
              "format": "date-time"
            },
            "end": {
              "type": "string",
              "format": "date-time"
            },
            "metrics": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "loadTime",
                  "firstPaint",
                  "firstContentfulPaint",
                  "firstInputDelay",
                  "largestContentfulPaint",
                  "cumulativeLayoutShift",
                  "interactionToNextPaint"
                ]
              }
            },
            "filter": {
              "type": "string",
              "description": "Case-sensitive filter in the format 'pageIdentifier = abc123' or 'pageIdentifier IN (abc123, def456)'"
            }
          },
          "required": [
            "applicationIdentifier",
            "start",
            "end",
            "metrics"
          ]
        }
      },
      {
        "name": "get_error_metrics_time_series",
        "description": "Get time-series metrics for errors",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string"
            },
            "start": {
              "type": "string",
              "format": "date-time"
            },
            "end": {
              "type": "string",
              "format": "date-time"
            },
            "granularity": {
              "type": "string",
              "pattern": "^\\d+[mhd]$",
              "description": "Time granularity in format like '1h', '30m', '1d'"
            },
            "aggregation": {
              "type": "string",
              "const": "count"
            },
            "metrics": {
              "type": "array",
              "items": {
                "type": "string",
                "const": "errorInstances"
              }
            },
            "filter": {
              "type": "string",
              "description": "Case-sensitive filter in the format 'errorGroupIdentifier = abc123' or 'errorGroupIdentifier IN (abc123, def456)'"
            }
          },
          "required": [
            "applicationIdentifier",
            "start",
            "end",
            "granularity",
            "aggregation",
            "metrics"
          ]
        }
      },
      {
        "name": "list_sessions",
        "description": "List sessions for an application",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "description": "Limits the number of items in the response"
            },
            "offset": {
              "type": "number",
              "description": "Number of items to skip before returning results"
            },
            "applicationIdentifier": {
              "type": "string"
            },
            "filter": {
              "type": "string",
              "description": "Filter items by an expression. Currently only supports filtering by `xhr.uri`. Example: xhr.uri eq https://example.com"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "customerIdentifier",
                  "customerIdentifier desc",
                  "startedAt",
                  "startedAt desc",
                  "updatedAt",
                  "updatedAt desc",
                  "endedAt",
                  "endedAt desc",
                  "countryCode",
                  "countryCode desc",
                  "platformName",
                  "platformName desc",
                  "operatingSystemName",
                  "operatingSystemName desc",
                  "operatingSystemVersion",
                  "operatingSystemVersion desc",
                  "browserName",
                  "browserName desc",
                  "browserVersion",
                  "browserVersion desc",
                  "viewportWidth",
                  "viewportWidth desc",
                  "viewportHeight",
                  "viewportHeight desc",
                  "deploymentVersion",
                  "deploymentVersion desc"
                ]
              },
              "description": "Order items by property values"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      },
      {
        "name": "get_session",
        "description": "Get session by identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string"
            },
            "sessionIdentifier": {
              "type": "string"
            },
            "include": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "pageViews",
                  "errors"
                ]
              },
              "description": "Include additional information for the session"
            }
          },
          "required": [
            "applicationIdentifier",
            "sessionIdentifier"
          ]
        }
      },
      {
        "name": "list_invitations",
        "description": "Returns a list invitations that the token and token owner has access to",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "description": "Limits the number of items in the response"
            },
            "offset": {
              "type": "number",
              "description": "Number of items to skip before returning results"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "emailAddress",
                  "emailAddress desc",
                  "createdAt",
                  "createdAt desc"
                ]
              },
              "description": "Order items by property values"
            }
          }
        }
      },
      {
        "name": "send_invitation",
        "description": "Send an invitation to a user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "emailAddress": {
              "type": "string",
              "format": "email",
              "description": "Email address to send the invitation to"
            }
          },
          "required": [
            "emailAddress"
          ]
        }
      },
      {
        "name": "get_invitation",
        "description": "Get an invitation by identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "invitationIdentifier": {
              "type": "string",
              "description": "Invitation identifier"
            }
          },
          "required": [
            "invitationIdentifier"
          ]
        }
      },
      {
        "name": "revoke_invitation",
        "description": "Revoke a sent invitation",
        "inputSchema": {
          "type": "object",
          "properties": {
            "invitationIdentifier": {
              "type": "string",
              "description": "Invitation identifier"
            }
          },
          "required": [
            "invitationIdentifier"
          ]
        }
      },
      {
        "name": "list_source_maps",
        "description": "Returns a list of source maps for the specified application",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "description": "Limits the number of items in the response"
            },
            "offset": {
              "type": "number",
              "description": "Number of items to skip before returning results"
            },
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "uri",
                  "uri desc",
                  "fileName",
                  "fileName desc",
                  "fileSizeBytes",
                  "fileSizeBytes desc",
                  "uploadedAt",
                  "uploadedAt desc",
                  "createdAt",
                  "createdAt desc",
                  "updatedAt",
                  "updatedAt desc"
                ]
              },
              "description": "Order items by property values"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      },
      {
        "name": "get_source_map",
        "description": "Returns a single source map by identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "sourceMapIdentifier": {
              "type": "string",
              "description": "Source map identifier"
            }
          },
          "required": [
            "applicationIdentifier",
            "sourceMapIdentifier"
          ]
        }
      },
      {
        "name": "update_source_map",
        "description": "Update the details of a source map",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "sourceMapIdentifier": {
              "type": "string",
              "description": "Source map identifier"
            },
            "uri": {
              "type": "string",
              "format": "uri",
              "description": "New URI for the source map"
            }
          },
          "required": [
            "applicationIdentifier",
            "sourceMapIdentifier",
            "uri"
          ]
        }
      },
      {
        "name": "delete_source_map",
        "description": "Delete a source map",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "sourceMapIdentifier": {
              "type": "string",
              "description": "Source map identifier"
            }
          },
          "required": [
            "applicationIdentifier",
            "sourceMapIdentifier"
          ]
        }
      },
      {
        "name": "upload_source_map",
        "description": "Uploads a source map to the specified application",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            },
            "filePath": {
              "type": "string",
              "description": "Path to the source map file"
            },
            "uri": {
              "type": "string",
              "format": "uri",
              "description": "URI to associate with the source map"
            }
          },
          "required": [
            "applicationIdentifier",
            "filePath",
            "uri"
          ]
        }
      },
      {
        "name": "delete_all_source_maps",
        "description": "Deletes all source maps",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationIdentifier": {
              "type": "string",
              "description": "Application identifier"
            }
          },
          "required": [
            "applicationIdentifier"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "mcp-zenml": {
    "display_name": "ZenML MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/zenml-io/mcp-zenml"
    },
    "homepage": "https://zenml.io",
    "author": {
      "name": "zenml-io"
    },
    "license": "MIT",
    "tags": [
      "zenml",
      "mcp",
      "ai",
      "ml",
      "pipelines"
    ],
    "arguments": {
      "ZENML_STORE_URL": {
        "description": "URL of your ZenML server",
        "required": true,
        "example": "https://d534d987a-zenml.cloudinfra.zenml.io"
      },
      "ZENML_STORE_API_KEY": {
        "description": "API key for your ZenML server",
        "required": true,
        "example": "your-api-key-here"
      },
      "LOGLEVEL": {
        "description": "Logging level",
        "required": false,
        "example": "INFO"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "uv",
        "args": [
          "run",
          "path/to/zenml_server.py"
        ],
        "env": {
          "LOGLEVEL": "INFO",
          "NO_COLOR": "1",
          "PYTHONUNBUFFERED": "1",
          "PYTHONIOENCODING": "UTF-8",
          "ZENML_STORE_URL": "https://your-zenml-server-goes-here.com",
          "ZENML_STORE_API_KEY": "your-api-key-here"
        }
      }
    },
    "examples": [
      {
        "title": "Query ZenML Information",
        "description": "Ask about ZenML pipelines, runs, and other resources",
        "prompt": "Can you show me the latest pipeline runs in my ZenML server?"
      }
    ],
    "name": "mcp-zenml",
    "description": "Interact with your MLOps and LLMOps pipelines through your ZenML MCP server",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "travel-planner": {
    "name": "travel-planner",
    "display_name": "Travel Planner",
    "description": "Travel planning and itinerary management server integrating with Google Maps API for location search, place details, and route calculations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/TRAVEL-PLANNER-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/TRAVEL-PLANNER-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "google-maps",
      "travel-planning"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@gongrzhe/server-travelplanner-mcp"
        ],
        "env": {
          "GOOGLE_MAPS_API_KEY": "${GOOGLE_MAPS_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Search Places",
        "description": "Search for places using Google Places API",
        "prompt": "searchPlaces({ query: 'restaurants', location: '34.0522,-118.2437', radius: 5000 });"
      },
      {
        "title": "Get Place Details",
        "description": "Get detailed information about a specific place",
        "prompt": "getPlaceDetails({ placeId: 'ChIJN1t_tDeuEmsRUcIa02j2sDE' });"
      },
      {
        "title": "Calculate Route",
        "description": "Calculate route between two locations",
        "prompt": "calculateRoute({ origin: 'Los Angeles, CA', destination: 'San Francisco, CA', mode: 'driving' });"
      },
      {
        "title": "Get Time Zone",
        "description": "Get timezone information for a location",
        "prompt": "getTimeZone({ location: '34.0522,-118.2437' });"
      }
    ],
    "arguments": {
      "GOOGLE_MAPS_API_KEY": {
        "description": "Your Google Maps API key with the following APIs enabled: Places API, Directions API, Geocoding API, Time Zone API",
        "required": true,
        "example": "your_google_maps_api_key"
      }
    },
    "tools": [
      {
        "name": "create_itinerary",
        "description": "Creates a personalized travel itinerary based on user preferences",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "Starting location"
            },
            "destination": {
              "type": "string",
              "description": "Destination location"
            },
            "startDate": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD)"
            },
            "endDate": {
              "type": "string",
              "description": "End date (YYYY-MM-DD)"
            },
            "budget": {
              "type": "number",
              "description": "Budget in USD"
            },
            "preferences": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Travel preferences"
            }
          },
          "required": [
            "origin",
            "destination",
            "startDate",
            "endDate"
          ]
        }
      },
      {
        "name": "optimize_itinerary",
        "description": "Optimizes an existing itinerary based on specified criteria",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itineraryId": {
              "type": "string",
              "description": "ID of the itinerary to optimize"
            },
            "optimizationCriteria": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Criteria for optimization (time, cost, etc.)"
            }
          },
          "required": [
            "itineraryId",
            "optimizationCriteria"
          ]
        }
      },
      {
        "name": "search_attractions",
        "description": "Searches for attractions and points of interest in a specified location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "Location to search attractions"
            },
            "radius": {
              "type": "number",
              "description": "Search radius in meters"
            },
            "categories": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Categories of attractions"
            }
          },
          "required": [
            "location"
          ]
        }
      },
      {
        "name": "get_transport_options",
        "description": "Retrieves available transportation options between two points",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "Starting point"
            },
            "destination": {
              "type": "string",
              "description": "Destination point"
            },
            "date": {
              "type": "string",
              "description": "Travel date (YYYY-MM-DD)"
            }
          },
          "required": [
            "origin",
            "destination",
            "date"
          ]
        }
      },
      {
        "name": "get_accommodations",
        "description": "Searches for accommodation options in a specified location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "Location to search"
            },
            "checkIn": {
              "type": "string",
              "description": "Check-in date (YYYY-MM-DD)"
            },
            "checkOut": {
              "type": "string",
              "description": "Check-out date (YYYY-MM-DD)"
            },
            "budget": {
              "type": "number",
              "description": "Maximum price per night"
            }
          },
          "required": [
            "location",
            "checkIn",
            "checkOut"
          ]
        }
      }
    ]
  },
  "postgresql": {
    "name": "postgresql",
    "display_name": "PostgreSQL",
    "description": "Read-only database access with schema inspection",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "PostgreSQL",
      "Database",
      "Read-Only"
    ],
    "author": {
      "name": "modelcontextprotocol"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/postgres",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-postgres",
          "postgresql://localhost/mydb"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "mcp/postgres",
          "postgresql://host.docker.internal:5432/mydb"
        ]
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Run a read-only SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sql": {
              "type": "string"
            }
          }
        }
      }
    ],
    "is_official": true
  },
  "todoist": {
    "name": "todoist",
    "display_name": "Todoist",
    "description": "Interact with Todoist to manage your tasks.",
    "repository": {
      "type": "git",
      "url": "https://github.com/abhiz123/todoist-mcp-server"
    },
    "homepage": "https://github.com/abhiz123/todoist-mcp-server",
    "author": {
      "name": "abhiz123"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@abhiz123/todoist-mcp-server"
        ],
        "env": {
          "TODOIST_API_TOKEN": "${TODOIST_API_TOKEN}"
        }
      }
    },
    "tags": [
      "task management",
      "todoist",
      "natural language processing"
    ],
    "examples": [
      {
        "title": "Creating Tasks",
        "description": "Example commands for creating tasks",
        "prompt": "\"Create task 'Team Meeting'\""
      },
      {
        "title": "Getting Tasks",
        "description": "Example commands for retrieving tasks",
        "prompt": "\"Show all my tasks\""
      },
      {
        "title": "Updating Tasks",
        "description": "Example commands for updating tasks",
        "prompt": "\"Update documentation task to be due next week\""
      },
      {
        "title": "Completing Tasks",
        "description": "Example commands for completing tasks",
        "prompt": "\"Mark the PR review task as complete\""
      },
      {
        "title": "Deleting Tasks",
        "description": "Example commands for deleting tasks",
        "prompt": "\"Delete the PR review task\""
      }
    ],
    "arguments": {
      "TODOIST_API_TOKEN": {
        "description": "API token to authenticate with the Todoist service",
        "required": true,
        "example": "your_api_token_here"
      }
    },
    "tools": [
      {
        "name": "todoist_create_task",
        "description": "Create a new task in Todoist with optional description, due date, and priority",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content/title of the task"
            },
            "description": {
              "type": "string",
              "description": "Detailed description of the task (optional)"
            },
            "due_string": {
              "type": "string",
              "description": "Natural language due date like 'tomorrow', 'next Monday', 'Jan 23' (optional)"
            },
            "priority": {
              "type": "number",
              "description": "Task priority from 1 (normal) to 4 (urgent) (optional)",
              "enum": [
                1,
                2,
                3,
                4
              ]
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "todoist_get_tasks",
        "description": "Get a list of tasks from Todoist with various filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Filter tasks by project ID (optional)"
            },
            "filter": {
              "type": "string",
              "description": "Natural language filter like 'today', 'tomorrow', 'next week', 'priority 1', 'overdue' (optional)"
            },
            "priority": {
              "type": "number",
              "description": "Filter by priority level (1-4) (optional)",
              "enum": [
                1,
                2,
                3,
                4
              ]
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of tasks to return (optional)",
              "default": 10
            }
          }
        }
      },
      {
        "name": "todoist_update_task",
        "description": "Update an existing task in Todoist by searching for it by name and then updating it",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and update"
            },
            "content": {
              "type": "string",
              "description": "New content/title for the task (optional)"
            },
            "description": {
              "type": "string",
              "description": "New description for the task (optional)"
            },
            "due_string": {
              "type": "string",
              "description": "New due date in natural language like 'tomorrow', 'next Monday' (optional)"
            },
            "priority": {
              "type": "number",
              "description": "New priority level from 1 (normal) to 4 (urgent) (optional)",
              "enum": [
                1,
                2,
                3,
                4
              ]
            }
          },
          "required": [
            "task_name"
          ]
        }
      },
      {
        "name": "todoist_delete_task",
        "description": "Delete a task from Todoist by searching for it by name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and delete"
            }
          },
          "required": [
            "task_name"
          ]
        }
      },
      {
        "name": "todoist_complete_task",
        "description": "Mark a task as complete by searching for it by name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and complete"
            }
          },
          "required": [
            "task_name"
          ]
        }
      }
    ]
  },
  "ntfy-mcp": {
    "name": "ntfy-mcp",
    "display_name": "Your Friendly Task Completion Notifier",
    "description": "The MCP server that keeps you informed by sending the notification on phone using ntfy",
    "repository": {
      "type": "git",
      "url": "https://github.com/teddyzxcv/ntfy-mcp"
    },
    "homepage": "https://github.com/teddyzxcv/ntfy-mcp",
    "author": {
      "name": "teddyzxcv"
    },
    "license": "Apache License 2.0",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "ntfy",
      "notifications"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/teddyzxcv/ntfy-mcp"
        ],
        "env": {
          "NTFY_TOPIC": "${NTFY_TOPIC}"
        }
      }
    },
    "examples": [
      {
        "title": "Python Hello World",
        "description": "Write a prompt to execute a task and receive a notification upon completion.",
        "prompt": "Write me a hello world in python, notify me when the task is done"
      }
    ],
    "arguments": {
      "NTFY_TOPIC": {
        "description": "Environment variable representing the topic name for notifications to be sent to.",
        "required": true,
        "example": "your_topic_name"
      }
    }
  },
  "everart": {
    "name": "everart",
    "display_name": "EverArt",
    "description": "AI image generation using various models",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/everart",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "[NOT FOUND]",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "EverArt",
      "API",
      "Claude Desktop"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-everart"
        ],
        "env": {
          "EVERART_API_KEY": "${EVERART_API_KEY}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "EVERART_API_KEY",
          "mcp/everart"
        ],
        "env": {
          "EVERART_API_KEY": "${EVERART_API_KEY}"
        }
      }
    },
    "arguments": {
      "EVERART_API_KEY": {
        "description": "API key to access the EverArt API",
        "required": true,
        "example": "your_key_here"
      }
    },
    "tools": [
      {
        "name": "generate_image",
        "description": "Generate images using EverArt Models and returns a clickable link to view the generated image. The tool will return a URL that can be clicked to view the image in a browser. Available models:\n- 5000:FLUX1.1: Standard quality\n- 9000:FLUX1.1-ultra: Ultra high quality\n- 6000:SD3.5: Stable Diffusion 3.5\n- 7000:Recraft-Real: Photorealistic style\n- 8000:Recraft-Vector: Vector art style\n\nThe response will contain a direct link to view the generated image.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Text description of desired image"
            },
            "model": {
              "type": "string",
              "description": "Model ID (5000:FLUX1.1, 9000:FLUX1.1-ultra, 6000:SD3.5, 7000:Recraft-Real, 8000:Recraft-Vector)",
              "default": "5000"
            },
            "image_count": {
              "type": "number",
              "description": "Number of images to generate",
              "default": 1
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ],
    "is_official": true
  },
  "pushover": {
    "name": "pushover",
    "display_name": "Pushover Notifications",
    "description": "Send instant notifications to your devices using [Pushover.net](https://pushover.net/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/ashiknesin/pushover-mcp"
    },
    "homepage": "https://github.com/ashiknesin/pushover-mcp",
    "author": {
      "name": "ashiknesin"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "pushover",
      "notifications"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "pushover-mcp@latest",
          "start",
          "--token",
          "${YOUR_TOKEN}",
          "--user",
          "${YOUR_USER}"
        ]
      }
    },
    "arguments": {
      "YOUR_TOKEN": {
        "description": "Application token required for authenticating with Pushover.net",
        "required": true,
        "example": "abcdef123456"
      },
      "YOUR_USER": {
        "description": "User key associated with your Pushover.net account",
        "required": true,
        "example": "1234567890:abcdef123456"
      }
    },
    "tools": [
      {
        "name": "send",
        "description": "Send a notification via Pushover",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "minLength": 1
            },
            "title": {
              "type": "string"
            },
            "priority": {
              "type": "number",
              "minimum": -2,
              "maximum": 2
            },
            "sound": {
              "type": "string"
            },
            "url": {
              "type": "string",
              "format": "uri"
            },
            "url_title": {
              "type": "string"
            },
            "device": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ]
        }
      }
    ]
  },
  "memory": {
    "name": "memory",
    "display_name": "Knowledge Graph Memory",
    "description": "Knowledge graph-based persistent memory system",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/memory",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "knowledge graph",
      "memory",
      "persistent memory"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-memory"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "-v",
          "claude-memory:/app/dist",
          "--rm",
          "mcp/memory"
        ]
      }
    },
    "examples": [
      {
        "title": "Basic Memory Interaction",
        "description": "A simple interaction with memory where user details are remembered.",
        "prompt": "Remembering..."
      }
    ],
    "arguments": {
      "MEMORY_FILE_PATH": {
        "description": "Path to the memory storage JSON file (default: memory.json in the server directory)",
        "required": false,
        "example": "/path/to/custom/memory.json"
      }
    },
    "tools": [
      {
        "name": "create_entities",
        "description": "Create multiple new entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entities": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "The name of the entity"
                  },
                  "entityType": {
                    "type": "string",
                    "description": "The type of the entity"
                  },
                  "observations": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observation contents associated with the entity"
                  }
                },
                "required": [
                  "name",
                  "entityType",
                  "observations"
                ]
              }
            }
          },
          "required": [
            "entities"
          ]
        }
      },
      {
        "name": "create_relations",
        "description": "Create multiple new relations between entities in the knowledge graph. Relations should be in active voice",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "from": {
                    "type": "string",
                    "description": "The name of the entity where the relation starts"
                  },
                  "to": {
                    "type": "string",
                    "description": "The name of the entity where the relation ends"
                  },
                  "relationType": {
                    "type": "string",
                    "description": "The type of the relation"
                  }
                },
                "required": [
                  "from",
                  "to",
                  "relationType"
                ]
              }
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "add_observations",
        "description": "Add new observations to existing entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "observations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "entityName": {
                    "type": "string",
                    "description": "The name of the entity to add the observations to"
                  },
                  "contents": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observation contents to add"
                  }
                },
                "required": [
                  "entityName",
                  "contents"
                ]
              }
            }
          },
          "required": [
            "observations"
          ]
        }
      },
      {
        "name": "delete_entities",
        "description": "Delete multiple entities and their associated relations from the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entityNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of entity names to delete"
            }
          },
          "required": [
            "entityNames"
          ]
        }
      },
      {
        "name": "delete_observations",
        "description": "Delete specific observations from entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "deletions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "entityName": {
                    "type": "string",
                    "description": "The name of the entity containing the observations"
                  },
                  "observations": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observations to delete"
                  }
                },
                "required": [
                  "entityName",
                  "observations"
                ]
              }
            }
          },
          "required": [
            "deletions"
          ]
        }
      },
      {
        "name": "delete_relations",
        "description": "Delete multiple relations from the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "from": {
                    "type": "string",
                    "description": "The name of the entity where the relation starts"
                  },
                  "to": {
                    "type": "string",
                    "description": "The name of the entity where the relation ends"
                  },
                  "relationType": {
                    "type": "string",
                    "description": "The type of the relation"
                  }
                },
                "required": [
                  "from",
                  "to",
                  "relationType"
                ]
              },
              "description": "An array of relations to delete"
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "read_graph",
        "description": "Read the entire knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "search_nodes",
        "description": "Search for nodes in the knowledge graph based on a query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query to match against entity names, types, and observation content"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "open_nodes",
        "description": "Open specific nodes in the knowledge graph by their names",
        "inputSchema": {
          "type": "object",
          "properties": {
            "names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of entity names to retrieve"
            }
          },
          "required": [
            "names"
          ]
        }
      }
    ],
    "is_official": true
  },
  "elevenlabs": {
    "name": "elevenlabs",
    "display_name": "ElevenLabs",
    "description": "A server that integrates with ElevenLabs text-to-speech API capable of generating full voiceovers with multiple voices.",
    "repository": {
      "type": "git",
      "url": "https://github.com/mamertofabian/elevenlabs-mcp-server"
    },
    "homepage": "https://github.com/mamertofabian/elevenlabs-mcp-server",
    "author": {
      "name": "mamertofabian"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "ElevenLabs",
      "Text-to-Speech",
      "SvelteKit",
      "TTS"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "elevenlabs-mcp-server"
        ],
        "env": {
          "ELEVENLABS_API_KEY": "${ELEVENLABS_API_KEY}",
          "ELEVENLABS_VOICE_ID": "${ELEVENLABS_VOICE_ID}",
          "ELEVENLABS_MODEL_ID": "${ELEVENLABS_MODEL_ID}",
          "ELEVENLABS_STABILITY": "${ELEVENLABS_STABILITY}",
          "ELEVENLABS_SIMILARITY_BOOST": "${ELEVENLABS_SIMILARITY_BOOST}",
          "ELEVENLABS_STYLE": "${ELEVENLABS_STYLE}",
          "ELEVENLABS_OUTPUT_DIR": "${ELEVENLABS_OUTPUT_DIR}"
        }
      }
    },
    "arguments": {
      "ELEVENLABS_API_KEY": {
        "description": "Your API key for ElevenLabs to access the text-to-speech services.",
        "required": true,
        "example": "sk-12345abcd"
      },
      "ELEVENLABS_VOICE_ID": {
        "description": "The ID of the voice you want to use for synthesis.",
        "required": true,
        "example": "voice-12345"
      },
      "ELEVENLABS_MODEL_ID": {
        "description": "The model ID to be used, indicating the version of the ElevenLabs API to utilize.",
        "required": false,
        "example": "eleven_flash_v2"
      },
      "ELEVENLABS_STABILITY": {
        "description": "Stability of the voice generation; controls variations in the output voice.",
        "required": false,
        "example": "0.5"
      },
      "ELEVENLABS_SIMILARITY_BOOST": {
        "description": "Boosting similarity for the voices; affects how closely the output mimics the selected voice.",
        "required": false,
        "example": "0.75"
      },
      "ELEVENLABS_STYLE": {
        "description": "Style parameter to adjust the expression in the generated speech.",
        "required": false,
        "example": "0.1"
      },
      "ELEVENLABS_OUTPUT_DIR": {
        "description": "Directory path where the generated audio files will be saved.",
        "required": false,
        "example": "output"
      }
    },
    "tools": [
      {
        "name": "generate_audio_simple",
        "description": "Generate audio from plain text using default voice settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Plain text to convert to audio"
            },
            "voice_id": {
              "type": "string",
              "description": "Optional voice ID to use for generation"
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "generate_audio_script",
        "description": "Generate audio from a structured script with multiple voices and actors. \n                    Accepts either:\n                    1. Plain text string\n                    2. JSON string with format: {\n                        \"script\": [\n                            {\n                                \"text\": \"Text to speak\",\n                                \"voice_id\": \"optional-voice-id\",\n                                \"actor\": \"optional-actor-name\"\n                            },\n                            ...\n                        ]\n                    }",
        "inputSchema": {
          "type": "object",
          "properties": {
            "script": {
              "type": "string",
              "description": "JSON string containing script array or plain text. For JSON format, provide an object with a 'script' array containing objects with 'text' (required), 'voice_id' (optional), and 'actor' (optional) fields."
            }
          },
          "required": [
            "script"
          ]
        }
      },
      {
        "name": "delete_job",
        "description": "Delete a voiceover job and its associated files",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "ID of the job to delete"
            }
          },
          "required": [
            "job_id"
          ]
        }
      },
      {
        "name": "get_audio_file",
        "description": "Get the audio file content for a specific job",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "ID of the job to get audio file for"
            }
          },
          "required": [
            "job_id"
          ]
        }
      },
      {
        "name": "list_voices",
        "description": "Get a list of all available ElevenLabs voices with metadata",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_voiceover_history",
        "description": "Get voiceover job history. Optionally specify a job ID for a specific job.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "Optional job ID to get details for a specific job"
            }
          },
          "required": []
        }
      }
    ]
  },
  "airbnb": {
    "name": "airbnb",
    "display_name": "Airbnb",
    "description": "Provides tools to search Airbnb and get listing details.",
    "repository": {
      "type": "git",
      "url": "https://github.com/openbnb-org/mcp-server-airbnb"
    },
    "homepage": "https://github.com/openbnb-org/mcp-server-airbnb",
    "author": {
      "name": "openbnb-org"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Airbnb",
      "search",
      "listings"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@openbnb/mcp-server-airbnb"
        ],
        "description": "Run with npx (requires npm install)"
      }
    },
    "examples": [
      {
        "title": "Search for Airbnb Listings",
        "description": "Search for listings in a specified location.",
        "prompt": "Search for listings in New York"
      },
      {
        "title": "Get Listing Details",
        "description": "Retrieve details for a specific listing.",
        "prompt": "Get details for listing 12345"
      }
    ],
    "arguments": {
      "location": {
        "description": "The location where you want to search for Airbnb listings",
        "required": true,
        "example": "New York City"
      },
      "placeId": {
        "description": "The unique identifier for a specific place or location",
        "required": false,
        "example": "ChIJN1t_tDeuEmsRUsoyG83frY4"
      },
      "checkin": {
        "description": "The check-in date for your stay in YYYY-MM-DD format",
        "required": false,
        "example": "2023-10-01"
      },
      "checkout": {
        "description": "The check-out date for your stay in YYYY-MM-DD format",
        "required": false,
        "example": "2023-10-05"
      },
      "adults": {
        "description": "The number of adults staying",
        "required": false,
        "example": "2"
      },
      "children": {
        "description": "The number of children staying",
        "required": false,
        "example": "1"
      },
      "infants": {
        "description": "The number of infants staying",
        "required": false,
        "example": "1"
      },
      "pets": {
        "description": "The number of pets allowed in the listing",
        "required": false,
        "example": "2"
      },
      "minPrice": {
        "description": "The minimum price per night for the listings",
        "required": false,
        "example": "50"
      },
      "maxPrice": {
        "description": "The maximum price per night for the listings",
        "required": false,
        "example": "300"
      },
      "cursor": {
        "description": "A cursor for paginating through results",
        "required": false,
        "example": "next-page-token"
      },
      "ignoreRobotsText": {
        "description": "Set to true to disregard Airbnb's robots.txt rules for all requests",
        "required": false,
        "example": "true"
      }
    },
    "tools": [
      {
        "name": "airbnb_search",
        "description": "Search for Airbnb listings with various filters and pagination. Provide direct links to the user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "Location to search for (city, state, etc.)"
            },
            "placeId": {
              "type": "string",
              "description": "Google Maps Place ID (overrides the location parameter)"
            },
            "checkin": {
              "type": "string",
              "description": "Check-in date (YYYY-MM-DD)"
            },
            "checkout": {
              "type": "string",
              "description": "Check-out date (YYYY-MM-DD)"
            },
            "adults": {
              "type": "number",
              "description": "Number of adults"
            },
            "children": {
              "type": "number",
              "description": "Number of children"
            },
            "infants": {
              "type": "number",
              "description": "Number of infants"
            },
            "pets": {
              "type": "number",
              "description": "Number of pets"
            },
            "minPrice": {
              "type": "number",
              "description": "Minimum price for the stay"
            },
            "maxPrice": {
              "type": "number",
              "description": "Maximum price for the stay"
            },
            "cursor": {
              "type": "string",
              "description": "Base64-encoded string used for Pagination"
            },
            "ignoreRobotsText": {
              "type": "boolean",
              "description": "Ignore robots.txt rules for this request"
            }
          },
          "required": [
            "location"
          ]
        }
      },
      {
        "name": "airbnb_listing_details",
        "description": "Get detailed information about a specific Airbnb listing. Provide direct links to the user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Airbnb listing ID"
            },
            "checkin": {
              "type": "string",
              "description": "Check-in date (YYYY-MM-DD)"
            },
            "checkout": {
              "type": "string",
              "description": "Check-out date (YYYY-MM-DD)"
            },
            "adults": {
              "type": "number",
              "description": "Number of adults"
            },
            "children": {
              "type": "number",
              "description": "Number of children"
            },
            "infants": {
              "type": "number",
              "description": "Number of infants"
            },
            "pets": {
              "type": "number",
              "description": "Number of pets"
            },
            "ignoreRobotsText": {
              "type": "boolean",
              "description": "Ignore robots.txt rules for this request"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  "prometheus": {
    "name": "prometheus",
    "display_name": "Prometheus",
    "description": "Query and analyze Prometheus - open-source monitoring system.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pab1it0/prometheus-mcp-server"
    },
    "homepage": "https://github.com/pab1it0/prometheus-mcp-server",
    "author": {
      "name": "pab1it0"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Prometheus",
      "Metrics",
      "AI"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pab1it0/prometheus-mcp-server",
          "prometheus-mcp-server"
        ],
        "env": {
          "PROMETHEUS_URL": "${PROMETHEUS_URL}",
          "PROMETHEUS_USERNAME": "${PROMETHEUS_USERNAME}",
          "PROMETHEUS_PASSWORD": "${PROMETHEUS_PASSWORD}"
        }
      }
    },
    "examples": [
      {
        "title": "Execute Query",
        "description": "Execute a PromQL instant query against Prometheus",
        "prompt": "execute_query({ query: \"up\" })"
      },
      {
        "title": "List Metrics",
        "description": "Get a list of metrics from Prometheus",
        "prompt": "list_metrics()"
      }
    ],
    "arguments": {
      "PROMETHEUS_URL": {
        "description": "The URL of the Prometheus server you want to connect to.",
        "required": true,
        "example": "http://your-prometheus-server:9090"
      },
      "PROMETHEUS_USERNAME": {
        "description": "The username for basic authentication when accessing the Prometheus server.",
        "required": false,
        "example": "your_username"
      },
      "PROMETHEUS_PASSWORD": {
        "description": "The password for basic authentication when accessing the Prometheus server.",
        "required": false,
        "example": "your_password"
      }
    },
    "tools": [
      {
        "name": "execute_query",
        "description": "Execute a PromQL instant query against Prometheus",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "time": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Time"
            }
          },
          "required": [
            "query"
          ],
          "title": "execute_queryArguments",
          "type": "object"
        }
      },
      {
        "name": "execute_range_query",
        "description": "Execute a PromQL range query with start time, end time, and step interval",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "start": {
              "title": "Start",
              "type": "string"
            },
            "end": {
              "title": "End",
              "type": "string"
            },
            "step": {
              "title": "Step",
              "type": "string"
            }
          },
          "required": [
            "query",
            "start",
            "end",
            "step"
          ],
          "title": "execute_range_queryArguments",
          "type": "object"
        }
      },
      {
        "name": "list_metrics",
        "description": "List all available metrics in Prometheus",
        "inputSchema": {
          "properties": {},
          "title": "list_metricsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_metric_metadata",
        "description": "Get metadata for a specific metric",
        "inputSchema": {
          "properties": {
            "metric": {
              "title": "Metric",
              "type": "string"
            }
          },
          "required": [
            "metric"
          ],
          "title": "get_metric_metadataArguments",
          "type": "object"
        }
      },
      {
        "name": "get_targets",
        "description": "Get information about all scrape targets",
        "inputSchema": {
          "properties": {},
          "title": "get_targetsArguments",
          "type": "object"
        }
      }
    ]
  },
  "searxng": {
    "name": "searxng",
    "display_name": "SearXNG",
    "description": "A Model Context Protocol Server for [SearXNG](https://docs.searxng.org/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/ihor-sokoliuk/mcp-searxng"
    },
    "homepage": "https://github.com/ihor-sokoliuk/mcp-searxng",
    "author": {
      "name": "ihor-sokoliuk"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "search",
      "searxng",
      "api"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/ihor-sokoliuk/mcp-searxng"
        ],
        "env": {
          "SEARXNG_URL": "${SEARXNG_URL}"
        }
      }
    },
    "arguments": {
      "SEARXNG_URL": {
        "description": "Environment variable to set the URL of the SearXNG instance that will be used for search queries.",
        "required": true,
        "example": "http://localhost:8080"
      }
    },
    "tools": [
      {
        "name": "searxng_web_search",
        "description": "Execute web searches with pagination.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search terms"
          },
          "count": {
            "type": "number",
            "description": "Results per page (default: 20)",
            "optional": true
          },
          "offset": {
            "type": "number",
            "description": "Pagination offset (default: 0)",
            "optional": true
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "greptimedb-mcp-server": {
    "display_name": "GreptimeDB MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/GreptimeTeam/greptimedb-mcp-server"
    },
    "homepage": "https://github.com/GreptimeTeam/greptimedb-mcp-server",
    "author": {
      "name": "GreptimeTeam"
    },
    "license": "MIT",
    "tags": [
      "database",
      "sql",
      "greptimedb",
      "mcp"
    ],
    "arguments": {
      "GREPTIMEDB_HOST": {
        "description": "Database host",
        "required": true,
        "example": "localhost"
      },
      "GREPTIMEDB_PORT": {
        "description": "Database port",
        "required": false,
        "example": "4002"
      },
      "GREPTIMEDB_USER": {
        "description": "Database username",
        "required": true,
        "example": "root"
      },
      "GREPTIMEDB_PASSWORD": {
        "description": "Database password",
        "required": true,
        "example": ""
      },
      "GREPTIMEDB_DATABASE": {
        "description": "Database name",
        "required": true,
        "example": "public"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "greptimedb-mcp-server"
        ],
        "env": {
          "GREPTIMEDB_HOST": "localhost",
          "GREPTIMEDB_PORT": "4002",
          "GREPTIMEDB_USER": "root",
          "GREPTIMEDB_PASSWORD": "",
          "GREPTIMEDB_DATABASE": "public"
        }
      }
    },
    "examples": [
      {
        "title": "Basic Usage",
        "description": "Connect to GreptimeDB and explore tables",
        "prompt": "Connect to my GreptimeDB instance and list all available tables."
      }
    ],
    "name": "greptimedb-mcp-server",
    "description": "A Model Context Protocol (MCP) server implementation for [GreptimeDB](https://github.com/GreptimeTeam/greptimedb).",
    "categories": [
      "Databases"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute an SQL query on the GreptimeDB server",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "pinecone": {
    "name": "pinecone",
    "display_name": "Pinecone Model Context Protocol for Claude Desktop",
    "description": "MCP server for searching and uploading records to Pinecone. Allows for simple RAG features, leveraging Pinecone's Inference API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sirmews/mcp-pinecone"
    },
    "homepage": "https://github.com/sirmews/mcp-pinecone",
    "author": {
      "name": "sirmews"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "pinecone"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-pinecone",
          "--index-name",
          "${your-index-name}",
          "--api-key",
          "${your-secret-api-key}"
        ]
      }
    },
    "tools": [
      {
        "name": "semantic_search",
        "description": "Search Pinecone for documents.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query"
          },
          "top_k": {
            "type": "integer",
            "description": "Number of top results to return (default: 10)",
            "default": 10
          },
          "namespace": {
            "type": "string",
            "description": "Optional namespace to search in",
            "optional": true
          },
          "category": {
            "type": "string",
            "description": "Category for search"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags for search"
          },
          "date_range": {
            "type": "object",
            "properties": {
              "start": {
                "type": "string",
                "format": "date",
                "description": "Start date of the range"
              },
              "end": {
                "type": "string",
                "format": "date",
                "description": "End date of the range"
              }
            }
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "read_document",
        "description": "Read a document from Pinecone.",
        "inputSchema": {
          "document_id": {
            "type": "string",
            "description": "ID of the document to read"
          },
          "namespace": {
            "type": "string",
            "description": "Optional namespace to read from",
            "optional": true
          }
        },
        "required": [
          "document_id"
        ]
      },
      {
        "name": "process_document",
        "description": "Process a document. This will optionally chunk, then embed, and upsert the document into Pinecone.",
        "inputSchema": {
          "document_id": {
            "type": "string",
            "description": "ID of the document to process"
          },
          "text": {
            "type": "string",
            "description": "Text content of the document"
          },
          "metadata": {
            "type": "object",
            "description": "Metadata for the document"
          },
          "namespace": {
            "type": "string",
            "description": "Optional namespace to store the document in",
            "optional": true
          }
        },
        "required": [
          "document_id",
          "text",
          "metadata"
        ]
      },
      {
        "name": "list_documents",
        "description": "List all documents in the knowledge base by namespace.",
        "inputSchema": {
          "namespace": {
            "type": "string",
            "description": "Namespace to list documents in"
          }
        },
        "required": [
          "namespace"
        ]
      },
      {
        "name": "pinecone_stats",
        "description": "Get stats about the Pinecone index specified in this server.",
        "inputSchema": {},
        "required": []
      }
    ]
  },
  "atlassian": {
    "name": "atlassian",
    "display_name": "Atlassian",
    "description": "Interact with Atlassian Cloud products (Confluence and Jira) including searching/reading Confluence spaces/pages, accessing Jira issues, and project metadata.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sooperset/mcp-atlassian"
    },
    "homepage": "https://github.com/sooperset/mcp-atlassian",
    "author": {
      "name": "sooperset"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Atlassian",
      "Confluence",
      "Jira"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-atlassian",
          "--confluence-url=${CONFLUENCE_URL}",
          "--confluence-username=${CONFLUENCE_USERNAME}",
          "--confluence-token=${CONFLUENCE_TOKEN}",
          "--jira-url=${JIRA_URL}",
          "--jira-username=${JIRA_USERNAME}",
          "--jira-token=${JIRA_TOKEN}"
        ],
        "description": "Run with uvx (requires uv install)"
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp-atlassian",
          "--confluence-url=${CONFLUENCE_URL}",
          "--confluence-username=${CONFLUENCE_USERNAME}",
          "--confluence-token=${CONFLUENCE_TOKEN}",
          "--jira-url=${JIRA_URL}",
          "--jira-username=${JIRA_USERNAME}",
          "--jira-token=${JIRA_TOKEN}"
        ],
        "description": "Run with Python module (requires pip install)"
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/atlassian",
          "--confluence-url=${CONFLUENCE_URL}",
          "--confluence-username=${CONFLUENCE_USERNAME}",
          "--confluence-token=${CONFLUENCE_TOKEN}",
          "--jira-url=${JIRA_URL}",
          "--jira-username=${JIRA_USERNAME}",
          "--jira-token=${JIRA_TOKEN}"
        ]
      }
    },
    "arguments": {
      "CONFLUENCE_URL": {
        "description": "The URL of the Confluence site to connect to. Required for both Cloud and Server/Data Center deployments.",
        "required": true,
        "example": "https://your-company.atlassian.net/wiki or https://confluence.your-company.com"
      },
      "CONFLUENCE_USERNAME": {
        "description": "The username for the Confluence account (email for Cloud). Required to authenticate with Confluence.",
        "required": true,
        "example": "your.email@company.com"
      },
      "CONFLUENCE_TOKEN": {
        "description": "The API token or personal access token for the Confluence account. Required for authentication with Confluence.",
        "required": true,
        "example": "your_api_token or your_token"
      },
      "JIRA_URL": {
        "description": "The URL of the Jira site to connect to. Required for both Cloud and Server/Data Center deployments.",
        "required": true,
        "example": "https://your-company.atlassian.net or https://jira.your-company.com"
      },
      "JIRA_USERNAME": {
        "description": "The username for the Jira account (email for Cloud). Required to authenticate with Jira.",
        "required": true,
        "example": "your.email@company.com"
      },
      "JIRA_TOKEN": {
        "description": "The API token or personal access token for the Jira account. Required for authentication with Jira.",
        "required": true,
        "example": "your_api_token or your_token"
      }
    },
    "tools": []
  },
  "mcp-server-browserbase": {
    "display_name": "Browserbase MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/browserbase/mcp-server-browserbase"
    },
    "license": "[NOT GIVEN]",
    "homepage": "https://www.browserbase.com/",
    "author": {
      "name": "browserbase"
    },
    "tags": [
      "browser automation",
      "puppeteer",
      "stagehand",
      "web interaction",
      "screenshots",
      "javascript"
    ],
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "src/build/dist/index.js"
        ],
        "description": "Run using Node.js"
      }
    },
    "name": "mcp-server-browserbase",
    "description": "Automate browser interactions in the cloud (e.g. web navigation, data extraction, form filling, and more)",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "open-strategy-partners-marketing-tools": {
    "name": "open-strategy-partners-marketing-tools",
    "display_name": "Open Strategy Partners Marketing Tools",
    "description": "Content editing codes, value map, and positioning tools for product marketing.",
    "repository": {
      "type": "git",
      "url": "https://github.com/open-strategy-partners/osp_marketing_tools"
    },
    "homepage": "https://github.com/open-strategy-partners/osp_marketing_tools",
    "author": {
      "name": "open-strategy-partners"
    },
    "license": "CC-BY-SA-4.0",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "LLM",
      "Technical Writing",
      "Optimization"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/open-strategy-partners/osp_marketing_tools@main",
          "osp_marketing_tools"
        ]
      }
    },
    "examples": [
      {
        "title": "Value Map Generation",
        "description": "Generate an OSP value map for a product with specified features for a target audience.",
        "prompt": "Generate an OSP value map for CloudDeploy, focusing on DevOps engineers with these key features: - Automated deployment pipeline - Infrastructure as code support - Real-time monitoring - Multi-cloud compatibility."
      },
      {
        "title": "Meta Information Creation",
        "description": "Create optimized metadata for an article based on a specific topic and audience.",
        "prompt": "Use the OSP meta tool to generate metadata for an article about containerization best practices. Primary keyword: 'Docker containers', audience: system administrators, content type: technical guide."
      },
      {
        "title": "Content Editing",
        "description": "Review technical content using OSP editing codes for improvements.",
        "prompt": "Review this technical content using OSP editing codes: Kubernetes helps you manage containers. It's really good at what it does. You can use it to deploy your apps and make them run better."
      },
      {
        "title": "Technical Writing",
        "description": "Apply the OSP writing guide to create a document for a specific audience.",
        "prompt": "Apply the OSP writing guide to create a tutorial about setting up a CI/CD pipeline for junior developers."
      }
    ],
    "tools": [
      {
        "name": "health_check",
        "description": "Check if the server is running and can access its resources",
        "inputSchema": {
          "properties": {},
          "title": "health_checkArguments",
          "type": "object"
        }
      },
      {
        "name": "get_editing_codes",
        "description": "Get the Open Strategy Partners (OSP) editing codes documentation and usage protocol for editing texts.",
        "inputSchema": {
          "properties": {},
          "title": "get_editing_codesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_writing_guide",
        "description": "Get the Open Strategy Partners (OSP) writing guide and usage protocol for editing texts.",
        "inputSchema": {
          "properties": {},
          "title": "get_writing_guideArguments",
          "type": "object"
        }
      },
      {
        "name": "get_meta_guide",
        "description": "Get the Open Strategy Partners (OSP) Web Content Meta Information Generation System (titles, meta-titles, slugs).",
        "inputSchema": {
          "properties": {},
          "title": "get_meta_guideArguments",
          "type": "object"
        }
      },
      {
        "name": "get_value_map_positioning_guide",
        "description": "Get the Open Strategy Partners (OSP) Product Communications Value Map Generation System for Product Positioning (value cases, feature extraction, taglines).",
        "inputSchema": {
          "properties": {},
          "title": "get_value_map_positioning_guideArguments",
          "type": "object"
        }
      },
      {
        "name": "get_on_page_seo_guide",
        "description": "Get the Open Strategy Partners (OSP) On-Page SEO Optimization Guide.",
        "inputSchema": {
          "properties": {},
          "title": "get_on_page_seo_guideArguments",
          "type": "object"
        }
      }
    ]
  },
  "mongodb-lens": {
    "name": "mongodb-lens",
    "display_name": "MongoDB Lens",
    "description": "Full Featured MCP Server for MongoDB Databases.",
    "repository": {
      "type": "git",
      "url": "https://github.com/furey/mongodb-lens"
    },
    "homepage": "https://github.com/furey/mongodb-lens",
    "author": {
      "name": "furey"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "mongodb",
      "server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mongodb-lens@latest",
          "${MONGODB_URI}"
        ],
        "env": {
          "CONFIG_LOG_LEVEL": "${CONFIG_LOG_LEVEL}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "--network=host",
          "--pull=always",
          "-e",
          "CONFIG_LOG_LEVEL='verbose'",
          "furey/mongodb-lens",
          "${MONGODB_URI}"
        ],
        "env": {
          "CONFIG_LOG_LEVEL": "${CONFIG_LOG_LEVEL}"
        }
      }
    },
    "arguments": {
      "CONFIG_LOG_LEVEL": {
        "description": "Sets the logging level of MongoDB Lens, controlling the verbosity of log output.",
        "required": false,
        "example": "verbose"
      },
      "MONGODB_URI": {
        "description": "The connection string for the MongoDB database.",
        "required": true,
        "example": "mongodb://your-connection-string"
      }
    },
    "tools": [
      {
        "name": "connect-mongodb",
        "description": "Connect to a different MongoDB URI or alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "uri": {
              "type": "string",
              "minLength": 1,
              "description": "MongoDB connection URI or alias to connect to"
            },
            "validateConnection": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "true",
              "description": "Whether to validate the connection"
            }
          },
          "required": [
            "uri"
          ]
        }
      },
      {
        "name": "connect-original",
        "description": "Connect back to the original MongoDB URI used at startup",
        "inputSchema": {
          "type": "object",
          "properties": {
            "validateConnection": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "true",
              "description": "Whether to validate the connection"
            }
          }
        }
      },
      {
        "name": "add-connection-alias",
        "description": "Add a new MongoDB connection alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "alias": {
              "type": "string",
              "minLength": 1,
              "description": "Alias name for the connection"
            },
            "uri": {
              "type": "string",
              "minLength": 1,
              "description": "MongoDB connection URI"
            }
          },
          "required": [
            "alias",
            "uri"
          ]
        }
      },
      {
        "name": "list-connections",
        "description": "List all configured MongoDB connection aliases",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "list-databases",
        "description": "List all accessible MongoDB databases",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "current-database",
        "description": "Get the name of the current database",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "create-database",
        "description": "Create a new MongoDB database with option to switch",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Database name to create"
            },
            "switch": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Whether to switch to the new database after creation"
            },
            "validateName": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "true",
              "description": "Whether to validate database name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "use-database",
        "description": "Switch to a specific database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "minLength": 1,
              "description": "Database name to use"
            }
          },
          "required": [
            "database"
          ]
        }
      },
      {
        "name": "drop-database",
        "description": "Drop a database (requires confirmation)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Database name to drop"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create-user",
        "description": "Create a new database user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1,
              "description": "Username"
            },
            "password": {
              "type": "string",
              "minLength": 1,
              "description": "Password"
            },
            "roles": {
              "type": "string",
              "description": "Roles as JSON array, e.g. [{\"role\": \"readWrite\", \"db\": \"mydb\"}]"
            }
          },
          "required": [
            "username",
            "password",
            "roles"
          ]
        }
      },
      {
        "name": "drop-user",
        "description": "Drop an existing database user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1,
              "description": "Username to drop"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "list-collections",
        "description": "List collections in the current database",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "create-collection",
        "description": "Create a new collection with options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "options": {
              "type": "string",
              "default": "{}",
              "description": "Collection options as JSON string (capped, size, etc.)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "drop-collection",
        "description": "Drop a collection (requires confirmation)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name to drop"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "rename-collection",
        "description": "Rename an existing collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "oldName": {
              "type": "string",
              "minLength": 1,
              "description": "Current collection name"
            },
            "newName": {
              "type": "string",
              "minLength": 1,
              "description": "New collection name"
            },
            "dropTarget": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Whether to drop target collection if it exists"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "oldName",
            "newName"
          ]
        }
      },
      {
        "name": "validate-collection",
        "description": "Run validation on a collection to check for inconsistencies",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "full": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Perform full validation (slower but more thorough)"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "distinct-values",
        "description": "Get unique values for a field",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "field": {
              "type": "string",
              "minLength": 1,
              "description": "Field name to get distinct values for"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "Optional filter as JSON string"
            }
          },
          "required": [
            "collection",
            "field"
          ]
        }
      },
      {
        "name": "find-documents",
        "description": "Run queries with filters and projections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "MongoDB query filter (JSON string)"
            },
            "projection": {
              "type": "string",
              "description": "Fields to include/exclude (JSON string)"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 10,
              "description": "Maximum number of documents to return"
            },
            "skip": {
              "type": "integer",
              "minimum": 0,
              "default": 0,
              "description": "Number of documents to skip"
            },
            "sort": {
              "type": "string",
              "description": "Sort specification (JSON string)"
            },
            "streaming": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Enable streaming for large result sets"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "count-documents",
        "description": "Count documents with optional filter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "MongoDB query filter (JSON string)"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "insert-document",
        "description": "Insert one or multiple documents into a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "document": {
              "type": "string",
              "description": "Document as JSON string or array of documents"
            },
            "options": {
              "type": "string",
              "description": "Options as JSON string (including \"ordered\" for multiple documents)"
            }
          },
          "required": [
            "collection",
            "document"
          ]
        }
      },
      {
        "name": "update-document",
        "description": "Update specific documents in a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "description": "Filter as JSON string"
            },
            "update": {
              "type": "string",
              "description": "Update operations as JSON string"
            },
            "options": {
              "type": "string",
              "description": "Options as JSON string"
            }
          },
          "required": [
            "collection",
            "filter",
            "update"
          ]
        }
      },
      {
        "name": "delete-document",
        "description": "Delete document(s) (requires confirmation)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "minLength": 1,
              "description": "Filter as JSON string"
            },
            "many": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Delete multiple documents if true"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "collection",
            "filter"
          ]
        }
      },
      {
        "name": "aggregate-data",
        "description": "Run aggregation pipelines",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "pipeline": {
              "type": "string",
              "description": "Aggregation pipeline as JSON string array"
            },
            "streaming": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Enable streaming results for large datasets"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 1000,
              "description": "Maximum number of results to return when streaming"
            }
          },
          "required": [
            "collection",
            "pipeline"
          ]
        }
      },
      {
        "name": "create-index",
        "description": "Create new index on collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "keys": {
              "type": "string",
              "description": "Index keys as JSON object"
            },
            "options": {
              "type": "string",
              "description": "Index options as JSON object"
            }
          },
          "required": [
            "collection",
            "keys"
          ]
        }
      },
      {
        "name": "drop-index",
        "description": "Drop an existing index from a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "indexName": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the index to drop"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "collection",
            "indexName"
          ]
        }
      },
      {
        "name": "get-stats",
        "description": "Get database or collection statistics",
        "inputSchema": {
          "type": "object",
          "properties": {
            "target": {
              "type": "string",
              "enum": [
                "database",
                "collection"
              ],
              "description": "Target type"
            },
            "name": {
              "type": "string",
              "description": "Collection name (for collection stats)"
            }
          },
          "required": [
            "target"
          ]
        }
      },
      {
        "name": "analyze-schema",
        "description": "Automatically infer schema from collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "sampleSize": {
              "type": "integer",
              "minimum": 1,
              "default": 100,
              "description": "Number of documents to sample"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "generate-schema-validator",
        "description": "Generate a JSON Schema validator for a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "strictness": {
              "type": "string",
              "enum": [
                "strict",
                "moderate",
                "relaxed"
              ],
              "default": "moderate",
              "description": "Validation strictness level"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "compare-schemas",
        "description": "Compare schemas between two collections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sourceCollection": {
              "type": "string",
              "minLength": 1,
              "description": "Source collection name"
            },
            "targetCollection": {
              "type": "string",
              "minLength": 1,
              "description": "Target collection name"
            },
            "sampleSize": {
              "type": "integer",
              "minimum": 1,
              "default": 100,
              "description": "Number of documents to sample"
            }
          },
          "required": [
            "sourceCollection",
            "targetCollection"
          ]
        }
      },
      {
        "name": "explain-query",
        "description": "Analyze query performance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "description": "MongoDB query filter (JSON string)"
            },
            "verbosity": {
              "type": "string",
              "enum": [
                "queryPlanner",
                "executionStats",
                "allPlansExecution"
              ],
              "default": "executionStats",
              "description": "Explain verbosity level"
            }
          },
          "required": [
            "collection",
            "filter"
          ]
        }
      },
      {
        "name": "analyze-query-patterns",
        "description": "Analyze query patterns and suggest optimizations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name to analyze"
            },
            "duration": {
              "type": "integer",
              "minimum": 1,
              "maximum": 60,
              "default": 10,
              "description": "Duration to analyze in seconds"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "bulk-operations",
        "description": "Perform bulk inserts, updates, or deletes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "operations": {
              "type": "string",
              "description": "Array of operations as JSON string"
            },
            "ordered": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "true",
              "description": "Whether operations should be performed in order"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "collection",
            "operations"
          ]
        }
      },
      {
        "name": "create-timeseries",
        "description": "Create a time series collection for temporal data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "timeField": {
              "type": "string",
              "minLength": 1,
              "description": "Field that contains the time value"
            },
            "metaField": {
              "type": "string",
              "description": "Field that contains metadata for grouping"
            },
            "granularity": {
              "type": "string",
              "enum": [
                "seconds",
                "minutes",
                "hours"
              ],
              "default": "seconds",
              "description": "Time series granularity"
            },
            "expireAfterSeconds": {
              "type": "integer",
              "description": "Optional TTL in seconds"
            }
          },
          "required": [
            "name",
            "timeField"
          ]
        }
      },
      {
        "name": "collation-query",
        "description": "Find documents with language-specific collation rules",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "Query filter as JSON string"
            },
            "locale": {
              "type": "string",
              "minLength": 2,
              "description": "Locale code (e.g., \"en\", \"fr\", \"de\")"
            },
            "strength": {
              "type": "integer",
              "minimum": 1,
              "maximum": 5,
              "default": 3,
              "description": "Collation strength (1-5)"
            },
            "caseLevel": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Consider case in first-level differences"
            },
            "sort": {
              "type": "string",
              "description": "Sort specification as JSON string"
            }
          },
          "required": [
            "collection",
            "locale"
          ]
        }
      },
      {
        "name": "text-search",
        "description": "Perform full-text search across text-indexed fields",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "searchText": {
              "type": "string",
              "minLength": 1,
              "description": "Text to search for"
            },
            "language": {
              "type": "string",
              "description": "Optional language for text search"
            },
            "caseSensitive": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Case sensitive search"
            },
            "diacriticSensitive": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Diacritic sensitive search"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 10,
              "description": "Maximum results to return"
            }
          },
          "required": [
            "collection",
            "searchText"
          ]
        }
      },
      {
        "name": "geo-query",
        "description": "Run geospatial queries with various operators",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "operator": {
              "type": "string",
              "enum": [
                "near",
                "geoWithin",
                "geoIntersects"
              ],
              "description": "Geospatial operator type"
            },
            "field": {
              "type": "string",
              "minLength": 1,
              "description": "Geospatial field name"
            },
            "geometry": {
              "type": "string",
              "description": "GeoJSON geometry as JSON string"
            },
            "maxDistance": {
              "type": "number",
              "description": "Maximum distance in meters (for near queries)"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 10,
              "description": "Maximum number of documents to return"
            }
          },
          "required": [
            "collection",
            "operator",
            "field",
            "geometry"
          ]
        }
      },
      {
        "name": "transaction",
        "description": "Execute multiple operations in a single transaction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "operations": {
              "type": "string",
              "description": "JSON array of operations with collection, operation type, and parameters"
            }
          },
          "required": [
            "operations"
          ]
        }
      },
      {
        "name": "map-reduce",
        "description": "Run Map-Reduce operations (note: Map-Reduce deprecated as of MongoDB 5.0)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "map": {
              "type": "string",
              "description": "Map function as string e.g. \"function() { emit(this.field, 1); }\""
            },
            "reduce": {
              "type": "string",
              "description": "Reduce function as string e.g. \"function(key, values) { return Array.sum(values); }\""
            },
            "options": {
              "type": "string",
              "description": "Options as JSON string (query, limit, etc.)"
            }
          },
          "required": [
            "collection",
            "map",
            "reduce"
          ]
        }
      },
      {
        "name": "watch-changes",
        "description": "Watch for changes in a collection using change streams",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "operations": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "insert",
                  "update",
                  "delete",
                  "replace"
                ]
              },
              "default": [
                "insert",
                "update",
                "delete"
              ],
              "description": "Operations to watch"
            },
            "duration": {
              "type": "integer",
              "minimum": 1,
              "maximum": 60,
              "default": 10,
              "description": "Duration to watch in seconds"
            },
            "fullDocument": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Include full document in update events"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "gridfs-operation",
        "description": "Manage large files with GridFS",
        "inputSchema": {
          "type": "object",
          "properties": {
            "operation": {
              "type": "string",
              "enum": [
                "list",
                "info",
                "delete"
              ],
              "description": "GridFS operation type"
            },
            "bucket": {
              "type": "string",
              "default": "fs",
              "description": "GridFS bucket name"
            },
            "filename": {
              "type": "string",
              "description": "Filename for info/delete operations"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 20,
              "description": "Maximum files to list"
            }
          },
          "required": [
            "operation"
          ]
        }
      },
      {
        "name": "clear-cache",
        "description": "Clear memory caches to ensure fresh data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "target": {
              "type": "string",
              "enum": [
                "all",
                "collections",
                "schemas",
                "indexes",
                "stats",
                "fields",
                "serverStatus"
              ],
              "default": "all",
              "description": "Cache type to clear (default: all)"
            }
          }
        }
      },
      {
        "name": "shard-status",
        "description": "Get sharding status for database or collections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "target": {
              "type": "string",
              "enum": [
                "database",
                "collection"
              ],
              "default": "database",
              "description": "Target type"
            },
            "collection": {
              "type": "string",
              "description": "Collection name (if target is collection)"
            }
          }
        }
      },
      {
        "name": "export-data",
        "description": "Export query results to formatted JSON or CSV",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "Filter as JSON string"
            },
            "format": {
              "type": "string",
              "enum": [
                "json",
                "csv"
              ],
              "default": "json",
              "description": "Export format"
            },
            "fields": {
              "type": "string",
              "description": "Comma-separated list of fields to include (for CSV)"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 1000,
              "description": "Maximum documents to export"
            },
            "sort": {
              "type": "string",
              "description": "Sort specification as JSON string (e.g. {\"date\": -1} for descending)"
            }
          },
          "required": [
            "collection"
          ]
        }
      }
    ]
  },
  "devrev": {
    "name": "devrev",
    "display_name": "DevRev",
    "description": "An MCP server to integrate with DevRev APIs to search through your DevRev Knowledge Graph where objects can be imported from diff. sources listed [here](https://devrev.ai/docs/import#available-sources).",
    "repository": {
      "type": "git",
      "url": "https://github.com/kpsunil97/devrev-mcp-server"
    },
    "homepage": "https://github.com/kpsunil97/devrev-mcp-server",
    "author": {
      "name": "kpsunil97"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "devrev",
      "server",
      "search"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "devrev-mcp"
        ],
        "env": {
          "DEVREV_API_KEY": "${DEVREV_API_KEY}"
        }
      }
    },
    "arguments": {
      "DEVREV_API_KEY": {
        "description": "Your DevRev API key required to authenticate requests to the DevRev API.",
        "required": true,
        "example": "YOUR_DEVREV_API_KEY"
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Search DevRev using the provided query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            },
            "namespace": {
              "type": "string",
              "enum": [
                "article",
                "issue",
                "ticket"
              ]
            }
          },
          "required": [
            "query",
            "namespace"
          ]
        }
      },
      {
        "name": "get_object",
        "description": "Get all information about a DevRev object using its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  "eunomia": {
    "name": "eunomia",
    "display_name": "Eunomia",
    "description": "Extension of the Eunomia framework that connects Eunomia instruments with MCP servers",
    "repository": {
      "type": "git",
      "url": "https://github.com/whataboutyou-ai/eunomia-MCP-server"
    },
    "homepage": "https://github.com/whataboutyou-ai/eunomia-MCP-server",
    "author": {
      "name": "whataboutyou-ai"
    },
    "license": "Apache-2.0",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Eunomia",
      "Data Governance"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/whataboutyou-ai/eunomia-MCP-server",
          "orchestra_server"
        ]
      }
    },
    "arguments": {
      "APP_NAME": {
        "description": "Name of the application",
        "required": true,
        "example": "mcp-server_orchestra"
      },
      "APP_VERSION": {
        "description": "Current version of the application",
        "required": true,
        "example": "0.1.0"
      },
      "LOG_LEVEL": {
        "description": "Logging level to control the verbosity of logs (default: 'info')",
        "required": false,
        "example": "info"
      },
      "REQUEST_TIMEOUT": {
        "description": "Environment variable that sets the request timeout duration in seconds",
        "required": false,
        "example": "30"
      }
    }
  },
  "amap": {
    "name": "amap",
    "display_name": "Amap / \u9ad8\u5fb7\u5730\u56fe",
    "description": "MCP Server for the AMap Map API.",
    "repository": {
      "type": "npm",
      "url": "https://www.npmjs.com/package/@amap/amap-maps-mcp-server"
    },
    "homepage": "https://lbs.amap.com/api/mcp-server/summary",
    "author": {
      "name": "amap"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "amap",
      "map"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@amap/amap-maps-mcp-server"
        ],
        "env": {
          "AMAP_MAPS_API_KEY": "${AMAP_MAPS_API_KEY}"
        }
      }
    },
    "arguments": {
      "AMAP_MAPS_API_KEY": {
        "description": "The API key to access the AMap service.",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      }
    },
    "is_official": true,
    "tools": [
      {
        "name": "maps_regeocode",
        "description": "\u5c06\u7ecf\u7eac\u5ea6\u5750\u6807\u8f6c\u6362\u4e3a\u5546\u5708\u533a\u57df\u4fe1\u606f",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "\u7ecf\u7eac\u5ea6\u5750\u6807"
            }
          },
          "required": [
            "location"
          ]
        }
      },
      {
        "name": "maps_geo",
        "description": "\u5c06\u5730\u5740\u8f6c\u6362\u4e3a\u7ecf\u7eac\u5ea6\u5750\u6807",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "\u5730\u5740"
            },
            "city": {
              "type": "string",
              "description": "\u6307\u5b9a\u67e5\u8be2\u7684\u57ce\u5e02"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "maps_ip_location",
        "description": "\u6839\u636e\u7528\u6237\u8f93\u5165\u7684 IP \u5730\u5740\u786e\u5b9a IP \u7684\u4f4d\u7f6e",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ip": {
              "type": "string",
              "description": "IP\u5730\u5740"
            }
          },
          "required": [
            "ip"
          ]
        }
      },
      {
        "name": "maps_weather",
        "description": "\u6839\u636e\u57ce\u5e02\u540d\u79f0\u6216 adcode \u67e5\u8be2\u6307\u5b9a\u57ce\u5e02\u7684\u5929\u6c14",
        "inputSchema": {
          "type": "object",
          "properties": {
            "city": {
              "type": "string",
              "description": "\u57ce\u5e02\u540d\u79f0\u6216 adcode"
            }
          },
          "required": [
            "city"
          ]
        }
      },
      {
        "name": "maps_search_detail",
        "description": "\u6839\u636e\u5173\u952e\u8bcd\u641c\u7d22\u6216\u5468\u8fb9\u641c\u7d22\u83b7\u53d6\u7684POI ID\u7684\u8be6\u7ec6\u4fe1\u606f",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "POI ID"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "maps_bicycling",
        "description": "\u6839\u636e\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u7ecf\u7eac\u5ea6\u5750\u6807\u89c4\u5212\u81ea\u884c\u8f66\u8def\u7ebf\uff0c\u89c4\u5212\u65f6\u4f1a\u8003\u8651\u4ea4\u901a\u3001\u5355\u884c\u7ebf\u3001\u5c01\u95ed\u8def\u6bb5\u7b49\u60c5\u51b5\uff0c\u6700\u591a\u652f\u6301500\u516c\u91cc\u7684\u81ea\u884c\u8f66\u8def\u7ebf\u89c4\u5212",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "\u8d77\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            },
            "destination": {
              "type": "string",
              "description": "\u7ec8\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            }
          },
          "required": [
            "origin",
            "destination"
          ]
        }
      },
      {
        "name": "maps_direction_walking",
        "description": "\u6839\u636e\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u7ecf\u7eac\u5ea6\u5750\u6807\u89c4\u5212\u6b65\u884c\u8def\u7ebf\uff0c\u6700\u591a\u652f\u6301100\u516c\u91cc\u7684\u6b65\u884c\u8def\u7ebf\u89c4\u5212",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "\u8d77\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            },
            "destination": {
              "type": "string",
              "description": "\u7ec8\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            }
          },
          "required": [
            "origin",
            "destination"
          ]
        }
      },
      {
        "name": "maps_direction_driving",
        "description": "\u6839\u636e\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u7ecf\u7eac\u5ea6\u5750\u6807\u89c4\u5212\u6c7d\u8f66\u8def\u7ebf\uff0c\u6700\u591a\u652f\u6301500\u516c\u91cc\u7684\u6c7d\u8f66\u8def\u7ebf\u89c4\u5212",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "\u8d77\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            },
            "destination": {
              "type": "string",
              "description": "\u7ec8\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            }
          },
          "required": [
            "origin",
            "destination"
          ]
        }
      },
      {
        "name": "maps_direction_transit_integrated",
        "description": "\u6839\u636e\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u7ecf\u7eac\u5ea6\u5750\u6807\u89c4\u5212\u516c\u5171\u4ea4\u901a\u8def\u7ebf\uff0c\u6700\u591a\u652f\u6301500\u516c\u91cc\u7684\u516c\u5171\u4ea4\u901a\u8def\u7ebf\u89c4\u5212",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "\u8d77\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            },
            "destination": {
              "type": "string",
              "description": "\u7ec8\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            },
            "city": {
              "type": "string",
              "description": "\u8d77\u70b9\u6240\u5728\u57ce\u5e02"
            },
            "cityd": {
              "type": "string",
              "description": "\u7ec8\u70b9\u6240\u5728\u57ce\u5e02"
            }
          },
          "required": [
            "origin",
            "destination",
            "city",
            "cityd"
          ]
        }
      },
      {
        "name": "maps_distance",
        "description": "\u6839\u636e\u4e24\u4e2a\u7ecf\u7eac\u5ea6\u5750\u6807\u8ba1\u7b97\u8ddd\u79bb\uff0c\u652f\u6301\u516c\u4ea4\u3001\u6b65\u884c\u3001\u5730\u94c1\u8ddd\u79bb\u8ba1\u7b97",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origins": {
              "type": "string",
              "description": "\u8d77\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6\uff0c\u53ef\u4ee5\u8f93\u5165\u591a\u4e2a\u5750\u6807\uff0c\u7528\u5206\u53f7\u5206\u9694\uff0c\u4f8b\u5982120,30;120,31"
            },
            "destination": {
              "type": "string",
              "description": "\u7ec8\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            },
            "type": {
              "type": "string",
              "description": "\u8ddd\u79bb\u7c7b\u578b\uff0c1\u8868\u793a\u516c\u4ea4\u8ddd\u79bb\u8ba1\u7b97\uff0c0\u8868\u793a\u76f4\u7ebf\u8ddd\u79bb\u8ba1\u7b97\uff0c3\u8868\u793a\u6b65\u884c\u8ddd\u79bb\u8ba1\u7b97"
            }
          },
          "required": [
            "origins",
            "destination"
          ]
        }
      },
      {
        "name": "maps_text_search",
        "description": "\u5173\u952e\u8bcd\u641c\u7d22\uff0c\u6839\u636e\u7528\u6237\u8f93\u5165\u7684\u5173\u952e\u8bcd\u641c\u7d22\u76f8\u5173\u7684POI",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string",
              "description": "\u5173\u952e\u8bcd"
            },
            "city": {
              "type": "string",
              "description": "\u67e5\u8be2\u57ce\u5e02"
            },
            "types": {
              "type": "string",
              "description": "POI\u7c7b\u578b\uff0c\u4f8b\u5982\u516c\u4ea4\u7ad9"
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "maps_around_search",
        "description": "\u5468\u8fb9\u641c\u7d22\uff0c\u6839\u636e\u7528\u6237\u8f93\u5165\u7684\u5173\u952e\u8bcd\u548c\u4e2d\u5fc3\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\u641c\u7d22\u5468\u56f4\u7684POI",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string",
              "description": "\u5173\u952e\u8bcd"
            },
            "location": {
              "type": "string",
              "description": "\u4e2d\u5fc3\u70b9\u7ecf\u7eac\u5ea6\u5750\u6807\uff0c\u5750\u6807\u683c\u5f0f\u4e3a\uff1a\u7ecf\u5ea6,\u7eac\u5ea6"
            },
            "radius": {
              "type": "string",
              "description": "\u641c\u7d22\u534a\u5f84"
            }
          },
          "required": [
            "location"
          ]
        }
      }
    ]
  },
  "google-custom-search": {
    "name": "google-custom-search",
    "display_name": "Google Custom Search",
    "description": "Provides Google Search results via the Google Custom Search API",
    "repository": {
      "type": "git",
      "url": "https://github.com/adenot/mcp-google-search"
    },
    "homepage": "https://github.com/adenot/mcp-google-search",
    "author": {
      "name": "adenot"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Google",
      "Custom Search",
      "Webpage Reading"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@adenot/mcp-google-search"
        ],
        "env": {
          "GOOGLE_API_KEY": "your-api-key-here",
          "GOOGLE_SEARCH_ENGINE_ID": "your-search-engine-id-here"
        }
      }
    },
    "examples": [
      {
        "title": "Search Tool",
        "description": "Perform web searches using Google Custom Search API.",
        "prompt": "{\"name\":\"search\",\"arguments\":{\"query\":\"your search query\",\"num\":5}}"
      },
      {
        "title": "Webpage Reader Tool",
        "description": "Extract content from any webpage.",
        "prompt": "{\"name\":\"read_webpage\",\"arguments\":{\"url\":\"https://example.com\"}}"
      }
    ],
    "arguments": {
      "GOOGLE_API_KEY": {
        "description": "Your Google API key for accessing the Google Custom Search API.",
        "required": true,
        "example": "AIzaSyA-xxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      },
      "GOOGLE_SEARCH_ENGINE_ID": {
        "description": "The unique identifier for your Custom Search Engine that you created on Google.",
        "required": true,
        "example": "012345678901234567890:abcdefghijk"
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Perform a web search query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "num": {
              "type": "number",
              "description": "Number of results (1-10)",
              "minimum": 1,
              "maximum": 10
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "bigquery": {
    "name": "bigquery",
    "display_name": "BigQuery",
    "description": "Server implementation for Google BigQuery integration that enables direct BigQuery database access and querying capabilities",
    "repository": {
      "type": "git",
      "url": "https://github.com/ergut/mcp-bigquery-server"
    },
    "homepage": "https://github.com/ergut/mcp-bigquery-server",
    "author": {
      "name": "ergut"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "BigQuery",
      "AI",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@ergut/mcp-bigquery-server",
          "--project-id",
          "${PROJECT_ID}",
          "--location",
          "${LOCATION}"
        ]
      }
    },
    "arguments": {
      "PROJECT_ID": {
        "description": "Your Google Cloud project ID",
        "required": true,
        "example": "your-project-id"
      },
      "LOCATION": {
        "description": "BigQuery location, defaults to 'us-central1'.",
        "required": false,
        "example": "us-central1"
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Run a read-only BigQuery SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sql": {
              "type": "string"
            },
            "maximumBytesBilled": {
              "type": "string",
              "description": "Maximum bytes billed (default: 1GB)",
              "optional": true
            }
          }
        }
      }
    ]
  },
  "e2b-mcp-server": {
    "display_name": "E2B MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/e2b-dev/mcp-server"
    },
    "homepage": "https://e2b.dev",
    "author": {
      "name": "e2b-dev"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "code-interpreter",
      "claude",
      "sandbox"
    ],
    "arguments": {
      "e2bApiKey": {
        "description": "E2B API key",
        "required": true
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@e2b/mcp-server"
        ],
        "env": {
          "E2B_API_KEY": "${e2bApiKey}"
        }
      },
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "e2b-mcp-server"
        ],
        "env": {
          "E2B_API_KEY": "${e2bApiKey}"
        }
      }
    },
    "name": "e2b-mcp-server",
    "description": "This repository contains the source code for the [E2B](https://e2b.dev) MCP server.",
    "categories": [
      "MCP Tools"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "run_code",
        "description": "Run python code in a secure sandbox by E2B. Using the Jupyter Notebook syntax.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string"
            }
          },
          "required": [
            "code"
          ]
        }
      }
    ]
  },
  "bitable-mcp": {
    "name": "bitable-mcp",
    "display_name": "Bitable",
    "description": "MCP server provides access to Lark Bitable through the Model Context Protocol. It allows users to interact with Bitable tables using predefined tools.",
    "repository": {
      "type": "git",
      "url": "https://github.com/lloydzhou/bitable-mcp"
    },
    "homepage": "https://github.com/lloydzhou/bitable-mcp",
    "author": {
      "name": "lloydzhou"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Bitable",
      "Lark"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "bitable-mcp"
        ],
        "env": {
          "PERSONAL_BASE_TOKEN": "${PERSONAL_BASE_TOKEN}",
          "APP_TOKEN": "${APP_TOKEN}"
        }
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "bitable_mcp"
        ],
        "env": {
          "PERSONAL_BASE_TOKEN": "${PERSONAL_BASE_TOKEN}",
          "APP_TOKEN": "${APP_TOKEN}"
        },
        "description": "Run with Python module (requires pip install)"
      }
    },
    "examples": [
      {
        "title": "List Tables",
        "description": "Lists all tables available in Bitable.",
        "prompt": "list_table"
      }
    ],
    "arguments": {
      "PERSONAL_BASE_TOKEN": {
        "description": "Personal base token required for authentication with the Bitable API.",
        "required": true,
        "example": "your_personal_base_token"
      },
      "APP_TOKEN": {
        "description": "Application token required for the Bitable server to function properly.",
        "required": true,
        "example": "your_app_token"
      }
    },
    "tools": [
      {
        "name": "list_table",
        "description": "list table for current bitable",
        "inputSchema": {
          "properties": {},
          "title": "list_tableArguments",
          "type": "object"
        }
      },
      {
        "name": "describe_table",
        "description": "describe_table by table name",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            }
          },
          "required": [
            "name"
          ],
          "title": "describe_tableArguments",
          "type": "object"
        }
      },
      {
        "name": "read_query",
        "description": "read_query by sql",
        "inputSchema": {
          "properties": {
            "sql": {
              "title": "Sql",
              "type": "string"
            }
          },
          "required": [
            "sql"
          ],
          "title": "read_queryArguments",
          "type": "object"
        }
      }
    ]
  },
  "openapi-anyapi": {
    "name": "openapi-anyapi",
    "display_name": "Scalable OpenAPI Endpoint Discovery Tool",
    "description": "Interact with large [OpenAPI](https://www.openapis.org/) docs using built-in semantic search for endpoints. Allows for customizing the MCP server prefix.",
    "repository": {
      "type": "git",
      "url": "https://github.com/baryhuang/mcp-server-any-openapi"
    },
    "homepage": "https://github.com/baryhuang/mcp-server-any-openapi",
    "author": {
      "name": "baryhuang"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "OPENAPI_JSON_DOCS_URL=${OPENAPI_JSON_DOCS_URL}",
          "-e",
          "API_REQUEST_BASE_URL=${API_REQUEST_BASE_URL}",
          "-e",
          "MCP_API_PREFIX=${MCP_API_PREFIX}",
          "buryhuang/mcp-server-any-openapi:latest"
        ],
        "env": {
          "OPENAPI_JSON_DOCS_URL": "${OPENAPI_JSON_DOCS_URL}",
          "API_REQUEST_BASE_URL": "${API_REQUEST_BASE_URL}",
          "MCP_API_PREFIX": "${MCP_API_PREFIX}"
        }
      },
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/baryhuang/mcp-server-any-openapi",
          "src/mcp_server_any_openapi/server.py"
        ],
        "env": {
          "OPENAPI_JSON_DOCS_URL": "${OPENAPI_JSON_DOCS_URL}",
          "API_REQUEST_BASE_URL": "${API_REQUEST_BASE_URL}",
          "MCP_API_PREFIX": "${MCP_API_PREFIX}"
        }
      }
    },
    "tags": [
      "OpenAPI",
      "API Discovery",
      "Semantic Search",
      "FastAPI"
    ],
    "examples": [
      {
        "title": "Get API Endpoints",
        "description": "Use this tool to find relevant API endpoints by describing your intent.",
        "prompt": "Get prices for all stocks"
      }
    ],
    "arguments": {
      "OPENAPI_JSON_DOCS_URL": {
        "description": "URL to the OpenAPI specification JSON (defaults to https://api.staging.readymojo.com/openapi.json)",
        "required": false,
        "example": "https://api.example.com/openapi.json"
      },
      "API_REQUEST_BASE_URL": {
        "description": "Optional base URL to override the default URL extracted from the OpenAPI document.",
        "required": false,
        "example": "https://api.finance.com"
      },
      "MCP_API_PREFIX": {
        "description": "Customizable tool namespace (default 'any_openapi'). Allows for control over tool naming.",
        "required": false,
        "example": "finance"
      }
    },
    "tools": [
      {
        "name": "${MCP_API_PREFIX}_api_request_schema",
        "description": "Get API endpoint schemas that match your intent. Returns endpoint details including path, method, parameters, and response formats.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Describe what you want to do with the API (e.g., 'Get user profile information', 'Create a new job posting')"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "${MCP_API_PREFIX}_make_request",
        "description": "Make an actual REST API request with full control over method, headers, body, and parameters.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "method": {
              "type": "string",
              "description": "HTTP method (GET, POST, PUT, DELETE, PATCH)",
              "enum": [
                "GET",
                "POST",
                "PUT",
                "DELETE",
                "PATCH"
              ]
            },
            "url": {
              "type": "string",
              "description": "Fully qualified API URL (e.g., https://api.example.com/users/123)"
            },
            "headers": {
              "type": "object",
              "description": "Request headers",
              "additionalProperties": {
                "type": "string"
              }
            },
            "query_params": {
              "type": "object",
              "description": "Query parameters",
              "additionalProperties": {
                "type": "string"
              }
            },
            "body": {
              "type": "object",
              "description": "Request body (for POST, PUT, PATCH)",
              "additionalProperties": true
            }
          },
          "required": [
            "method",
            "url"
          ]
        }
      }
    ]
  },
  "blender": {
    "name": "blender",
    "display_name": "Blender",
    "description": "Blender integration allowing prompt enabled 3D scene creation, modeling and manipulation.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ahujasid/blender-mcp"
    },
    "homepage": "https://github.com/ahujasid/blender-mcp",
    "author": {
      "name": "ahujasid"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Blender",
      "Claude AI",
      "3D Modeling"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "blender-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "get_scene_info",
        "description": "Get detailed information about the current Blender scene",
        "inputSchema": {
          "properties": {},
          "title": "get_scene_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "get_object_info",
        "description": "\n    Get detailed information about a specific object in the Blender scene.\n    \n    Parameters:\n    - object_name: The name of the object to get information about\n    ",
        "inputSchema": {
          "properties": {
            "object_name": {
              "title": "Object Name",
              "type": "string"
            }
          },
          "required": [
            "object_name"
          ],
          "title": "get_object_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "create_object",
        "description": "\n    Create a new object in the Blender scene.\n    \n    Parameters:\n    - type: Object type (CUBE, SPHERE, CYLINDER, PLANE, CONE, TORUS, EMPTY, CAMERA, LIGHT)\n    - name: Optional name for the object\n    - location: Optional [x, y, z] location coordinates\n    - rotation: Optional [x, y, z] rotation in radians\n    - scale: Optional [x, y, z] scale factors (not used for TORUS)\n    \n    Torus-specific parameters (only used when type == \"TORUS\"):\n    - align: How to align the torus ('WORLD', 'VIEW', or 'CURSOR')\n    - major_segments: Number of segments for the main ring\n    - minor_segments: Number of segments for the cross-section\n    - mode: Dimension mode ('MAJOR_MINOR' or 'EXT_INT')\n    - major_radius: Radius from the origin to the center of the cross sections\n    - minor_radius: Radius of the torus' cross section\n    - abso_major_rad: Total exterior radius of the torus\n    - abso_minor_rad: Total interior radius of the torus\n    - generate_uvs: Whether to generate a default UV map\n    \n    Returns:\n    A message indicating the created object name.\n    ",
        "inputSchema": {
          "properties": {
            "type": {
              "default": "CUBE",
              "title": "Type",
              "type": "string"
            },
            "name": {
              "default": null,
              "title": "Name",
              "type": "string"
            },
            "location": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Location",
              "type": "array"
            },
            "rotation": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Rotation",
              "type": "array"
            },
            "scale": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Scale",
              "type": "array"
            },
            "align": {
              "default": "WORLD",
              "title": "Align",
              "type": "string"
            },
            "major_segments": {
              "default": 48,
              "title": "Major Segments",
              "type": "integer"
            },
            "minor_segments": {
              "default": 12,
              "title": "Minor Segments",
              "type": "integer"
            },
            "mode": {
              "default": "MAJOR_MINOR",
              "title": "Mode",
              "type": "string"
            },
            "major_radius": {
              "default": 1.0,
              "title": "Major Radius",
              "type": "number"
            },
            "minor_radius": {
              "default": 0.25,
              "title": "Minor Radius",
              "type": "number"
            },
            "abso_major_rad": {
              "default": 1.25,
              "title": "Abso Major Rad",
              "type": "number"
            },
            "abso_minor_rad": {
              "default": 0.75,
              "title": "Abso Minor Rad",
              "type": "number"
            },
            "generate_uvs": {
              "default": true,
              "title": "Generate Uvs",
              "type": "boolean"
            }
          },
          "title": "create_objectArguments",
          "type": "object"
        }
      },
      {
        "name": "modify_object",
        "description": "\n    Modify an existing object in the Blender scene.\n    \n    Parameters:\n    - name: Name of the object to modify\n    - location: Optional [x, y, z] location coordinates\n    - rotation: Optional [x, y, z] rotation in radians\n    - scale: Optional [x, y, z] scale factors\n    - visible: Optional boolean to set visibility\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "location": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Location",
              "type": "array"
            },
            "rotation": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Rotation",
              "type": "array"
            },
            "scale": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Scale",
              "type": "array"
            },
            "visible": {
              "default": null,
              "title": "Visible",
              "type": "boolean"
            }
          },
          "required": [
            "name"
          ],
          "title": "modify_objectArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_object",
        "description": "\n    Delete an object from the Blender scene.\n    \n    Parameters:\n    - name: Name of the object to delete\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            }
          },
          "required": [
            "name"
          ],
          "title": "delete_objectArguments",
          "type": "object"
        }
      },
      {
        "name": "set_material",
        "description": "\n    Set or create a material for an object.\n    \n    Parameters:\n    - object_name: Name of the object to apply the material to\n    - material_name: Optional name of the material to use or create\n    - color: Optional [R, G, B] color values (0.0-1.0)\n    ",
        "inputSchema": {
          "properties": {
            "object_name": {
              "title": "Object Name",
              "type": "string"
            },
            "material_name": {
              "default": null,
              "title": "Material Name",
              "type": "string"
            },
            "color": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Color",
              "type": "array"
            }
          },
          "required": [
            "object_name"
          ],
          "title": "set_materialArguments",
          "type": "object"
        }
      },
      {
        "name": "execute_blender_code",
        "description": "\n    Execute arbitrary Python code in Blender.\n    \n    Parameters:\n    - code: The Python code to execute\n    ",
        "inputSchema": {
          "properties": {
            "code": {
              "title": "Code",
              "type": "string"
            }
          },
          "required": [
            "code"
          ],
          "title": "execute_blender_codeArguments",
          "type": "object"
        }
      },
      {
        "name": "get_polyhaven_categories",
        "description": "\n    Get a list of categories for a specific asset type on Polyhaven.\n    \n    Parameters:\n    - asset_type: The type of asset to get categories for (hdris, textures, models, all)\n    ",
        "inputSchema": {
          "properties": {
            "asset_type": {
              "default": "hdris",
              "title": "Asset Type",
              "type": "string"
            }
          },
          "title": "get_polyhaven_categoriesArguments",
          "type": "object"
        }
      },
      {
        "name": "search_polyhaven_assets",
        "description": "\n    Search for assets on Polyhaven with optional filtering.\n    \n    Parameters:\n    - asset_type: Type of assets to search for (hdris, textures, models, all)\n    - categories: Optional comma-separated list of categories to filter by\n    \n    Returns a list of matching assets with basic information.\n    ",
        "inputSchema": {
          "properties": {
            "asset_type": {
              "default": "all",
              "title": "Asset Type",
              "type": "string"
            },
            "categories": {
              "default": null,
              "title": "Categories",
              "type": "string"
            }
          },
          "title": "search_polyhaven_assetsArguments",
          "type": "object"
        }
      },
      {
        "name": "download_polyhaven_asset",
        "description": "\n    Download and import a Polyhaven asset into Blender.\n    \n    Parameters:\n    - asset_id: The ID of the asset to download\n    - asset_type: The type of asset (hdris, textures, models)\n    - resolution: The resolution to download (e.g., 1k, 2k, 4k)\n    - file_format: Optional file format (e.g., hdr, exr for HDRIs; jpg, png for textures; gltf, fbx for models)\n    \n    Returns a message indicating success or failure.\n    ",
        "inputSchema": {
          "properties": {
            "asset_id": {
              "title": "Asset Id",
              "type": "string"
            },
            "asset_type": {
              "title": "Asset Type",
              "type": "string"
            },
            "resolution": {
              "default": "1k",
              "title": "Resolution",
              "type": "string"
            },
            "file_format": {
              "default": null,
              "title": "File Format",
              "type": "string"
            }
          },
          "required": [
            "asset_id",
            "asset_type"
          ],
          "title": "download_polyhaven_assetArguments",
          "type": "object"
        }
      },
      {
        "name": "set_texture",
        "description": "\n    Apply a previously downloaded Polyhaven texture to an object.\n    \n    Parameters:\n    - object_name: Name of the object to apply the texture to\n    - texture_id: ID of the Polyhaven texture to apply (must be downloaded first)\n    \n    Returns a message indicating success or failure.\n    ",
        "inputSchema": {
          "properties": {
            "object_name": {
              "title": "Object Name",
              "type": "string"
            },
            "texture_id": {
              "title": "Texture Id",
              "type": "string"
            }
          },
          "required": [
            "object_name",
            "texture_id"
          ],
          "title": "set_textureArguments",
          "type": "object"
        }
      },
      {
        "name": "get_polyhaven_status",
        "description": "\n    Check if PolyHaven integration is enabled in Blender.\n    Returns a message indicating whether PolyHaven features are available.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_polyhaven_statusArguments",
          "type": "object"
        }
      },
      {
        "name": "get_hyper3d_status",
        "description": "\n    Check if Hyper3D Rodin integration is enabled in Blender.\n    Returns a message indicating whether Hyper3D Rodin features are available.\n\n    Don't emphasize the key type in the returned message, but sliently remember it. \n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_hyper3d_statusArguments",
          "type": "object"
        }
      },
      {
        "name": "generate_hyper3d_model_via_text",
        "description": "\n    Generate 3D asset using Hyper3D by giving description of the desired asset, and import the asset into Blender.\n    The 3D asset has built-in materials.\n    The generated model has a normalized size, so re-scaling after generation can be useful.\n    \n    Parameters:\n    - text_prompt: A short description of the desired model in **English**.\n    - bbox_condition: Optional. If given, it has to be a list of floats of length 3. Controls the ratio between [Length, Width, Height] of the model.\n\n    Returns a message indicating success or failure.\n    ",
        "inputSchema": {
          "properties": {
            "text_prompt": {
              "title": "Text Prompt",
              "type": "string"
            },
            "bbox_condition": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Bbox Condition",
              "type": "array"
            }
          },
          "required": [
            "text_prompt"
          ],
          "title": "generate_hyper3d_model_via_textArguments",
          "type": "object"
        }
      },
      {
        "name": "generate_hyper3d_model_via_images",
        "description": "\n    Generate 3D asset using Hyper3D by giving images of the wanted asset, and import the generated asset into Blender.\n    The 3D asset has built-in materials.\n    The generated model has a normalized size, so re-scaling after generation can be useful.\n    \n    Parameters:\n    - input_image_paths: The **absolute** paths of input images. Even if only one image is provided, wrap it into a list. Required if Hyper3D Rodin in MAIN_SITE mode.\n    - input_image_urls: The URLs of input images. Even if only one image is provided, wrap it into a list. Required if Hyper3D Rodin in FAL_AI mode.\n    - bbox_condition: Optional. If given, it has to be a list of ints of length 3. Controls the ratio between [Length, Width, Height] of the model.\n\n    Only one of {input_image_paths, input_image_urls} should be given at a time, depending on the Hyper3D Rodin's current mode.\n    Returns a message indicating success or failure.\n    ",
        "inputSchema": {
          "properties": {
            "input_image_paths": {
              "default": null,
              "items": {
                "type": "string"
              },
              "title": "Input Image Paths",
              "type": "array"
            },
            "input_image_urls": {
              "default": null,
              "items": {
                "type": "string"
              },
              "title": "Input Image Urls",
              "type": "array"
            },
            "bbox_condition": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Bbox Condition",
              "type": "array"
            }
          },
          "title": "generate_hyper3d_model_via_imagesArguments",
          "type": "object"
        }
      },
      {
        "name": "poll_rodin_job_status",
        "description": "\n    Check if the Hyper3D Rodin generation task is completed.\n\n    For Hyper3D Rodin mode MAIN_SITE:\n        Parameters:\n        - subscription_key: The subscription_key given in the generate model step.\n\n        Returns a list of status. The task is done if all status are \"Done\".\n        If \"Failed\" showed up, the generating process failed.\n        This is a polling API, so only proceed if the status are finally determined (\"Done\" or \"Canceled\").\n\n    For Hyper3D Rodin mode FAL_AI:\n        Parameters:\n        - request_id: The request_id given in the generate model step.\n\n        Returns the generation task status. The task is done if status is \"COMPLETED\".\n        The task is in progress if status is \"IN_PROGRESS\".\n        If status other than \"COMPLETED\", \"IN_PROGRESS\", \"IN_QUEUE\" showed up, the generating process might be failed.\n        This is a polling API, so only proceed if the status are finally determined (\"COMPLETED\" or some failed state).\n    ",
        "inputSchema": {
          "properties": {
            "subscription_key": {
              "default": null,
              "title": "Subscription Key",
              "type": "string"
            },
            "request_id": {
              "default": null,
              "title": "Request Id",
              "type": "string"
            }
          },
          "title": "poll_rodin_job_statusArguments",
          "type": "object"
        }
      },
      {
        "name": "import_generated_asset",
        "description": "\n    Import the asset generated by Hyper3D Rodin after the generation task is completed.\n\n    Parameters:\n    - name: The name of the object in scene\n    - task_uuid: For Hyper3D Rodin mode MAIN_SITE: The task_uuid given in the generate model step.\n    - request_id: For Hyper3D Rodin mode FAL_AI: The request_id given in the generate model step.\n\n    Only give one of {task_uuid, request_id} based on the Hyper3D Rodin Mode!\n    Return if the asset has been imported successfully.\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "task_uuid": {
              "default": null,
              "title": "Task Uuid",
              "type": "string"
            },
            "request_id": {
              "default": null,
              "title": "Request Id",
              "type": "string"
            }
          },
          "required": [
            "name"
          ],
          "title": "import_generated_assetArguments",
          "type": "object"
        }
      }
    ]
  },
  "virtual-location-google-street-view-etc": {
    "name": "virtual-location-google-street-view-etc",
    "display_name": "Virtual Traveling Bot",
    "description": "Integrates Google Map, Google Street View, PixAI, Stability.ai, ComfyUI API and Bluesky to provide a virtual location simulation in LLM (written in Effect.ts)",
    "repository": {
      "type": "git",
      "url": "https://github.com/mfukushim/map-traveler-mcp"
    },
    "homepage": "https://github.com/mfukushim/map-traveler-mcp",
    "author": {
      "name": "mfukushim"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Google Maps",
      "Avatar",
      "Virtual Travel"
    ],
    "tools": [
      {
        "name": "tips",
        "description": "Inform you of recommended actions for your device",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_setting",
        "description": "Get current setting",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_traveler_info",
        "description": "get a traveler's setting.For example, traveler's name, the language traveler speak, Personality and speaking habits, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "settings": {}
          }
        }
      },
      {
        "name": "set_traveler_info",
        "description": "set a traveler's setting.For example, traveler's name, the language traveler speak, Personality and speaking habits, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "settings": {
              "type": "string",
              "description": "traveler's setting. traveler's name, the language traveler speak, etc."
            }
          },
          "required": [
            "settings"
          ]
        }
      },
      {
        "name": "set_avatar_prompt",
        "description": "set a traveler's avatar prompt. A prompt for AI image generation to specify the appearance of a traveler's avatar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "traveler's avatar AI image generation prompt."
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "reset_avatar_prompt",
        "description": "reset to default traveler's avatar prompt.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "start_journey",
        "description": "Start the journey to destination",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "stop_journey",
        "description": "Stop the journey",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "reach_a_percentage_of_destination",
        "description": "Reach a specified percentage of the destination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timeElapsedPercentage": {
              "type": "number",
              "description": "Percent progress towards destination. (0~100)"
            }
          },
          "required": [
            "timeElapsedPercentage"
          ]
        }
      },
      {
        "name": "get_current_view_info",
        "description": "Get the address of the current location and information on nearby facilities,view snapshot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "includePhoto": {
              "type": "boolean",
              "description": "Get scenery photos of current location"
            },
            "includeNearbyFacilities": {
              "type": "boolean",
              "description": "Get information on nearby facilities"
            }
          }
        }
      },
      {
        "name": "get_traveler_location",
        "description": "Get the address of the current traveler's location",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_sns_mentions",
        "description": "Get recent social media mentions",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_sns_feeds",
        "description": "Get recent social media posts from fellow travelers feeds",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "post_sns_writer",
        "description": "Post your recent travel experiences to social media for fellow travelers and readers.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "A description of the journey. important: Do not use offensive language."
            }
          },
          "required": [
            "message"
          ]
        }
      },
      {
        "name": "reply_sns_writer",
        "description": "Write a reply to the article with the specified ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "A description of the reply article. important: Do not use offensive language."
            },
            "id": {
              "type": "string",
              "description": "The ID of the original post to which you want to add a reply."
            }
          },
          "required": [
            "message",
            "id"
          ]
        }
      },
      {
        "name": "add_like",
        "description": "Add a like to the specified post",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the post to like."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "set_current_location",
        "description": "Set my current address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "address to set"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_destination_address",
        "description": "get a address of destination location",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "set_destination_address",
        "description": "set a address of destination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "address of destination"
            }
          },
          "required": [
            "address"
          ]
        }
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@mfukushim/map-traveler-mcp"
        ],
        "env": {
          "GoogleMapApi_key": "${GoogleMapApi_key}",
          "mapApi_url": "${mapApi_url}",
          "time_scale": "${time_scale}",
          "sqlite_path": "${sqlite_path}",
          "rembg_path": "${rembg_path}",
          "remBgUrl": "${remBgUrl}",
          "pixAi_key": "${pixAi_key}",
          "sd_key": "${sd_key}",
          "pixAi_modelId": "${pixAi_modelId}",
          "comfy_url": "${comfy_url}",
          "comfy_workflow_t2i": "${comfy_workflow_t2i}",
          "comfy_workflow_i2i": "${comfy_workflow_i2i}",
          "comfy_params": "${comfy_params}",
          "fixed_model_prompt": "${fixed_model_prompt}",
          "bodyAreaRatio": "${bodyAreaRatio}",
          "bodyHWRatio": "${bodyHWRatio}",
          "bodyWindowRatioW": "${bodyWindowRatioW}",
          "bodyWindowRatioH": "${bodyWindowRatioH}",
          "bs_id": "${bs_id}",
          "bs_pass": "${bs_pass}",
          "bs_handle": "${bs_handle}",
          "filter_tools": "${filter_tools}",
          "moveMode": "${moveMode}",
          "image_width": "${image_width}",
          "DATABASE_URL": "${DATABASE_URL}"
        }
      }
    },
    "examples": [
      {
        "title": "Travel to Tokyo",
        "description": "Instruct the avatar to travel to Tokyo Station.",
        "prompt": "Go to Tokyo Station."
      },
      {
        "title": "Current Location Info",
        "description": "Get the current location information of the avatar.",
        "prompt": "Where are you now?"
      }
    ],
    "arguments": {
      "GoogleMapApi_key": {
        "description": "API key for accessing Google Maps services.",
        "required": true,
        "example": "YOUR_GOOGLE_MAP_API_KEY"
      },
      "mapApi_url": {
        "description": "Custom endpoint for the Map API, if any; otherwise, the default endpoint is used.",
        "required": false,
        "example": "https://your-custom-map-api.com"
      },
      "time_scale": {
        "description": "Scale factor to adjust the travel time based on real roads duration; default is 4.",
        "required": false,
        "example": "5"
      },
      "sqlite_path": {
        "description": "Path for saving the SQLite database file. It determines where the travel log will be stored.",
        "required": true,
        "example": "%USERPROFILE%/Desktop/traveler.sqlite"
      },
      "rembg_path": {
        "description": "Absolute path of the installed rembg command line interface for removing backgrounds from images.",
        "required": true,
        "example": "C:\\path\\to\\your\\rembg.exe"
      },
      "remBgUrl": {
        "description": "URL for the rembg API service if used; this is an alternative to the command line interface.",
        "required": false,
        "example": "http://rembg:7000"
      },
      "pixAi_key": {
        "description": "API key for accessing PixAI image generation services; either this or sd_key must be set to use image generation.",
        "required": true,
        "example": "YOUR_PIXAI_API_KEY"
      },
      "sd_key": {
        "description": "API key for accessing Stability.ai image generation services; either this or pixAi_key must be set.",
        "required": true,
        "example": "YOUR_STABILITY_AI_API_KEY"
      },
      "pixAi_modelId": {
        "description": "ID for the PixAI model to be used, if not set, the default model will be used.",
        "required": false,
        "example": "1648918127446573124"
      },
      "comfy_url": {
        "description": "URL to the ComfyUI API for image generation; must be set if using ComfyUI for this purpose.",
        "required": false,
        "example": "http://192.168.1.100:8188"
      },
      "comfy_workflow_t2i": {
        "description": "Path to the workflow JSON file for text-to-image conversion in ComfyUI.",
        "required": false,
        "example": "C:\\path\\to\\workflow\\t2i.json"
      },
      "comfy_workflow_i2i": {
        "description": "Path to the workflow JSON file for image-to-image conversion in ComfyUI.",
        "required": false,
        "example": "C:\\path\\to\\workflow\\i2i.json"
      },
      "comfy_params": {
        "description": "Parameters for the ComfyUI workflow in key-value format, received during the request.",
        "required": false,
        "example": "key1=value1,key2=value2"
      },
      "fixed_model_prompt": {
        "description": "A fixed prompt for avatar generation that prevents changes during conversations.",
        "required": false,
        "example": "Generate a friendly avatar."
      },
      "bodyAreaRatio": {
        "description": "Acceptable ratio for the avatar image area; affects how much of the image is used for the avatar.",
        "required": false,
        "example": "0.042"
      },
      "bodyHWRatio": {
        "description": "Acceptable aspect ratios for the avatar image; ensures correct proportions for the avatar.",
        "required": false,
        "example": "1.5~2.3"
      },
      "bodyWindowRatioW": {
        "description": "Horizontal ratio for the avatar composite window; affects layout.",
        "required": false,
        "example": "0.5"
      },
      "bodyWindowRatioH": {
        "description": "Aspect ratio for the avatar composite window; also affects layout.",
        "required": false,
        "example": "0.75"
      },
      "bs_id": {
        "description": "Bluesky SNS registration address for posting travel updates.",
        "required": false,
        "example": "YOUR_BSKY_ID"
      },
      "bs_pass": {
        "description": "Bluesky SNS password for the dedicated account used for posting.",
        "required": false,
        "example": "YOUR_BSKY_PASSWORD"
      },
      "bs_handle": {
        "description": "Bluesky SNS handle name for the account; used in the posts.",
        "required": false,
        "example": "myusername.bsky.social"
      },
      "filter_tools": {
        "description": "Settings to filter the tools available for use; all tools will be available by default.",
        "required": false,
        "example": "tips,set_traveler_location"
      },
      "moveMode": {
        "description": "Indicates whether the movement mode is realtime or skip; default is realtime.",
        "required": false,
        "example": "realtime"
      },
      "image_width": {
        "description": "Width of the generated output image in pixels; the default is 512.",
        "required": false,
        "example": "512"
      },
      "DATABASE_URL": {
        "description": "Database URL for persistent storage; used if a different database should be connected.",
        "required": false,
        "example": "mysql://user:password@host/dbname"
      }
    }
  },
  "multicluster-mcp-sever": {
    "name": "multicluster-mcp-sever",
    "display_name": "Multi-Cluster Server",
    "description": "The gateway for GenAI systems to interact with multiple Kubernetes clusters.",
    "repository": {
      "type": "git",
      "url": "https://github.com/yanmxa/multicluster-mcp-server"
    },
    "homepage": "https://github.com/yanmxa/multicluster-mcp-server",
    "author": {
      "name": "yanmxa"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Generative AI",
      "Kubernetes"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/yanmxa/multicluster-mcp-server"
        ]
      }
    },
    "tools": [
      {
        "name": "kubectl_executor",
        "description": "Securely execute a kubectl command.",
        "inputSchema": {
          "command": {
            "type": "string",
            "description": "The full kubectl command to execute. Must start with 'kubectl'."
          },
          "cluster": {
            "type": "string",
            "description": "Optional cluster name for multi-cluster environments. Specify only if explicitly provided."
          }
        },
        "required": [
          "command"
        ]
      },
      {
        "name": "clusters",
        "description": "Retrieves a list of Kubernetes clusters (also known as managed clusters or spoke clusters).",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "connect_cluster_via_admin",
        "description": "Generates the KUBECONFIG for the cluster using the ServiceAccount and binds it to the cluster-admin role.",
        "inputSchema": {
          "cluster": {
            "type": "string",
            "description": "The target cluster where the ServiceAccount will be created."
          }
        },
        "required": [
          "cluster"
        ]
      },
      {
        "name": "apply_service_account_with_cluster_role",
        "description": "Creates a ServiceAccount in the specified cluster and optionally binds it to a ClusterRole. If no ClusterRole is provided, only the ServiceAccount and kubeconfig are created.",
        "inputSchema": {
          "cluster": {
            "type": "string",
            "description": "The cluster where the ServiceAccount will be created."
          },
          "clusterRole": {
            "type": "object",
            "description": "Optional ClusterRole object defining permissions for the ServiceAccount."
          }
        },
        "required": [
          "cluster"
        ]
      }
    ]
  },
  "txyz-search": {
    "name": "txyz-search",
    "description": "A Model Context Protocol (MCP) server for TXYZ Search API. Provides tools for academic and scholarly search, general web search, and smart search.",
    "display_name": "TXYZ Search",
    "repository": {
      "type": "git",
      "url": "https://github.com/pathintegral-institute/mcp.science"
    },
    "homepage": "https://github.com/pathintegral-institute/mcp.science/tree/main/servers/txyz-search",
    "author": {
      "name": "pathintegral-institute"
    },
    "license": "MIT",
    "tags": [
      "search",
      "academic",
      "scholarly",
      "web search"
    ],
    "arguments": {
      "TXYZ_API_KEY": {
        "description": "API key from [TXYZ Platform](https://platform.txyz.ai/console)",
        "required": true,
        "example": "your-txyz-api-key"
      }
    },
    "tools": [
      {
        "name": "txyz_search_scholar",
        "description": "Academic and scholarly search for papers, articles, and other academic materials",
        "prompt": "Find recent research papers about quantum computing"
      },
      {
        "name": "txyz_search_web",
        "description": "General web search functionality for resources from web pages",
        "prompt": "Find information about the latest smartphone releases"
      },
      {
        "name": "txyz_search_smart",
        "description": "Automatically selects the best search type based on the query (may include either scholarly materials or web pages)",
        "prompt": "What are the latest developments in climate change research?"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pathintegral-institute/mcp.science#subdirectory=servers/txyz-search",
          "mcp-txyz-search"
        ],
        "env": {
          "TXYZ_API_KEY": "${TXYZ_API_KEY}"
        },
        "description": "Run using uvx"
      }
    },
    "examples": [
      {
        "title": "Academic Search",
        "description": "Search for academic papers on a topic",
        "prompt": "Find recent research papers about quantum computing"
      },
      {
        "title": "Web Search",
        "description": "Search the web for information",
        "prompt": "Find information about the latest smartphone releases"
      },
      {
        "title": "Smart Search",
        "description": "Let the system choose the best search type",
        "prompt": "What are the latest developments in climate change research?"
      }
    ],
    "categories": [
      "Web Services"
    ],
    "is_official": true
  },
  "google-maps": {
    "name": "google-maps",
    "display_name": "Google Maps",
    "description": "Location services, directions, and place details",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/google-maps",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Google Maps",
      "Geolocation"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-google-maps"
        ],
        "env": {
          "GOOGLE_MAPS_API_KEY": "${GOOGLE_MAPS_API_KEY}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "GOOGLE_MAPS_API_KEY",
          "mcp/google-maps"
        ],
        "env": {
          "GOOGLE_MAPS_API_KEY": "${GOOGLE_MAPS_API_KEY}"
        }
      }
    },
    "arguments": {
      "GOOGLE_MAPS_API_KEY": {
        "description": "Your Google Maps API key obtained from the Google Developers Console.",
        "required": true,
        "example": "AIzaSyD..."
      }
    },
    "tools": [
      {
        "name": "maps_geocode",
        "description": "Convert an address into geographic coordinates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The address to geocode"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "maps_reverse_geocode",
        "description": "Convert coordinates into an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "latitude": {
              "type": "number",
              "description": "Latitude coordinate"
            },
            "longitude": {
              "type": "number",
              "description": "Longitude coordinate"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ]
        }
      },
      {
        "name": "maps_search_places",
        "description": "Search for places using Google Places API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "location": {
              "type": "object",
              "properties": {
                "latitude": {
                  "type": "number"
                },
                "longitude": {
                  "type": "number"
                }
              },
              "description": "Optional center point for the search"
            },
            "radius": {
              "type": "number",
              "description": "Search radius in meters (max 50000)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "maps_place_details",
        "description": "Get detailed information about a specific place",
        "inputSchema": {
          "type": "object",
          "properties": {
            "place_id": {
              "type": "string",
              "description": "The place ID to get details for"
            }
          },
          "required": [
            "place_id"
          ]
        }
      },
      {
        "name": "maps_distance_matrix",
        "description": "Calculate travel distance and time for multiple origins and destinations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origins": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of origin addresses or coordinates"
            },
            "destinations": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of destination addresses or coordinates"
            },
            "mode": {
              "type": "string",
              "description": "Travel mode (driving, walking, bicycling, transit)",
              "enum": [
                "driving",
                "walking",
                "bicycling",
                "transit"
              ]
            }
          },
          "required": [
            "origins",
            "destinations"
          ]
        }
      },
      {
        "name": "maps_elevation",
        "description": "Get elevation data for locations on the earth",
        "inputSchema": {
          "type": "object",
          "properties": {
            "locations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "latitude": {
                    "type": "number"
                  },
                  "longitude": {
                    "type": "number"
                  }
                },
                "required": [
                  "latitude",
                  "longitude"
                ]
              },
              "description": "Array of locations to get elevation for"
            }
          },
          "required": [
            "locations"
          ]
        }
      },
      {
        "name": "maps_directions",
        "description": "Get directions between two points",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "Starting point address or coordinates"
            },
            "destination": {
              "type": "string",
              "description": "Ending point address or coordinates"
            },
            "mode": {
              "type": "string",
              "description": "Travel mode (driving, walking, bicycling, transit)",
              "enum": [
                "driving",
                "walking",
                "bicycling",
                "transit"
              ]
            }
          },
          "required": [
            "origin",
            "destination"
          ]
        }
      }
    ],
    "is_official": true
  },
  "mcp-server-starrocks": {
    "display_name": "StarRocks Official MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/StarRocks/mcp-server-starrocks"
    },
    "homepage": "https://github.com/StarRocks/mcp-server-starrocks",
    "author": {
      "name": "StarRocks"
    },
    "license": "Apache-2.0",
    "tags": [
      "database",
      "sql",
      "starrocks"
    ],
    "arguments": {
      "STARROCKS_HOST": {
        "description": "StarRocks database host",
        "required": false,
        "example": "localhost"
      },
      "STARROCKS_PORT": {
        "description": "StarRocks database port",
        "required": false,
        "example": "9030"
      },
      "STARROCKS_USER": {
        "description": "StarRocks database user",
        "required": false,
        "example": "root"
      },
      "STARROCKS_PASSWORD": {
        "description": "StarRocks database password",
        "required": false,
        "example": ""
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-starrocks"
        ],
        "env": {
          "STARROCKS_HOST": "localhost",
          "STARROCKS_PORT": "9030",
          "STARROCKS_USER": "root",
          "STARROCKS_PASSWORD": ""
        },
        "description": "Run using Python with uv package manager",
        "recommended": true
      }
    },
    "examples": [],
    "name": "mcp-server-starrocks",
    "description": "The StarRocks MCP Server acts as a bridge between AI assistants and StarRocks databases, allowing for direct SQL execution and database exploration without requiring complex setup or configuration.",
    "categories": [
      "Databases"
    ],
    "tools": [
      {
        "name": "read_query",
        "description": "Execute a SELECT query or commands that return a ResultSet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "write_query",
        "description": "Execute an DDL/DML or other StarRocks command that do not have a ResultSet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SQL to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [
      {
        "uri": "starrocks:///databases",
        "name": "All Databases",
        "description": "List all databases in StarRocks",
        "mimeType": "text/plain",
        "annotations": null
      }
    ],
    "is_official": true
  },
  "mcp-gitee": {
    "display_name": "Gitee MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/oschina/mcp-gitee"
    },
    "homepage": "https://gitee.com/oschina/mcp-gitee",
    "author": {
      "name": "oschina"
    },
    "license": "MIT",
    "tags": [
      "gitee",
      "mcp",
      "repository",
      "issues",
      "pull requests"
    ],
    "arguments": {
      "GITEE_ACCESS_TOKEN": {
        "description": "Gitee access token",
        "required": true,
        "example": "<your personal access token>"
      },
      "api-base": {
        "description": "Gitee API base URL",
        "required": false,
        "example": "https://gitee.com/api/v5"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "go",
        "args": [
          "install",
          "gitee.com/oschina/mcp-gitee@latest"
        ],
        "description": "Install using Go",
        "recommended": false
      }
    },
    "examples": [
      {
        "title": "Get repository Issues",
        "description": "Retrieve issues from a Gitee repository",
        "prompt": "Use the list_repo_issues tool to get all issues from my repository"
      },
      {
        "title": "Create Pull Request",
        "description": "Implement code and create a Pull Request based on Issue details",
        "prompt": "Create a pull request to fix issue #123 in my repository"
      },
      {
        "title": "Comment & Close Issue",
        "description": "Add a comment to an issue and close it",
        "prompt": "Comment on issue #123 saying the fix is complete and close the issue"
      }
    ],
    "name": "mcp-gitee",
    "description": "Gitee MCP Server is a Model Context Protocol (MCP) server implementation for Gitee. It provides a set of tools for interacting with Gitee's API, allowing AI assistants to manage repositories, issues, pull requests, and more.",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "chronulus-mcp": {
    "display_name": "Chronulus MCP",
    "repository": {
      "type": "git",
      "url": "https://github.com/ChronulusAI/chronulus-mcp"
    },
    "license": "[NOT GIVEN]",
    "homepage": "https://www.chronulus.com",
    "author": {
      "name": "ChronulusAI"
    },
    "tags": [
      "forecasting",
      "prediction",
      "AI agents"
    ],
    "arguments": {
      "CHRONULUS_API_KEY": {
        "description": "API key for Chronulus services",
        "required": true,
        "example": "<YOUR_CHRONULUS_API_KEY>"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "chronulus-mcp"
        ],
        "env": {
          "CHRONULUS_API_KEY": "<YOUR_CHRONULUS_API_KEY>"
        },
        "description": "Install and run using uvx"
      },
      "pip": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "chronulus_mcp"
        ],
        "package": "chronulus-mcp",
        "env": {
          "CHRONULUS_API_KEY": "<YOUR_CHRONULUS_API_KEY>"
        },
        "description": "Install using pip from PyPI"
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "CHRONULUS_API_KEY",
          "chronulus-mcp"
        ],
        "env": {
          "CHRONULUS_API_KEY": "<YOUR_CHRONULUS_API_KEY>"
        },
        "description": "Run using Docker"
      }
    },
    "name": "chronulus-mcp",
    "description": "<img width=\"150px\" src=\"https://www.chronulus.com/brand-assets/chronulus-logo-blue-on-alpha-square.png\" alt=\"Chronulus AI\">",
    "categories": [
      "MCP Tools"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "create_chronulus_session",
        "description": "\nA tool that creates a new Chronulus Session and returns a session_id\n\nWhen to use this tool:\n- Use this tool when a user has requested a forecast or prediction for a new use case\n- Before calling this tool make sure you have enough information to write a well-defined situation and task. You might\nneed to ask clarifying questions in order to get this from the user.\n- The same session_id can be reused as long as the situation and task remain the same\n- If user wants to forecast a different use case, create a new session and then use that\n\nHow to use this tool:\n- To create a session, you need to provide a situation and task that describe the forecasting use case \n- If the user has not provided enough detail for you to decompose the use case into a \n    situation (broad or background context) and task (specific requirements for the forecast), \n    ask them to elaborate since more detail will result in a better / more accurate forecast.\n- Once created, this will generate a unique session_id that can be used to when calling other tools about this use case.\n",
        "inputSchema": {
          "properties": {
            "name": {
              "description": "A short descriptive name for the use case defined in the session.",
              "title": "Name",
              "type": "string"
            },
            "situation": {
              "description": "The broader context for the use case",
              "title": "Situation",
              "type": "string"
            },
            "task": {
              "description": "Specific details on the forecasting or prediction task.",
              "title": "Task",
              "type": "string"
            }
          },
          "required": [
            "name",
            "situation",
            "task"
          ],
          "title": "create_chronulus_sessionArguments",
          "type": "object"
        }
      },
      {
        "name": "create_forecasting_agent_and_get_forecast",
        "description": "\nThis tool creates a NormalizedForecaster agent with your session and input data model and then provides a forecast input \ndata to the agent and returns the prediction data and text explanation from the agent.\n\nWhen to use this tool:\n- Use this tool to request a forecast from Chronulus\n- This tool is specifically made to forecast values between 0 and 1 and does not require historical data\n- The prediction can be thought of as seasonal weights, probabilities, or shares of something as in the decimal representation of a percent\n\nHow to use this tool:\n- First, make sure you have a session_id for the forecasting or prediction use case.\n- Next, think about the features / characteristics most suitable for producing the requested forecast and then \ncreate an input_data_model that corresponds to the input_data you will provide for the thing being forecasted.\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, add information about the forecasting horizon and time scale requested by the user\n- Assume the dates and datetimes in the prediction results are already converted to the appropriate local timezone if location is a factor in the use case. So do not try to convert from UTC to local time when plotting.\n- When plotting the predictions, use a Rechart time series with the appropriate axes labeled and with the prediction explanation displayed as a caption below the plot\n",
        "inputSchema": {
          "$defs": {
            "InputField": {
              "properties": {
                "name": {
                  "description": "Field name. Should be a valid python variable name.",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "description": "A description of the value you will pass in the field.",
                  "title": "Description",
                  "type": "string"
                },
                "type": {
                  "default": "str",
                  "description": "The type of the field. \n        ImageFromFile takes a single named-argument, 'file_path' as input which should be absolute path to the image to be included. So you should provide this input as json, eg. {'file_path': '/path/to/image'}.\n        ",
                  "enum": [
                    "str",
                    "Text",
                    "List[Text]",
                    "TextFromFile",
                    "List[TextFromFile]",
                    "PdfFromFile",
                    "List[PdfFromFile]",
                    "ImageFromFile",
                    "List[ImageFromFile]"
                  ],
                  "title": "Type",
                  "type": "string"
                }
              },
              "required": [
                "name",
                "description"
              ],
              "title": "InputField",
              "type": "object"
            }
          },
          "properties": {
            "session_id": {
              "description": "The session_id for the forecasting or prediction use case",
              "title": "Session Id",
              "type": "string"
            },
            "input_data_model": {
              "description": "Metadata on the fields you will include in the input_data.",
              "items": {
                "$ref": "#/$defs/InputField"
              },
              "title": "Input Data Model",
              "type": "array"
            },
            "input_data": {
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  {
                    "items": {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    "type": "array"
                  }
                ]
              },
              "description": "The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.",
              "title": "Input Data",
              "type": "object"
            },
            "forecast_start_dt_str": {
              "description": "The datetime str in '%Y-%m-%d %H:%M:%S' format of the first value in the forecast horizon.",
              "title": "Forecast Start Dt Str",
              "type": "string"
            },
            "time_scale": {
              "default": "days",
              "description": "The times scale of the forecast horizon. Valid time scales are 'hours', 'days', and 'weeks'.",
              "title": "Time Scale",
              "type": "string"
            },
            "horizon_len": {
              "default": 60,
              "description": "The integer length of the forecast horizon. Eg., 60 if a 60 day forecast was requested.",
              "title": "Horizon Len",
              "type": "integer"
            }
          },
          "required": [
            "session_id",
            "input_data_model",
            "input_data",
            "forecast_start_dt_str"
          ],
          "title": "create_forecasting_agent_and_get_forecastArguments",
          "type": "object"
        }
      },
      {
        "name": "reuse_forecasting_agent_and_get_forecast",
        "description": "\nThis tool creates a NormalizedForecaster agent with your session and input data model and then provides a forecast input \ndata to the agent and returns the prediction data and text explanation from the agent.\n\nWhen to use this tool:\n- Use this tool to request a forecast from Chronulus\n- This tool is specifically made to forecast values between 0 and 1 and does not require historical data\n- The prediction can be thought of as seasonal weights, probabilities, or shares of something as in the decimal representation of a percent\n\nHow to use this tool:\n- First, make sure you have a session_id for the forecasting or prediction use case.\n- Next, think about the features / characteristics most suitable for producing the requested forecast and then \ncreate an input_data_model that corresponds to the input_data you will provide for the thing being forecasted.\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, add information about the forecasting horizon and time scale requested by the user\n- Assume the dates and datetimes in the prediction results are already converted to the appropriate local timezone if location is a factor in the use case. So do not try to convert from UTC to local time when plotting.\n- When plotting the predictions, use a Rechart time series with the appropriate axes labeled and with the prediction explanation displayed as a caption below the plot\n",
        "inputSchema": {
          "properties": {
            "agent_id": {
              "description": "The agent_id for the forecasting or prediction use case and previously defined input_data_model",
              "title": "Agent Id",
              "type": "string"
            },
            "input_data": {
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  {
                    "items": {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    "type": "array"
                  }
                ]
              },
              "description": "The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.",
              "title": "Input Data",
              "type": "object"
            },
            "forecast_start_dt_str": {
              "description": "The datetime str in '%Y-%m-%d %H:%M:%S' format of the first value in the forecast horizon.",
              "title": "Forecast Start Dt Str",
              "type": "string"
            },
            "time_scale": {
              "default": "days",
              "description": "The times scale of the forecast horizon. Valid time scales are 'hours', 'days', and 'weeks'.",
              "title": "Time Scale",
              "type": "string"
            },
            "horizon_len": {
              "default": 60,
              "description": "The integer length of the forecast horizon. Eg., 60 if a 60 day forecast was requested.",
              "title": "Horizon Len",
              "type": "integer"
            }
          },
          "required": [
            "agent_id",
            "input_data",
            "forecast_start_dt_str"
          ],
          "title": "reuse_forecasting_agent_and_get_forecastArguments",
          "type": "object"
        }
      },
      {
        "name": "rescale_forecast",
        "description": "\nA tool that rescales the prediction data (values between 0 and 1) from the NormalizedForecaster agent to scale required for a use case\n\nWhen to use this tool:\n- Use this tool when there is enough information from the user or use cases to determine a reasonable min and max for the forecast predictions\n- Do not attempt to rescale or denormalize the predictions on your own without using this tool.\n- Also, if the best min and max for the use case is 0 and 1, then no rescaling is needed since that is already the scale of the predictions.\n- If a user requests to convert from probabilities to a unit in levels, be sure to caveat your use of this tool by noting that\n    probabilities do not always scale uniformly to levels. Rescaling can be used as a rough first-pass estimate. But for best results, \n    it would be better to start a new Chronulus forecasting use case predicting in levels from the start.\n    \nHow to use this tool:\n- To use this tool present prediction_id from the normalized prediction and the min and max as floats\n- If the user is also changing units, consider if the units will be inverted and set the inverse scale to True if needed.\n- When plotting the rescaled predictions, use a Rechart time series plot with the appropriate axes labeled and include the chronulus \n    prediction explanation as a caption below the plot. \n- If you would like to add additional notes about the scaled series, put these below the original prediction explanation. \n",
        "inputSchema": {
          "properties": {
            "prediction_id": {
              "description": "The prediction_id from a prediction result",
              "title": "Prediction Id",
              "type": "string"
            },
            "y_min": {
              "description": "The expected smallest value for the use case. E.g., for product sales, 0 would be the least possible value for sales.",
              "title": "Y Min",
              "type": "number"
            },
            "y_max": {
              "description": "The expected largest value for the use case. E.g., for product sales, 0 would be the largest possible value would be given by the user or determined from this history of sales for the product in question or a similar product.",
              "title": "Y Max",
              "type": "number"
            },
            "invert_scale": {
              "default": false,
              "description": "Set this flag to true if the scale of the new units will run in the opposite direction from the inputs.",
              "title": "Invert Scale",
              "type": "boolean"
            }
          },
          "required": [
            "prediction_id",
            "y_min",
            "y_max"
          ],
          "title": "rescale_forecastArguments",
          "type": "object"
        }
      },
      {
        "name": "save_forecast",
        "description": "\nA tool that saves a Chronulus forecast from NormalizedForecaster to separate CSV and TXT files\n\nWhen to use this tool:\n- Use this tool when you need to save both the forecast data and its explanation to files\n- The forecast data will be saved as a CSV file for data analysis\n- The forecast explanation will be saved as a TXT file for reference\n- Both files will be saved in the same directory specified by output_path\n- This tool can also be used to directly save rescaled predictions without first calling the rescaling tool\n\nHow to use this tool:\n- Provide the prediction_id from a previous forecast\n- Specify the output_path where both files should be saved\n- Provide csv_name for the forecast data file (must end in .csv)\n- Provide txt_name for the explanation file (must end in .txt)\n- Optionally provide y_min and y_max to rescale the predictions (defaults to 0)\n- Set invert_scale to True if the target units run in the opposite direction\n- The tool will provide status updates through the MCP context\n",
        "inputSchema": {
          "properties": {
            "prediction_id": {
              "description": "The prediction_id from a prediction result",
              "title": "Prediction Id",
              "type": "string"
            },
            "output_path": {
              "description": "The path where the CSV file should be saved. Should end in .csv",
              "title": "Output Path",
              "type": "string"
            },
            "csv_name": {
              "description": "The path where the CSV file should be saved. Should end in .csv",
              "title": "Csv Name",
              "type": "string"
            },
            "txt_name": {
              "description": "The name of the TXT file to be saved. Should end in .txt",
              "title": "Txt Name",
              "type": "string"
            },
            "y_min": {
              "default": 0.0,
              "description": "The expected smallest value for the use case. E.g., for product sales, 0 would be the least possible value for sales.",
              "title": "Y Min",
              "type": "number"
            },
            "y_max": {
              "default": 1.0,
              "description": "The expected largest value for the use case. E.g., for product sales, 0 would be the largest possible value would be given by the user or determined from this history of sales for the product in question or a similar product.",
              "title": "Y Max",
              "type": "number"
            },
            "invert_scale": {
              "default": false,
              "description": "Set this flag to true if the scale of the new units will run in the opposite direction from the inputs.",
              "title": "Invert Scale",
              "type": "boolean"
            }
          },
          "required": [
            "prediction_id",
            "output_path",
            "csv_name",
            "txt_name"
          ],
          "title": "save_forecastArguments",
          "type": "object"
        }
      },
      {
        "name": "create_prediction_agent_and_get_predictions",
        "description": "\nThis tool creates a BinaryPredictor agent with your session and input data model and then provides prediction input \ndata to the agent and returns the consensus a prediction from a panel of experts along with their individual estimates\nand text explanations. The agent also returns the alpha and beta parameters for a Beta distribution that allows you to\nestimate the confidence interval of its consensus probability estimate.\n\nWhen to use this tool:\n- Use this tool to request a probability estimate from Chronulus in situation when there is a binary outcome\n- This tool is specifically made to estimate the probability of an event occurring and not occurring and does not \nrequire historical data\n\nHow to use this tool:\n- First, make sure you have a session_id for the prediction use case.\n- Next, think about the features / characteristics most suitable for producing the requested prediction and then \ncreate an input_data_model that corresponds to the input_data you will provide for the thing or event being predicted.\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, provide the number of experts to consult. The minimum and default number is 2, but users may request up to 30\n30 opinions in situations where reproducibility and risk sensitively is of the utmost importance. In most cases, 2 to 5 \nexperts is sufficient. \n",
        "inputSchema": {
          "$defs": {
            "InputField": {
              "properties": {
                "name": {
                  "description": "Field name. Should be a valid python variable name.",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "description": "A description of the value you will pass in the field.",
                  "title": "Description",
                  "type": "string"
                },
                "type": {
                  "default": "str",
                  "description": "The type of the field. \n        ImageFromFile takes a single named-argument, 'file_path' as input which should be absolute path to the image to be included. So you should provide this input as json, eg. {'file_path': '/path/to/image'}.\n        ",
                  "enum": [
                    "str",
                    "Text",
                    "List[Text]",
                    "TextFromFile",
                    "List[TextFromFile]",
                    "PdfFromFile",
                    "List[PdfFromFile]",
                    "ImageFromFile",
                    "List[ImageFromFile]"
                  ],
                  "title": "Type",
                  "type": "string"
                }
              },
              "required": [
                "name",
                "description"
              ],
              "title": "InputField",
              "type": "object"
            }
          },
          "properties": {
            "session_id": {
              "description": "The session_id for the forecasting or prediction use case",
              "title": "Session Id",
              "type": "string"
            },
            "input_data_model": {
              "description": "Metadata on the fields you will include in the input_data.",
              "items": {
                "$ref": "#/$defs/InputField"
              },
              "title": "Input Data Model",
              "type": "array"
            },
            "input_data": {
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  {
                    "items": {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    "type": "array"
                  }
                ]
              },
              "description": "The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.",
              "title": "Input Data",
              "type": "object"
            },
            "num_experts": {
              "description": "The number of experts to consult when forming consensus",
              "title": "Num Experts",
              "type": "integer"
            }
          },
          "required": [
            "session_id",
            "input_data_model",
            "input_data",
            "num_experts"
          ],
          "title": "create_prediction_agent_and_get_predictionsArguments",
          "type": "object"
        }
      },
      {
        "name": "reuse_prediction_agent_and_get_prediction",
        "description": "\nThis tool provides prediction input data to a previously created Chronulus BinaryPredictor agent and returns the \nconsensus a prediction from a panel of experts along with their individual estimates and text explanations. The agent \nalso returns the alpha and beta parameters for a Beta distribution that allows you to estimate the confidence interval \nof its consensus probability estimate.\n\nWhen to use this tool:\n- Use this tool to request a prediction from a Chronulus prediction agent that you have already created and when your \ninput data model is unchanged\n- Use this tool to request a probability estimate from an existing prediction agent in a situation when there is a binary outcome\n- This tool is specifically made to estimate the probability of an event occurring and not occurring and does not \nrequire historical data\n\nHow to use this tool:\n- First, make sure you have a session_id for the prediction use case.\n- Next, think about the features / characteristics most suitable for producing the requested prediction and then \ncreate an input_data_model that corresponds to the input_data you will provide for the thing or event being predicted.\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, provide the number of experts to consult. The minimum and default number is 2, but users may request up to 30\n30 opinions in situations where reproducibility and risk sensitively is of the utmost importance. In most cases, 2 to 5 \nexperts is sufficient. \n\nHow to use this tool:\n- First, make sure you have an agent_id for the prediction agent. The agent is already attached to the correct session. \nSo you do not need to provide a session_id.\n- Next, reference the input data model that you previously used with the agent and create new input data for the item \nbeing predicted that aligns with the previously specified input data model\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, provide the number of experts to consult. The minimum and default number is 2, but users may request up to 30\n30 opinions in situations where reproducibility and risk sensitively is of the utmost importance. In most cases, 2 to 5 \nexperts is sufficient. \n",
        "inputSchema": {
          "properties": {
            "agent_id": {
              "description": "The agent_id for the forecasting or prediction use case and previously defined input_data_model",
              "title": "Agent Id",
              "type": "string"
            },
            "input_data": {
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  {
                    "items": {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    "type": "array"
                  }
                ]
              },
              "description": "The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.",
              "title": "Input Data",
              "type": "object"
            },
            "num_experts": {
              "description": "The number of experts to consult when forming consensus",
              "title": "Num Experts",
              "type": "integer"
            }
          },
          "required": [
            "agent_id",
            "input_data",
            "num_experts"
          ],
          "title": "reuse_prediction_agent_and_get_predictionArguments",
          "type": "object"
        }
      },
      {
        "name": "save_prediction_analysis_html",
        "description": "\nA tool that saves an analysis of a BinaryPredictor prediction to HTML. \n\nThe analysis includes a plot of the theoretical and empirical beta distribution estimated by Chronulus and also\nlist the opinions provided by each expert.\n\nWhen to use this tool:\n- Use this tool when you need to save the BinaryPredictor estimates to for the user\n\nHow to use this tool:\n- Provide the request_id from a previous prediction response\n- Specify the output_path where the html should be saved\n- Provide html_name for the file (must end in .html)\n- The tool will provide status updates through the MCP context\n",
        "inputSchema": {
          "properties": {
            "request_id": {
              "description": "The request_id from the BinaryPredictor result",
              "title": "Request Id",
              "type": "string"
            },
            "output_path": {
              "description": "The path where the HTML file should be saved.",
              "title": "Output Path",
              "type": "string"
            },
            "html_name": {
              "description": "The path where the HTML file should be saved.",
              "title": "Html Name",
              "type": "string"
            },
            "title": {
              "description": "Title of analysis",
              "title": "Title",
              "type": "string"
            },
            "plot_label": {
              "description": "Label for the Beta plot",
              "title": "Plot Label",
              "type": "string"
            },
            "chronulus_prediction_summary": {
              "description": "A summary paragraph distilling prediction results and expert opinions provided by Chronulus",
              "title": "Chronulus Prediction Summary",
              "type": "string"
            },
            "dist_shape": {
              "description": "A one line description of the shape of the distribution of predictions",
              "title": "Dist Shape",
              "type": "string"
            },
            "dist_shape_interpretation": {
              "description": "2-3 sentences interpreting the shape of the distribution of predictions in layman's terms",
              "title": "Dist Shape Interpretation",
              "type": "string"
            }
          },
          "required": [
            "request_id",
            "output_path",
            "html_name",
            "title",
            "plot_label",
            "chronulus_prediction_summary",
            "dist_shape",
            "dist_shape_interpretation"
          ],
          "title": "save_prediction_analysis_htmlArguments",
          "type": "object"
        }
      },
      {
        "name": "get_risk_assessment_scorecard",
        "description": "\nA tool that retrieves the risk assessment scorecard for the Chronulus Session in Markdown format\n\nWhen to use this tool:\n- Use this tool when the use asks about the risk level or safety concerns of a forecasting use case\n- You may also use this tool to provide justification to a user if you would like to warn them of the implications of \n    what they are asking you to forecasting or predict.\n\nHow to use this tool:\n- Make sure you have a session_id for the forecasting or prediction use case\n- When displaying the scorecard markdown for the user, you should use an MDX-style React component\n",
        "inputSchema": {
          "properties": {
            "session_id": {
              "description": "The session_id for the forecasting or prediction use case",
              "title": "Session Id",
              "type": "string"
            },
            "as_json": {
              "description": "If true, returns the scorecard in JSON format, otherwise returns a markdown formatted scorecard",
              "title": "As Json",
              "type": "boolean"
            }
          },
          "required": [
            "session_id",
            "as_json"
          ],
          "title": "get_risk_assessment_scorecardArguments",
          "type": "object"
        }
      }
    ]
  },
  "spotify": {
    "name": "spotify",
    "display_name": "Spotify",
    "description": "This MCP allows an LLM to play and use Spotify.",
    "repository": {
      "type": "git",
      "url": "https://github.com/varunneal/spotify-mcp"
    },
    "homepage": "https://github.com/varunneal/spotify-mcp",
    "author": {
      "name": "varunneal"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "spotify",
      "audio"
    ],
    "examples": [
      {
        "title": "Basic Playback Control",
        "description": "Use the MCP to start, pause, or skip songs on Spotify.",
        "prompt": "Start playing a song on Spotify."
      },
      {
        "title": "Search for Tracks",
        "description": "Search for tracks, albums, artists, or playlists using the Spotify API.",
        "prompt": "Search for the album 'Thriller'."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/varunneal/spotify-mcp",
          "spotify-mcp"
        ],
        "env": {
          "SPOTIFY_CLIENT_ID": "${SPOTIFY_CLIENT_ID}",
          "SPOTIFY_CLIENT_SECRET": "${SPOTIFY_CLIENT_SECRET}",
          "SPOTIFY_REDIRECT_URI": "${SPOTIFY_REDIRECT_URI}"
        }
      }
    },
    "arguments": {
      "SPOTIFY_CLIENT_ID": {
        "description": "The client ID for your Spotify application, required to authenticate with the Spotify API.",
        "required": true,
        "example": "your_spotify_client_id_here"
      },
      "SPOTIFY_CLIENT_SECRET": {
        "description": "The client secret for your Spotify application, needed for secure authentication with the API.",
        "required": true,
        "example": "your_spotify_client_secret_here"
      },
      "SPOTIFY_REDIRECT_URI": {
        "description": "The redirect URI you specified when creating the Spotify application, needed for the OAuth authentication process.",
        "required": false,
        "example": "http://localhost:8888"
      }
    },
    "tools": [
      {
        "name": "SpotifyPlayback",
        "description": "Manages the current playback with the following actions:\n    - get: Get information about user's current track.\n    - start: Starts playing new item or resumes current playback if called with no uri.\n    - pause: Pauses current playback.\n    - skip: Skips current track.\n    ",
        "inputSchema": {
          "description": "Manages the current playback with the following actions:\n- get: Get information about user's current track.\n- start: Starts playing new item or resumes current playback if called with no uri.\n- pause: Pauses current playback.\n- skip: Skips current track.",
          "properties": {
            "action": {
              "description": "Action to perform: 'get', 'start', 'pause' or 'skip'.",
              "title": "Action",
              "type": "string"
            },
            "spotify_uri": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Spotify uri of item to play for 'start' action. If omitted, resumes current playback.",
              "title": "Spotify Uri"
            },
            "num_skips": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 1,
              "description": "Number of tracks to skip for `skip` action.",
              "title": "Num Skips"
            }
          },
          "required": [
            "action"
          ],
          "title": "Playback",
          "type": "object"
        }
      },
      {
        "name": "SpotifySearch",
        "description": "Search for tracks, albums, artists, or playlists on Spotify.",
        "inputSchema": {
          "description": "Search for tracks, albums, artists, or playlists on Spotify.",
          "properties": {
            "query": {
              "description": "query term",
              "title": "Query",
              "type": "string"
            },
            "qtype": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "track",
              "description": "Type of items to search for (track, album, artist, playlist, or comma-separated combination)",
              "title": "Qtype"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 10,
              "description": "Maximum number of items to return",
              "title": "Limit"
            }
          },
          "required": [
            "query"
          ],
          "title": "Search",
          "type": "object"
        }
      },
      {
        "name": "SpotifyQueue",
        "description": "Manage the playback queue - get the queue or add tracks.",
        "inputSchema": {
          "description": "Manage the playback queue - get the queue or add tracks.",
          "properties": {
            "action": {
              "description": "Action to perform: 'add' or 'get'.",
              "title": "Action",
              "type": "string"
            },
            "track_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Track ID to add to queue (required for add action)",
              "title": "Track Id"
            }
          },
          "required": [
            "action"
          ],
          "title": "Queue",
          "type": "object"
        }
      },
      {
        "name": "SpotifyGetInfo",
        "description": "Get detailed information about a Spotify item (track, album, artist, or playlist).",
        "inputSchema": {
          "description": "Get detailed information about a Spotify item (track, album, artist, or playlist).",
          "properties": {
            "item_uri": {
              "description": "URI of the item to get information about. If 'playlist' or 'album', returns its tracks. If 'artist', returns albums and top tracks.",
              "title": "Item Uri",
              "type": "string"
            }
          },
          "required": [
            "item_uri"
          ],
          "title": "GetInfo",
          "type": "object"
        }
      }
    ]
  },
  "any-chat-completions": {
    "name": "any-chat-completions",
    "display_name": "Any Chat Completions",
    "description": "Interact with any OpenAI SDK Compatible Chat Completions API like OpenAI, Perplexity, Groq, xAI and many more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pyroprompts/any-chat-completions-mcp"
    },
    "homepage": "https://github.com/pyroprompts/any-chat-completions-mcp",
    "author": {
      "name": "pyroprompts"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Claude",
      "OpenAI",
      "API",
      "Chat Completion"
    ],
    "examples": [
      {
        "title": "OpenAI Integration",
        "description": "Integrate OpenAI into Claude Desktop",
        "prompt": "Configure the MCP server to use OpenAI's API."
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/pyroprompts/any-chat-completions-mcp"
        ],
        "env": {
          "AI_CHAT_KEY": "${AI_CHAT_KEY}",
          "AI_CHAT_NAME": "${AI_CHAT_NAME}",
          "AI_CHAT_MODEL": "${AI_CHAT_MODEL}",
          "AI_CHAT_BASE_URL": "${AI_CHAT_BASE_URL}"
        }
      }
    },
    "arguments": {
      "AI_CHAT_KEY": {
        "description": "API key for authentication with the chat service provider.",
        "required": true,
        "example": "your_openai_secret_key_here"
      },
      "AI_CHAT_NAME": {
        "description": "The name of the AI chat provider to use, like 'OpenAI' or 'PyroPrompts'.",
        "required": true,
        "example": "OpenAI"
      },
      "AI_CHAT_MODEL": {
        "description": "Specifies which model to be used for the chat service, e.g., 'gpt-4o'.",
        "required": true,
        "example": "gpt-4o"
      },
      "AI_CHAT_BASE_URL": {
        "description": "The base URL for the API service of the chat provider.",
        "required": true,
        "example": "https://api.openai.com/v1"
      }
    },
    "tools": [
      {
        "name": "chat-with-${AI_CHAT_NAME_CLEAN}",
        "description": "Text chat with ${AI_CHAT_NAME}",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content of the chat to send to ${AI_CHAT_NAME}"
            }
          },
          "required": [
            "content"
          ]
        }
      }
    ]
  },
  "google-tasks": {
    "name": "google-tasks",
    "display_name": "Google Tasks",
    "description": "Google Tasks API Model Context Protocol Server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/zcaceres/gtasks-mcp"
    },
    "homepage": "https://github.com/zcaceres/gtasks-mcp",
    "author": {
      "name": "zcaceres"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "google",
      "tasks",
      "productivity"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/zcaceres/gtasks-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Search for tasks in Google Tasks.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for tasks"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "list",
        "description": "List all tasks in Google Tasks.",
        "inputSchema": {
          "cursor": {
            "type": "string",
            "description": "Cursor for pagination",
            "optional": true
          }
        },
        "required": []
      },
      {
        "name": "create",
        "description": "Create a new task in Google Tasks.",
        "inputSchema": {
          "taskListId": {
            "type": "string",
            "description": "Task list ID",
            "optional": true
          },
          "title": {
            "type": "string",
            "description": "Task title"
          },
          "notes": {
            "type": "string",
            "description": "Task notes",
            "optional": true
          },
          "due": {
            "type": "string",
            "description": "Due date",
            "optional": true
          }
        },
        "required": [
          "title"
        ]
      },
      {
        "name": "update",
        "description": "Update an existing task in Google Tasks.",
        "inputSchema": {
          "taskListId": {
            "type": "string",
            "description": "Task list ID",
            "optional": true
          },
          "id": {
            "type": "string",
            "description": "Task ID"
          },
          "uri": {
            "type": "string",
            "description": "Task URI"
          },
          "title": {
            "type": "string",
            "description": "New task title",
            "optional": true
          },
          "notes": {
            "type": "string",
            "description": "New task notes",
            "optional": true
          },
          "status": {
            "type": "string",
            "description": "New task status ('needsAction' or 'completed')",
            "optional": true
          },
          "due": {
            "type": "string",
            "description": "New due date",
            "optional": true
          }
        },
        "required": [
          "id",
          "uri"
        ]
      },
      {
        "name": "delete",
        "description": "Delete a task in Google Tasks.",
        "inputSchema": {
          "taskListId": {
            "type": "string",
            "description": "Task list ID"
          },
          "id": {
            "type": "string",
            "description": "Task ID"
          }
        },
        "required": [
          "taskListId",
          "id"
        ]
      },
      {
        "name": "clear",
        "description": "Clear completed tasks from a Google Tasks task list.",
        "inputSchema": {
          "taskListId": {
            "type": "string",
            "description": "Task list ID"
          }
        },
        "required": [
          "taskListId"
        ]
      }
    ]
  },
  "greptimedb": {
    "display_name": "GreptimeDB",
    "repository": {
      "type": "git",
      "url": "https://github.com/GreptimeTeam/greptimedb"
    },
    "homepage": "https://greptime.com",
    "author": {
      "name": "GreptimeTeam"
    },
    "license": "Apache License 2.0",
    "tags": [
      "database",
      "timeseries",
      "observability",
      "metrics",
      "logs",
      "events"
    ],
    "arguments": {
      "http-addr": {
        "description": "HTTP address to bind to",
        "required": true,
        "example": "0.0.0.0:4000"
      },
      "rpc-bind-addr": {
        "description": "RPC address to bind to",
        "required": true,
        "example": "0.0.0.0:4001"
      },
      "mysql-addr": {
        "description": "MySQL protocol address to bind to",
        "required": true,
        "example": "0.0.0.0:4002"
      },
      "postgres-addr": {
        "description": "PostgreSQL protocol address to bind to",
        "required": true,
        "example": "0.0.0.0:4003"
      }
    },
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-p",
          "127.0.0.1:4000-4003:4000-4003",
          "-v",
          "$(pwd)/greptimedb:./greptimedb_data",
          "--name",
          "greptime",
          "--rm",
          "greptime/greptimedb:latest",
          "standalone",
          "start",
          "--http-addr",
          "0.0.0.0:4000",
          "--rpc-bind-addr",
          "0.0.0.0:4001",
          "--mysql-addr",
          "0.0.0.0:4002",
          "--postgres-addr",
          "0.0.0.0:4003"
        ],
        "recommended": true,
        "description": "Run GreptimeDB in a Docker container"
      },
      "source": {
        "type": "custom",
        "command": "cargo",
        "args": [
          "run",
          "--",
          "standalone",
          "start"
        ],
        "description": "Build and run GreptimeDB from source"
      }
    },
    "examples": [
      {
        "title": "Start a standalone server",
        "description": "Run a standalone GreptimeDB server",
        "prompt": "cargo run -- standalone start"
      }
    ],
    "name": "greptimedb",
    "description": "<source media=\"(prefers-color-scheme: light)\" srcset=\"https://cdn.jsdelivr.net/gh/GreptimeTeam/greptimedb@main/docs/logo-text-padding.png\">",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "chroma-mcp": {
    "display_name": "Chroma MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/chroma-core/chroma-mcp"
    },
    "homepage": "https://www.trychroma.com/",
    "author": {
      "name": "chroma-core"
    },
    "license": "Apache 2.0",
    "tags": [
      "vector database",
      "embeddings",
      "LLM",
      "retrieval",
      "MCP"
    ],
    "arguments": {
      "client-type": {
        "description": "Type of client to use (ephemeral, persistent, http, cloud)",
        "required": false,
        "example": "persistent"
      },
      "data-dir": {
        "description": "Directory to store data for persistent client",
        "required": false,
        "example": "/full/path/to/your/data/directory"
      },
      "host": {
        "description": "Host for HTTP client",
        "required": false,
        "example": "your-host"
      },
      "port": {
        "description": "Port for HTTP client",
        "required": false,
        "example": "your-port"
      },
      "tenant": {
        "description": "Tenant ID for cloud client",
        "required": false,
        "example": "your-tenant-id"
      },
      "database": {
        "description": "Database name for cloud client",
        "required": false,
        "example": "your-database-name"
      },
      "api-key": {
        "description": "API key for cloud client",
        "required": false,
        "example": "your-api-key"
      },
      "custom-auth-credentials": {
        "description": "Custom authentication credentials for HTTP client",
        "required": false,
        "example": "your-custom-auth-credentials"
      },
      "ssl": {
        "description": "Whether to use SSL for HTTP client",
        "required": false,
        "example": "true"
      },
      "dotenv-path": {
        "description": "Path to .env file",
        "required": false,
        "example": "/custom/path/.env"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "chroma-mcp"
        ],
        "description": "Install using uvx",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "List Collections",
        "description": "List all collections with pagination support",
        "prompt": "Use chroma_list_collections to show me all available collections."
      },
      {
        "title": "Create Collection",
        "description": "Create a new collection with optional HNSW configuration",
        "prompt": "Use chroma_create_collection to create a new collection named 'my_documents'."
      },
      {
        "title": "Query Documents",
        "description": "Query documents using semantic search with advanced filtering",
        "prompt": "Use chroma_query_documents to find documents in the 'my_documents' collection that are similar to 'machine learning concepts'."
      }
    ],
    "name": "chroma-mcp",
    "description": "Embeddings, vector search, document storage, and full-text search with the open-source AI application database",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "xmind": {
    "name": "xmind",
    "display_name": "XMind",
    "description": "Read and search through your XMind directory containing XMind files.",
    "repository": {
      "type": "git",
      "url": "https://github.com/apeyroux/mcp-xmind"
    },
    "homepage": "https://github.com/apeyroux/mcp-xmind",
    "license": "MIT",
    "author": {
      "name": "apeyroux"
    },
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "XMind",
      "Mind Mapping",
      "Analysis",
      "Productivity"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@41px/mcp-xmind",
          "${USER_XMIND_DIRECTORY}"
        ]
      }
    },
    "examples": [
      {
        "title": "Search for Nodes",
        "description": "Searches through the mind map for specific nodes based on the query parameters.",
        "prompt": "{\"name\": \"search_nodes\", \"arguments\": {\"path\": \"/path/to/file.xmind\", \"query\": \"project\", \"searchIn\": [\"title\", \"notes\"], \"caseSensitive\": false}}"
      },
      {
        "title": "Extract Node",
        "description": "Extracts a node from the mind map based on a search query.",
        "prompt": "{\"name\": \"extract_node\", \"arguments\": {\"path\": \"/path/to/file.xmind\", \"searchQuery\": \"Feature > API\"}}"
      },
      {
        "title": "List Tasks",
        "description": "Lists TODO tasks from the mind map.",
        "prompt": "{\"name\": \"get_todo_tasks\", \"arguments\": {\"path\": \"/path/to/file.xmind\"}}"
      }
    ],
    "arguments": {
      "USER_XMIND_DIRECTORY": {
        "description": "The path to the directory containing XMind files that should be processed by the server.",
        "required": true,
        "example": "/Users/alex/XMind"
      }
    },
    "tools": [
      {
        "name": "read_xmind",
        "description": "Parse and analyze XMind files with multiple capabilities:\n                - Extract complete mind map structure in JSON format\n                - Include all relationships between nodes with their IDs and titles\n                - Extract callouts attached to topics\n                - Generate text or markdown summaries\n                - Search for specific content\n                - Get hierarchical path to any node\n                - Filter content by labels, task status, or node depth\n                - Extract all URLs and external references\n                - Analyze relationships and connections between topics\n                Input: File path to .xmind file\n                Output: JSON structure containing nodes, relationships, and callouts",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list_xmind_directory",
        "description": "Comprehensive XMind file discovery and analysis tool:\n                - Recursively scan directories for .xmind files\n                - Filter files by creation/modification date\n                - Search for files containing specific content\n                - Group files by project or category\n                - Detect duplicate mind maps\n                - Generate directory statistics and summaries\n                - Verify file integrity and structure\n                - Monitor changes in mind map files\n                Input: Directory path to scan\n                Output: List of XMind files with optional metadata",
        "inputSchema": {
          "type": "object",
          "properties": {
            "directory": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "read_multiple_xmind_files",
        "description": "Advanced multi-file analysis and correlation tool:\n                - Process multiple XMind files simultaneously\n                - Compare content across different mind maps\n                - Identify common themes and patterns\n                - Merge related content from different files\n                - Generate cross-reference reports\n                - Find content duplications across files\n                - Create consolidated summaries\n                - Track changes across multiple versions\n                - Generate comparative analysis\n                Input: Array of file paths to .xmind files\n                Output: Combined analysis results in JSON format with per-file details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "paths"
          ]
        }
      },
      {
        "name": "search_xmind_files",
        "description": "Advanced file search tool with recursive capabilities:\n                - Search for files and directories by partial name matching\n                - Case-insensitive pattern matching\n                - Searches through all subdirectories recursively\n                - Returns full paths to all matching items\n                - Includes both files and directories in results\n                - Safe searching within allowed directories only\n                - Handles special characters in names\n                - Continues searching even if some directories are inaccessible\n                Input: {\n                    directory: Starting directory path,\n                    pattern: Search text to match in names\n                }\n                Output: Array of full paths to matching items",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string"
            },
            "directory": {
              "type": "string"
            }
          },
          "required": [
            "pattern"
          ]
        }
      },
      {
        "name": "extract_node",
        "description": "Smart node extraction with fuzzy path matching:\n                - Flexible search using partial or complete node paths\n                - Returns multiple matching nodes ranked by relevance\n                - Supports approximate matching for better results\n                - Includes full context and hierarchy information\n                - Returns complete subtree for each match\n                - Best tool for exploring and navigating complex mind maps\n                - Perfect for finding nodes when exact path is unknown\n                Usage examples:\n                - \"Project > Backend\" : finds nodes in any path containing these terms\n                - \"Feature API\" : finds nodes containing these words in any order\n                Input: {\n                    path: Path to .xmind file,\n                    searchQuery: Text to search in node paths (flexible matching)\n                }\n                Output: Ranked list of matching nodes with their full subtrees",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "searchQuery": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "searchQuery"
          ]
        }
      },
      {
        "name": "extract_node_by_id",
        "description": "Extract a specific node and its subtree using its unique ID:\n                - Find and extract node using its XMind ID\n                - Return complete subtree structure\n                - Preserve all node properties and relationships\n                - Fast direct access without path traversal\n                Note: For a more detailed view with fuzzy matching, use \"extract_node\" with the node's path\n                Input: {\n                    path: Path to .xmind file,\n                    nodeId: Unique identifier of the node\n                }\n                Output: JSON structure of the found node and its subtree",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "nodeId": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "nodeId"
          ]
        }
      },
      {
        "name": "search_nodes",
        "description": "Advanced node search with multiple criteria:\n                - Search through titles, notes, labels, callouts and tasks\n                - Filter by task status (todo/done)\n                - Find nodes by their relationships\n                - Configure which fields to search in\n                - Case-sensitive or insensitive search\n                - Get full context including task status\n                - Returns all matching nodes with their IDs\n                - Includes relationship information and task status\n                Input: {\n                    path: Path to .xmind file,\n                    query: Search text,\n                    searchIn: Array of fields to search in ['title', 'notes', 'labels', 'callouts', 'tasks'],\n                    taskStatus: 'todo' | 'done' (optional),\n                    caseSensitive: Boolean (optional)\n                }\n                Output: Detailed search results with task status and context",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "query": {
              "type": "string"
            },
            "searchIn": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "title",
                  "notes",
                  "labels",
                  "callouts",
                  "tasks"
                ]
              }
            },
            "caseSensitive": {
              "type": "boolean"
            },
            "taskStatus": {
              "type": "string",
              "enum": [
                "todo",
                "done"
              ]
            }
          },
          "required": [
            "path",
            "query"
          ]
        }
      }
    ]
  },
  "search1api-mcp": {
    "display_name": "Search1API MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/fatwang2/search1api-mcp"
    },
    "homepage": "https://www.search1api.com/?utm_source=mcp",
    "author": {
      "name": "fatwang2"
    },
    "license": "MIT",
    "tags": [
      "search",
      "web",
      "news",
      "crawl",
      "sitemap",
      "reasoning",
      "trending"
    ],
    "arguments": {
      "SEARCH1API_KEY": {
        "description": "Your Search1API API key",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "search1api-mcp"
        ],
        "env": {
          "SEARCH1API_KEY": "YOUR_SEARCH1API_KEY"
        },
        "description": "Run directly using npx",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Web Search",
        "description": "Search the web for information",
        "prompt": "Search for the latest news about artificial intelligence"
      },
      {
        "title": "News Search",
        "description": "Search for news articles",
        "prompt": "Find news articles about climate change from the past month"
      },
      {
        "title": "Web Crawling",
        "description": "Extract content from a specific URL",
        "prompt": "Crawl the content from https://example.com"
      }
    ],
    "name": "search1api-mcp",
    "description": "A Model Context Protocol (MCP) server that provides search and crawl functionality using Search1API.",
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "search",
        "description": "Web search tool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query, be simple and concise"
            },
            "max_results": {
              "type": "number",
              "description": "Maximum number of results to return",
              "default": 10
            },
            "search_service": {
              "type": "string",
              "description": "Specify the search engine to use. Choose based on your specific needs",
              "default": "google",
              "enum": [
                "google",
                "bing",
                "duckduckgo",
                "yahoo",
                "x",
                "reddit",
                "github",
                "youtube",
                "arxiv",
                "wechat",
                "bilibili",
                "imdb",
                "wikipedia"
              ]
            },
            "crawl_results": {
              "type": "number",
              "description": "Number of results to crawl for full webpage content, useful when search result summaries are insufficient for complex queries",
              "default": 0
            },
            "include_sites": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of sites to include in search. Only use when you need special results from sites not available in search_service",
              "default": []
            },
            "exclude_sites": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of sites to exclude from search. Only use when you need to explicitly filter out specific domains from results",
              "default": []
            },
            "time_range": {
              "type": "string",
              "description": "Time range for search results, only use when specific time constraints are required",
              "enum": [
                "day",
                "month",
                "year"
              ]
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "news",
        "description": "News search tool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query, be simple and concise"
            },
            "max_results": {
              "type": "number",
              "description": "Maximum number of results to return",
              "default": 10
            },
            "search_service": {
              "type": "string",
              "description": "Specify the news engine to use. Choose based on your specific needs",
              "default": "bing",
              "enum": [
                "google",
                "bing",
                "duckduckgo",
                "yahoo",
                "hackernews"
              ]
            },
            "crawl_results": {
              "type": "number",
              "description": "Number of results to crawl for full webpage content, useful when search result summaries are insufficient for complex queries",
              "default": 0
            },
            "include_sites": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of sites to include in search. Only use when you need special results from sites not available in search_service",
              "default": []
            },
            "exclude_sites": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of sites to exclude from search. Only use when you need to explicitly filter out specific domains from results",
              "default": []
            },
            "time_range": {
              "type": "string",
              "description": "Time range for search results, only use when specific time constraints are required",
              "enum": [
                "day",
                "month",
                "year"
              ]
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "crawl",
        "description": "Extract content from URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to crawl"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "sitemap",
        "description": "Get all related links from a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to get sitemap"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "reasoning",
        "description": "Deep thinking and complex problem solving",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The question or problem that needs deep thinking"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "trending",
        "description": "Get trending topics from popular platforms",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search_service": {
              "type": "string",
              "description": "Specify the platform to get trending topics from",
              "enum": [
                "github",
                "hackernews"
              ],
              "default": "github"
            },
            "max_results": {
              "type": "number",
              "description": "Maximum number of trending items to return",
              "default": 10
            }
          },
          "required": [
            "search_service"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [
      {
        "uri": "search1api://info",
        "name": "Search1API Information",
        "description": "Basic information about Search1API capabilities",
        "mimeType": "application/json"
      }
    ],
    "is_official": true
  },
  "influxdb": {
    "name": "influxdb",
    "display_name": "InfluxDB",
    "description": "Run queries against InfluxDB OSS API v2.",
    "repository": {
      "type": "git",
      "url": "https://github.com/idoru/influxdb-mcp-server"
    },
    "homepage": "https://github.com/idoru/influxdb-mcp-server",
    "author": {
      "name": "idoru"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "InfluxDB",
      "API",
      "server",
      "time-series"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "${INFLUXDB_TOKEN}",
          "${INFLUXDB_URL}",
          "${INFLUXDB_ORG}"
        ],
        "env": {
          "INFLUXDB_TOKEN": "your_token",
          "INFLUXDB_URL": "http://localhost:8086",
          "INFLUXDB_ORG": "your_org"
        }
      }
    },
    "arguments": {
      "INFLUXDB_TOKEN": {
        "description": "Authentication token for the InfluxDB API",
        "required": true,
        "example": "your_token"
      },
      "INFLUXDB_URL": {
        "description": "URL of the InfluxDB instance",
        "required": false,
        "example": "http://localhost:8086"
      },
      "INFLUXDB_ORG": {
        "description": "Default organization name for certain operations",
        "required": false,
        "example": "your_org"
      }
    },
    "tools": [
      {
        "name": "write-data",
        "description": "Write data to InfluxDB in line protocol format.",
        "inputSchema": {
          "org": {
            "type": "string",
            "description": "The organization name"
          },
          "bucket": {
            "type": "string",
            "description": "The bucket name"
          },
          "data": {
            "type": "string",
            "description": "Data in InfluxDB line protocol format"
          },
          "precision": {
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "Timestamp precision (ns, us, ms, s)"
          }
        },
        "required": [
          "org",
          "bucket",
          "data"
        ]
      },
      {
        "name": "query-data",
        "description": "Execute a Flux query on InfluxDB data.",
        "inputSchema": {
          "org": {
            "type": "string",
            "description": "The organization name"
          },
          "query": {
            "type": "string",
            "description": "Flux query string"
          }
        },
        "required": [
          "org",
          "query"
        ]
      },
      {
        "name": "create-bucket",
        "description": "Create a new bucket in InfluxDB.",
        "inputSchema": {
          "name": {
            "type": "string",
            "description": "The bucket name"
          },
          "orgID": {
            "type": "string",
            "description": "The organization ID"
          },
          "retentionPeriodSeconds": {
            "type": "number",
            "description": "Retention period in seconds (optional)"
          }
        },
        "required": [
          "name",
          "orgID"
        ]
      },
      {
        "name": "create-org",
        "description": "Create a new organization in InfluxDB.",
        "inputSchema": {
          "name": {
            "type": "string",
            "description": "The organization name"
          },
          "description": {
            "type": "string",
            "description": "Organization description (optional)"
          }
        },
        "required": [
          "name"
        ]
      }
    ]
  },
  "mssql": {
    "name": "mssql",
    "display_name": "MSSQL",
    "description": "MCP Server for MSSQL database in Python",
    "repository": {
      "type": "git",
      "url": "https://github.com/JexinSam/mssql_mcp_server"
    },
    "homepage": "https://github.com/JexinSam/mssql_mcp_server",
    "author": {
      "name": "JexinSam"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "MSSQL",
      "AI",
      "Database Access"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mssql_mcp_server"
        ],
        "env": {
          "MSSQL_DRIVER": "${MSSQL_DRIVER}",
          "MSSQL_HOST": "${MSSQL_HOST}",
          "MSSQL_USER": "${MSSQL_USER}",
          "MSSQL_PASSWORD": "${MSSQL_PASSWORD}",
          "MSSQL_DATABASE": "${MSSQL_DATABASE}"
        }
      }
    },
    "arguments": {
      "MSSQL_DRIVER": {
        "description": "Environment variable that specifies the driver to connect to the MSSQL database.",
        "required": true,
        "example": "mssql_driver"
      },
      "MSSQL_HOST": {
        "description": "Environment variable that specifies the hostname or IP address of the MSSQL server.",
        "required": true,
        "example": "localhost"
      },
      "MSSQL_USER": {
        "description": "Environment variable that defines the username for connecting to the MSSQL database.",
        "required": true,
        "example": "your_username"
      },
      "MSSQL_PASSWORD": {
        "description": "Environment variable that stores the password for the MSSQL user.",
        "required": true,
        "example": "your_password"
      },
      "MSSQL_DATABASE": {
        "description": "Environment variable that specifies the name of the MSSQL database to connect to.",
        "required": true,
        "example": "your_database"
      }
    },
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute an SQL query on the MSSQL server",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "The SQL query to execute"
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "n8n": {
    "name": "n8n",
    "display_name": "n8n",
    "description": "This MCP server provides tools and resources for AI assistants to manage n8n workflows and executions, including listing, creating, updating, and deleting workflows, as well as monitoring their execution status.",
    "repository": {
      "type": "git",
      "url": "https://github.com/leonardsellem/n8n-mcp-server"
    },
    "homepage": "https://github.com/leonardsellem/n8n-mcp-server",
    "author": {
      "name": "leonardsellem"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "n8n",
      "server",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@anaisbetts/mcp-installer"
        ],
        "env": {
          "N8N_API_URL": "${N8N_API_URL}",
          "N8N_API_KEY": "${N8N_API_KEY}"
        }
      }
    },
    "arguments": {
      "N8N_API_URL": {
        "description": "URL of the n8n API",
        "required": true,
        "example": "http://localhost:5678/api/v1"
      },
      "N8N_API_KEY": {
        "description": "API key for authenticating with n8n",
        "required": true,
        "example": "n8n_api_..."
      }
    },
    "tools": [
      {
        "name": "install_repo_mcp_server",
        "description": "Install an MCP server via npx or uvx",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The package name of the MCP server"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The arguments to pass along"
            },
            "env": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The environment variables to set, delimited by ="
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "install_local_mcp_server",
        "description": "Install an MCP server whose code is cloned locally on your computer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "The path to the MCP server code cloned on your computer"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The arguments to pass along"
            },
            "env": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The environment variables to set, delimited by ="
            }
          },
          "required": [
            "path"
          ]
        }
      }
    ]
  },
  "bing-web-search-api": {
    "name": "bing-web-search-api",
    "display_name": "Bing Search API",
    "description": "Server implementation for Microsoft Bing Web Search API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/leehanchung/bing-search-mcp"
    },
    "homepage": "https://github.com/leehanchung/bing-search-mcp",
    "author": {
      "name": "leehanchung"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Bing",
      "Search",
      "Web",
      "News",
      "Images"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+http://github.com/leehanchung/bing-search-mcp",
          "mcp-server-bing"
        ],
        "env": {
          "BING_API_KEY": "${BING_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Web Search Example",
        "description": "Search the web for various queries.",
        "prompt": "Search for 'latest technology news'."
      },
      {
        "title": "News Search Example",
        "description": "Search for the latest news articles.",
        "prompt": "Search for 'global warming'."
      },
      {
        "title": "Image Search Example",
        "description": "Find images related to a query.",
        "prompt": "Search for 'sunsets'."
      }
    ],
    "arguments": {
      "BING_API_KEY": {
        "description": "API key required for authenticating requests to the Microsoft Bing Search API.",
        "required": true,
        "example": "your-bing-api-key"
      }
    },
    "tools": [
      {
        "name": "bing_web_search",
        "description": "Performs a web search using the Bing Search API for general information\n    and websites.\n\n    Args:\n        query: Search query (required)\n        count: Number of results (1-50, default 10)\n        offset: Pagination offset (default 0)\n        market: Market code like en-US, en-GB, etc.\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "count": {
              "default": 10,
              "title": "Count",
              "type": "integer"
            },
            "offset": {
              "default": 0,
              "title": "Offset",
              "type": "integer"
            },
            "market": {
              "default": "en-US",
              "title": "Market",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "bing_web_searchArguments",
          "type": "object"
        }
      },
      {
        "name": "bing_news_search",
        "description": "Searches for news articles using Bing News Search API for current\n    events and timely information.\n\n    Args:\n        query: News search query (required)\n        count: Number of results (1-50, default 10)\n        market: Market code like en-US, en-GB, etc.\n        freshness: Time period of news (Day, Week, Month)\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "count": {
              "default": 10,
              "title": "Count",
              "type": "integer"
            },
            "market": {
              "default": "en-US",
              "title": "Market",
              "type": "string"
            },
            "freshness": {
              "default": "Day",
              "title": "Freshness",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "bing_news_searchArguments",
          "type": "object"
        }
      },
      {
        "name": "bing_image_search",
        "description": "Searches for images using Bing Image Search API for visual content.\n\n    Args:\n        query: Image search query (required)\n        count: Number of results (1-50, default 10)\n        market: Market code like en-US, en-GB, etc.\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "count": {
              "default": 10,
              "title": "Count",
              "type": "integer"
            },
            "market": {
              "default": "en-US",
              "title": "Market",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "bing_image_searchArguments",
          "type": "object"
        }
      }
    ]
  },
  "image-generation": {
    "name": "image-generation",
    "display_name": "Image Generation",
    "description": "This MCP server provides image generation capabilities using the Replicate Flux model.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/Image-Generation-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/Image-Generation-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "image",
      "generation",
      "flux",
      "Replicate"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@gongrzhe/image-gen-server"
        ],
        "env": {
          "REPLICATE_API_TOKEN": "${REPLICATE_API_TOKEN}",
          "MODEL": "${MODEL}",
          "your-replicate-api-token": "${your_replicate_api_token}",
          "alternative-model-name": "${alternative_model_name}"
        }
      }
    },
    "arguments": {
      "REPLICATE_API_TOKEN": {
        "description": "Your Replicate API token for authentication",
        "required": true,
        "example": "your-replicate-api-token"
      },
      "MODEL": {
        "description": "The Replicate model to use for image generation. Defaults to \"black-forest-labs/flux-schnell\"",
        "required": false,
        "example": "alternative-model-name"
      }
    },
    "tools": [
      {
        "name": "generate_image",
        "description": "Generate an image using the Flux model",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Prompt for generated image"
            },
            "seed": {
              "type": "integer",
              "description": "Random seed for reproducible generation"
            },
            "aspect_ratio": {
              "type": "string",
              "enum": [
                "1:1",
                "16:9",
                "21:9",
                "3:2",
                "2:3",
                "4:5",
                "5:4",
                "3:4",
                "4:3",
                "9:16",
                "9:21"
              ],
              "description": "Aspect ratio for the generated image",
              "default": "1:1"
            },
            "output_format": {
              "type": "string",
              "enum": [
                "webp",
                "jpg",
                "png"
              ],
              "description": "Format of the output images",
              "default": "webp"
            },
            "num_outputs": {
              "type": "integer",
              "description": "Number of outputs to generate (1-4)",
              "default": 1,
              "minimum": 1,
              "maximum": 4
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "aws-s3": {
    "name": "aws-s3",
    "display_name": "Sample S3 Model Context Protocol",
    "description": "A sample MCP server for AWS S3 that flexibly fetches objects from S3 such as PDF documents.",
    "repository": {
      "type": "git",
      "url": "https://github.com/aws-samples/sample-mcp-server-s3"
    },
    "homepage": "https://github.com/aws-samples/sample-mcp-server-s3",
    "author": {
      "name": "aws-samples"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "S3",
      "PDF",
      "aws"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "s3-mcp-server"
        ]
      }
    }
  },
  "markdownify": {
    "name": "markdownify",
    "display_name": "Markdownify",
    "description": "MCP to convert almost anything to Markdown (PPTX, HTML, PDF, Youtube Transcripts and more)",
    "repository": {
      "type": "git",
      "url": "https://github.com/zcaceres/mcp-markdownify-server"
    },
    "homepage": "https://github.com/zcaceres/mcp-markdownify-server",
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "markdown",
      "conversion"
    ],
    "author": {
      "name": "zcaceres"
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/zcaceres/mcp-markdownify-server"
        ],
        "env": {
          "UV_PATH": "${UV_PATH}"
        }
      }
    },
    "arguments": {
      "UV_PATH": {
        "description": "Environment variable specifying the installation location of the `uv` dependency.",
        "required": false,
        "example": "/path/to/uv"
      }
    }
  },
  "openapi-schema": {
    "name": "openapi-schema",
    "display_name": "OpenAPI Schema Model Context Protocol",
    "description": "Allow LLMs to explore large [OpenAPI](https://www.openapis.org/) schemas without bloating the context.",
    "repository": {
      "type": "git",
      "url": "https://github.com/hannesj/mcp-openapi-schema"
    },
    "homepage": "https://github.com/hannesj/mcp-openapi-schema",
    "author": {
      "name": "hannesj"
    },
    "license": "[NOT FOUND]",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "OpenAPI",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-openapi-schema",
          "${ABSOLUTE_PATH_TO_OPENAPI_YAML}"
        ]
      }
    },
    "arguments": {
      "ABSOLUTE_PATH_TO_OPENAPI_YAML": {
        "description": "The absolute path to the OpenAPI YAML file that the MCP server will use to load the schema.",
        "required": true,
        "example": "/absolute/path/to/openapi.yaml"
      }
    },
    "tools": [
      {
        "name": "list-endpoints",
        "description": "Lists all API paths and their HTTP methods with summaries, organized by path",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "get-endpoint",
        "description": "Gets detailed information about a specific API endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "method": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "method"
          ]
        }
      },
      {
        "name": "get-request-body",
        "description": "Gets the request body schema for a specific endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "method": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "method"
          ]
        }
      },
      {
        "name": "get-response-schema",
        "description": "Gets the response schema for a specific endpoint, method, and status code",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "method": {
              "type": "string"
            },
            "statusCode": {
              "type": "string",
              "default": "200"
            }
          },
          "required": [
            "path",
            "method"
          ]
        }
      },
      {
        "name": "get-path-parameters",
        "description": "Gets the parameters for a specific path",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "method": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list-components",
        "description": "Lists all schema components (schemas, parameters, responses, etc.)",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "get-component",
        "description": "Gets detailed definition for a specific component",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Component type (e.g., schemas, parameters, responses)"
            },
            "name": {
              "type": "string",
              "description": "Component name"
            }
          },
          "required": [
            "type",
            "name"
          ]
        }
      },
      {
        "name": "list-security-schemes",
        "description": "Lists all available security schemes",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "get-examples",
        "description": "Gets examples for a specific component or endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "request",
                "response",
                "component"
              ],
              "description": "Type of example to retrieve"
            },
            "path": {
              "type": "string",
              "description": "API path (required for request/response examples)"
            },
            "method": {
              "type": "string",
              "description": "HTTP method (required for request/response examples)"
            },
            "statusCode": {
              "type": "string",
              "description": "Status code (for response examples)"
            },
            "componentType": {
              "type": "string",
              "description": "Component type (required for component examples)"
            },
            "componentName": {
              "type": "string",
              "description": "Component name (required for component examples)"
            }
          },
          "required": [
            "type"
          ]
        }
      },
      {
        "name": "search-schema",
        "description": "Searches across paths, operations, and schemas",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string",
              "description": "Search pattern (case-insensitive)"
            }
          },
          "required": [
            "pattern"
          ]
        }
      }
    ]
  },
  "xcodebuild": {
    "name": "xcodebuild",
    "display_name": "Xcode Build",
    "description": "\ud83c\udf4e Build iOS Xcode workspace/project and feed back errors to llm.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ShenghaiWang/xcodebuild"
    },
    "homepage": "https://github.com/ShenghaiWang/xcodebuild",
    "author": {
      "name": "ShenghaiWang"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "xcode",
      "mcpxcodebuild"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcpxcodebuild"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcpxcodebuild"
        ]
      }
    },
    "examples": [
      {
        "title": "Build iOS Project",
        "description": "Builds the iOS Xcode workspace/project located at a specified folder.",
        "prompt": "build --folder /path/to/your/project"
      }
    ],
    "tools": [
      {
        "name": "build",
        "description": "Build the iOS Xcode workspace/project in the folder",
        "inputSchema": {
          "description": "Parameters",
          "properties": {
            "folder": {
              "description": "The full path of the current folder that the iOS Xcode workspace/project sits",
              "title": "Folder",
              "type": "string"
            }
          },
          "required": [
            "folder"
          ],
          "title": "Folder",
          "type": "object"
        }
      },
      {
        "name": "test",
        "description": "Run test for the iOS Xcode workspace/project in the folder",
        "inputSchema": {
          "description": "Parameters",
          "properties": {
            "folder": {
              "description": "The full path of the current folder that the iOS Xcode workspace/project sits",
              "title": "Folder",
              "type": "string"
            }
          },
          "required": [
            "folder"
          ],
          "title": "Folder",
          "type": "object"
        }
      }
    ]
  },
  "azure-adx": {
    "name": "azure-adx",
    "display_name": "Azure Data Explorer",
    "description": "Query and analyze Azure Data Explorer databases.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pab1it0/adx-mcp-server"
    },
    "homepage": "https://github.com/pab1it0/adx-mcp-server",
    "author": {
      "name": "pab1it0"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Azure",
      "KQL",
      "Data Explorer"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pab1it0/adx-mcp-server",
          "adx-mcp-server"
        ],
        "env": {
          "ADX_CLUSTER_URL": "${ADX_CLUSTER_URL}",
          "ADX_DATABASE": "${ADX_DATABASE}"
        }
      }
    },
    "arguments": {
      "ADX_CLUSTER_URL": {
        "description": "The URL of the Azure Data Explorer cluster.",
        "required": true,
        "example": "https://yourcluster.region.kusto.windows.net"
      },
      "ADX_DATABASE": {
        "description": "The name of the Azure Data Explorer database to connect to.",
        "required": true,
        "example": "your_database"
      }
    },
    "tools": [
      {
        "name": "execute_query",
        "description": "Executes a Kusto Query Language (KQL) query against the configured Azure Data Explorer database and returns the results as a list of dictionaries.",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "execute_queryArguments",
          "type": "object"
        }
      },
      {
        "name": "list_tables",
        "description": "Retrieves a list of all tables available in the configured Azure Data Explorer database, including their names, folders, and database associations.",
        "inputSchema": {
          "properties": {},
          "title": "list_tablesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_table_schema",
        "description": "Retrieves the schema information for a specified table in the Azure Data Explorer database, including column names, data types, and other schema-related metadata.",
        "inputSchema": {
          "properties": {
            "table_name": {
              "title": "Table Name",
              "type": "string"
            }
          },
          "required": [
            "table_name"
          ],
          "title": "get_table_schemaArguments",
          "type": "object"
        }
      },
      {
        "name": "sample_table_data",
        "description": "Retrieves a random sample of rows from the specified table in the Azure Data Explorer database. The sample_size parameter controls how many rows to return (default: 10).",
        "inputSchema": {
          "properties": {
            "table_name": {
              "title": "Table Name",
              "type": "string"
            },
            "sample_size": {
              "default": 10,
              "title": "Sample Size",
              "type": "integer"
            }
          },
          "required": [
            "table_name"
          ],
          "title": "sample_table_dataArguments",
          "type": "object"
        }
      }
    ]
  },
  "llm-context": {
    "name": "llm-context",
    "display_name": "LLM Context",
    "description": "Provides a repo-packing MCP tool with configurable profiles that specify file inclusion/exclusion patterns and optional prompts.",
    "repository": {
      "type": "git",
      "url": "https://github.com/cyberchitta/llm-context.py"
    },
    "homepage": "https://github.com/cyberchitta/llm-context.py",
    "author": {
      "name": "cyberchitta"
    },
    "license": "Apache 2.0",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "LLM",
      "Context Injection",
      "Development",
      "ChatGPT",
      "Productivity"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "llm-context",
          "lc-mcp"
        ]
      }
    },
    "arguments": {
      "mcp": {
        "description": "Indicates the model context protocol that should be used for communication.",
        "required": true,
        "example": "lc-mcp"
      }
    },
    "tools": [
      {
        "name": "lc-project-context",
        "description": "IMPORTANT: First check if project context is already available in the conversation before making any new requests. Use lc-get-files for retrieving specific files, and only use this tool when a broad repository overview is needed.\n\nGenerates a structured repository overview including: 1) Directory tree with file status (\u2713 full, \u25cb outline, \u2717 excluded) 2) Complete contents of key files 3) Smart outlines highlighting important definitions in supported languages. The output is customizable via profiles that control file inclusion rules and presentation format. The assistant tracks previously retrieved project context in the conversation and checks this history before making new requests.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "rule_name": {
              "default": "lc-code",
              "description": "Rule to use (e.g. 'code', 'copy', 'full') - defines file inclusion and presentation rules",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "title": "Rule Name",
              "type": "string"
            }
          },
          "required": [
            "root_path"
          ],
          "title": "ContextRequest",
          "type": "object"
        }
      },
      {
        "name": "lc-get-files",
        "description": "IMPORTANT: Check previously retrieved file contents before making new requests. Retrieves (read-only) complete contents of specified files from the project. For this project, this is the preferred method for all file content analysis and text searches - simply retrieve the relevant files and examine their contents. The assistant cannot modify files with this tool - it only reads their contents.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "paths": {
              "description": "File paths relative to root_path, starting with a forward slash and including the root directory name. For example, if root_path is '/home/user/projects/myproject', then a valid path would be '/myproject/src/main.py",
              "items": {
                "type": "string"
              },
              "title": "Paths",
              "type": "array"
            }
          },
          "required": [
            "root_path",
            "paths"
          ],
          "title": "FilesRequest",
          "type": "object"
        }
      },
      {
        "name": "lc-list-modified-files",
        "description": "IMPORTANT: First get the generation timestamp from the project context. Returns a list of paths to files that have been modified since a given timestamp. This is typically used to track which files have changed during the conversation. After getting the list, use lc-get-files to examine the contents of any modified files of interest.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "rule_name": {
              "default": "lc-code",
              "description": "Rule to use (e.g. 'code', 'copy', 'full') - defines file inclusion and presentation rules",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "title": "Rule Name",
              "type": "string"
            },
            "timestamp": {
              "description": "Unix timestamp to check modifications since",
              "title": "Timestamp",
              "type": "number"
            }
          },
          "required": [
            "root_path",
            "timestamp"
          ],
          "title": "ListModifiedFilesRequest",
          "type": "object"
        }
      },
      {
        "name": "lc-code-outlines",
        "description": "Returns smart outlines highlighting important definitions in all supported code files. This provides a high-level overview of code structure without retrieving full file contents. Outlines show key definitions (classes, functions, methods) in the codebase. Use lc-get-implementations to retrieve the full implementation of any definition shown in these outlines.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "rule_name": {
              "default": "lc-code",
              "description": "Rule to use for file selection rules",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "title": "Rule Name",
              "type": "string"
            }
          },
          "required": [
            "root_path"
          ],
          "title": "OutlinesRequest",
          "type": "object"
        }
      },
      {
        "name": "lc-get-implementations",
        "description": "Retrieves complete code implementations of definitions identified in code outlines. Provide a list of file paths and definition names to get their full implementations. This tool works with all supported languages except C and C++.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "queries": {
              "description": "List of (file_path, definition_name) tuples to fetch implementations for",
              "items": {
                "maxItems": 2,
                "minItems": 2,
                "prefixItems": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "type": "array"
              },
              "title": "Queries",
              "type": "array"
            }
          },
          "required": [
            "root_path",
            "queries"
          ],
          "title": "ImplementationsRequest",
          "type": "object"
        }
      }
    ]
  },
  "gmail-headless": {
    "name": "gmail-headless",
    "display_name": "Headless Gmail Server",
    "description": "Remote hostable MCP server that can get and send Gmail messages without local credential or file system setup.",
    "repository": {
      "type": "git",
      "url": "https://github.com/baryhuang/mcp-headless-gmail"
    },
    "homepage": "https://github.com/baryhuang/mcp-headless-gmail",
    "author": {
      "name": "baryhuang"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Gmail",
      "Headless",
      "Docker",
      "API"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "buryhuang/mcp-headless-gmail:latest"
        ]
      }
    },
    "tools": [
      {
        "name": "gmail_refresh_token",
        "description": "Refresh the access token using the refresh token and client credentials",
        "inputSchema": {
          "google_access_token": {
            "type": "string",
            "description": "Google OAuth2 access token (optional if expired)"
          },
          "google_refresh_token": {
            "type": "string",
            "description": "Google OAuth2 refresh token"
          },
          "google_client_id": {
            "type": "string",
            "description": "Google OAuth2 client ID for token refresh"
          },
          "google_client_secret": {
            "type": "string",
            "description": "Google OAuth2 client secret for token refresh"
          }
        },
        "required": [
          "google_refresh_token",
          "google_client_id",
          "google_client_secret"
        ]
      },
      {
        "name": "gmail_get_recent_emails",
        "description": "Get the most recent emails from Gmail (returns metadata, snippets, and first 1k chars of body)",
        "inputSchema": {
          "google_access_token": {
            "type": "string",
            "description": "Google OAuth2 access token"
          },
          "max_results": {
            "type": "integer",
            "description": "Maximum number of emails to return (default: 10)"
          },
          "unread_only": {
            "type": "boolean",
            "description": "Whether to return only unread emails (default: False)"
          }
        },
        "required": [
          "google_access_token"
        ]
      },
      {
        "name": "gmail_get_email_body_chunk",
        "description": "Get a 1k character chunk of an email body starting from the specified offset",
        "inputSchema": {
          "google_access_token": {
            "type": "string",
            "description": "Google OAuth2 access token"
          },
          "message_id": {
            "type": "string",
            "description": "ID of the message to retrieve"
          },
          "thread_id": {
            "type": "string",
            "description": "ID of the thread to retrieve (will get the first message if multiple exist)"
          },
          "offset": {
            "type": "integer",
            "description": "Offset in characters to start from (default: 0)"
          }
        },
        "required": [
          "google_access_token"
        ]
      },
      {
        "name": "gmail_send_email",
        "description": "Send an email via Gmail",
        "inputSchema": {
          "google_access_token": {
            "type": "string",
            "description": "Google OAuth2 access token"
          },
          "to": {
            "type": "string",
            "description": "Recipient email address"
          },
          "subject": {
            "type": "string",
            "description": "Email subject"
          },
          "body": {
            "type": "string",
            "description": "Email body content (plain text)"
          },
          "html_body": {
            "type": "string",
            "description": "Email body content in HTML format (optional)"
          }
        },
        "required": [
          "google_access_token",
          "to",
          "subject",
          "body"
        ]
      }
    ]
  },
  "graphlit-mcp-server": {
    "display_name": "Graphlit MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/graphlit/graphlit-mcp-server"
    },
    "homepage": "https://www.graphlit.com/blog/graphlit-mcp-server",
    "author": {
      "name": "graphlit"
    },
    "license": "MIT",
    "tags": [
      "mcp",
      "graphlit",
      "retrieval",
      "extraction",
      "ingestion",
      "web",
      "notifications"
    ],
    "arguments": {
      "GRAPHLIT_ORGANIZATION_ID": {
        "description": "Your organization ID from Graphlit Platform",
        "required": true,
        "example": "your-organization-id"
      },
      "GRAPHLIT_ENVIRONMENT_ID": {
        "description": "Your environment ID from Graphlit Platform",
        "required": true,
        "example": "your-environment-id"
      },
      "GRAPHLIT_JWT_SECRET": {
        "description": "Your JWT secret for signing the JWT token",
        "required": true,
        "example": "your-jwt-secret"
      }
    },
    "installations": {
      "npx": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "graphlit-mcp-server"
        ],
        "env": {
          "GRAPHLIT_ORGANIZATION_ID": "${input:organization_id}",
          "GRAPHLIT_ENVIRONMENT_ID": "${input:environment_id}",
          "GRAPHLIT_JWT_SECRET": "${input:jwt_secret}"
        },
        "description": "Run using NPX",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Query Contents",
        "description": "Retrieve relevant content from your Graphlit project",
        "prompt": "Use the Graphlit MCP Server to search for information about machine learning in my project"
      }
    ],
    "name": "graphlit-mcp-server",
    "description": "The Model Context Protocol (MCP) Server enables integration between MCP clients and the Graphlit service. This document outlines the setup process and provides a basic example of using the client.",
    "categories": [
      "Knowledge Base"
    ],
    "tools": [
      {
        "name": "configureProject",
        "description": "Configures the default content workflow for the Graphlit project. Only needed if user asks to configure the default workflow.\n    Optionally accepts whether to enable high-quality document and web page preparation using a vision LLM. Defaults to using Azure AI Document Intelligence for document preparation, if not assigned.\n    Optionally accepts whether to enable entity extraction using LLM into the knowledge graph. Defaults to no entity extraction, if not assigned.\n    Optionally accepts the preferred model provider service type, i.e. Anthropic, OpenAI, Google. Defaults to Anthropic if not provided.\n    Returns the project identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "enablePreparation": {
              "type": "boolean",
              "default": false,
              "description": "Whether to enable high-quality document and web page preparation using vision LLM. Defaults to False."
            },
            "enableExtraction": {
              "type": "boolean",
              "default": false,
              "description": "Whether to enable entity extraction using LLM into the knowledge graph. Defaults to False."
            },
            "serviceType": {
              "type": "string",
              "enum": [
                "ANTHROPIC",
                "AZURE_AI",
                "AZURE_OPEN_AI",
                "CEREBRAS",
                "COHERE",
                "DEEPSEEK",
                "GOOGLE",
                "GROQ",
                "JINA",
                "MISTRAL",
                "OPEN_AI",
                "REPLICATE",
                "VOYAGE"
              ],
              "default": "ANTHROPIC",
              "description": "Preferred model provider service type, i.e. Anthropic, OpenAI, Google. Defaults to Anthropic if not provided."
            }
          }
        }
      },
      {
        "name": "askGraphlit",
        "description": "Ask questions about the Graphlit API or SDKs. Can create code samples for any API call.\n    Accepts an LLM user prompt for code generation.\n    Returns the LLM prompt completion in Markdown format.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "LLM user prompt for code generation."
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "retrieveSources",
        "description": "Retrieve relevant content sources from Graphlit knowledge base. Do *not* use for retrieving content by content identifier - retrieve content resource instead, with URI 'contents://{id}'.\n    Accepts an LLM user prompt for content retrieval. For best retrieval quality, provide only key words or phrases from the user prompt, which will be used to create text embeddings for a vector search query.\n    Only use when there is a valid LLM user prompt for content retrieval, otherwise use queryContents. For example 'recent content' is not a useful user prompt, since it doesn't reference the text in the content.\n    Accepts an optional ingestion recency filter (defaults to null, meaning all time), and optional content type and file type filters.\n    Also accepts optional feed and collection identifiers to filter content by.\n    Returns the ranked content sources, including their content resource URI to retrieve the complete Markdown text.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "LLM user prompt for content retrieval."
            },
            "inLast": {
              "type": "string",
              "description": "Recency filter for content ingested 'in last' timespan, optional. Should be ISO 8601 format, for example, 'PT1H' for last hour, 'P1D' for last day, 'P7D' for last week, 'P30D' for last month. Doesn't support weeks or months explicitly."
            },
            "contentType": {
              "type": "string",
              "enum": [
                "EMAIL",
                "EVENT",
                "FILE",
                "ISSUE",
                "MESSAGE",
                "PAGE",
                "POST",
                "TEXT"
              ],
              "description": "Content type filter, optional. One of: Email, Event, File, Issue, Message, Page, Post, Text."
            },
            "fileType": {
              "type": "string",
              "enum": [
                "ANIMATION",
                "AUDIO",
                "CODE",
                "DATA",
                "DOCUMENT",
                "DRAWING",
                "EMAIL",
                "GEOMETRY",
                "IMAGE",
                "MANIFEST",
                "PACKAGE",
                "POINT_CLOUD",
                "SHAPE",
                "UNKNOWN",
                "VIDEO"
              ],
              "description": "File type filter, optional. One of: Animation, Audio, Code, Data, Document, Drawing, Email, Geometry, Image, Package, PointCloud, Shape, Video."
            },
            "feeds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Feed identifiers to filter content by, optional."
            },
            "collections": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Collection identifiers to filter content by, optional."
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "retrieveImages",
        "description": "Retrieve images from Graphlit knowledge base. Provides image-specific retrieval when image similarity search is desired.\n    Do *not* use for retrieving content by content identifier - retrieve content resource instead, with URI 'contents://{id}'.\n    Accepts image URL. Image will be used for similarity search using image embeddings.\n    Accepts optional geo-location filter for search by latitude, longitude and optional distance radius. Images taken with GPS enabled are searchable by geo-location.\n    Also accepts optional recency filter (defaults to null, meaning all time), and optional feed and collection identifiers to filter images by.\n    Returns the matching images, including their content resource URI to retrieve the complete Markdown text.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of image which will be used for similarity search using image embeddings."
            },
            "inLast": {
              "type": "string",
              "description": "Recency filter for images ingested 'in last' timespan, optional. Should be ISO 8601 format, for example, 'PT1H' for last hour, 'P1D' for last day, 'P7D' for last week, 'P30D' for last month. Doesn't support weeks or months explicitly."
            },
            "feeds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Feed identifiers to filter images by, optional."
            },
            "collections": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Collection identifiers to filter images by, optional."
            },
            "location": {
              "type": "object",
              "properties": {
                "latitude": {
                  "type": "number",
                  "minimum": -90,
                  "maximum": 90,
                  "description": "The latitude, must be between -90 and 90."
                },
                "longitude": {
                  "type": "number",
                  "minimum": -180,
                  "maximum": 180,
                  "description": "The longitude, must be between -180 and 180."
                },
                "distance": {
                  "type": "number",
                  "description": "The distance radius (in meters)."
                }
              },
              "required": [
                "latitude",
                "longitude"
              ],
              "additionalProperties": false,
              "description": "Geo-location filter for search by latitude, longitude and optional distance radius."
            },
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Limit the number of images to be returned. Defaults to 100."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "extractText",
        "description": "Extracts JSON data from text using LLM.\n    Accepts text to be extracted, and JSON schema which describes the data which will be extracted. JSON schema needs be of type 'object' and include 'properties' and 'required' fields.\n    Optionally accepts text prompt which is provided to LLM to guide data extraction. Defaults to 'Extract data using the tools provided'.\n    Returns extracted JSON from text.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Text to be extracted with LLM."
            },
            "schema": {
              "type": "string",
              "description": "JSON schema which describes the data which will be extracted. JSON schema needs be of type 'object' and include 'properties' and 'required' fields."
            },
            "prompt": {
              "type": "string",
              "description": "Text prompt which is provided to LLM to guide data extraction, optional."
            }
          },
          "required": [
            "text",
            "schema"
          ]
        }
      },
      {
        "name": "createCollection",
        "description": "Create a collection.\n    Accepts a collection name, and optional list of content identifiers to add to collection.\n    Returns the collection identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Collection name."
            },
            "contents": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Content identifiers to add to collection, optional."
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "addContentsToCollection",
        "description": "Add contents to a collection.\n    Accepts a collection identifier and a list of content identifiers to add to collection.\n    Returns the collection identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Collection identifier."
            },
            "contents": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Content identifiers to add to collection."
            }
          },
          "required": [
            "id",
            "contents"
          ]
        }
      },
      {
        "name": "removeContentsFromCollection",
        "description": "Remove contents from collection.\n    Accepts a collection identifier and a list of content identifiers to remove from collection.\n    Returns the collection identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Collection identifier."
            },
            "contents": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Content identifiers to remove from collection."
            }
          },
          "required": [
            "id",
            "contents"
          ]
        }
      },
      {
        "name": "deleteContent",
        "description": "Deletes content from Graphlit knowledge base.\n    Accepts content identifier.\n    Returns the content identifier and content state, i.e. Deleted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Content identifier."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "deleteCollection",
        "description": "Deletes collection from Graphlit knowledge base.\n    Does *not* delete the contents in the collection, only the collection itself.\n    Accepts collection identifier.\n    Returns the collection identifier and collection state, i.e. Deleted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Collection identifier."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "deleteFeed",
        "description": "Deletes feed from Graphlit knowledge base.\n    *Does* delete the contents in the feed, in addition to the feed itself.\n    Accepts feed identifier.\n    Returns the feed identifier and feed state, i.e. Deleted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Feed identifier."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "deleteFeeds",
        "description": "Deletes feeds from Graphlit knowledge base.\n    *Does* delete the contents in the feed, in addition to the feed itself.\n    Accepts optional feed type filter to limit the feeds which will be deleted.\n    Also accepts optional limit of how many feeds to delete, defaults to 100.\n    Returns the feed identifiers and feed state, i.e. Deleted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "feedType": {
              "type": "string",
              "enum": [
                "DISCORD",
                "EMAIL",
                "INTERCOM",
                "ISSUE",
                "MICROSOFT_TEAMS",
                "NOTION",
                "REDDIT",
                "RSS",
                "SEARCH",
                "SITE",
                "SLACK",
                "TWITTER",
                "WEB",
                "YOU_TUBE",
                "ZENDESK"
              ],
              "description": "Feed type filter, optional. One of: Discord, Email, Intercom, Issue, MicrosoftTeams, Notion, Reddit, Rss, Search, Site, Slack, Web, YouTube, Zendesk."
            },
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Limit the number of feeds to be deleted. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "deleteCollections",
        "description": "Deletes collections from Graphlit knowledge base.\n    Does *not* delete the contents in the collections, only the collections themselves.\n    Accepts optional limit of how many collections to delete, defaults to 100.\n    Returns the collection identifiers and collection state, i.e. Deleted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Limit the number of collections to be deleted. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "deleteContents",
        "description": "Deletes contents from Graphlit knowledge base.\n    Accepts optional content type and file type filters to limit the contents which will be deleted.\n    Also accepts optional limit of how many contents to delete, defaults to 1000.\n    Returns the content identifiers and content state, i.e. Deleted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentType": {
              "type": "string",
              "enum": [
                "EMAIL",
                "EVENT",
                "FILE",
                "ISSUE",
                "MESSAGE",
                "PAGE",
                "POST",
                "TEXT"
              ],
              "description": "Content type filter, optional. One of: Email, Event, File, Issue, Message, Page, Post, Text."
            },
            "fileType": {
              "type": "string",
              "enum": [
                "ANIMATION",
                "AUDIO",
                "CODE",
                "DATA",
                "DOCUMENT",
                "DRAWING",
                "EMAIL",
                "GEOMETRY",
                "IMAGE",
                "MANIFEST",
                "PACKAGE",
                "POINT_CLOUD",
                "SHAPE",
                "UNKNOWN",
                "VIDEO"
              ],
              "description": "File type filter, optional. One of: Animation, Audio, Code, Data, Document, Drawing, Email, Geometry, Image, Package, PointCloud, Shape, Video."
            },
            "limit": {
              "type": "number",
              "default": 1000,
              "description": "Limit the number of contents to be deleted. Defaults to 1000."
            }
          }
        }
      },
      {
        "name": "queryContents",
        "description": "Query contents from Graphlit knowledge base. Do *not* use for retrieving content by content identifier - retrieve content resource instead, with URI 'contents://{id}'.\n    Accepts optional content name, content type and file type for metadata filtering.\n    Accepts optional recency filter (defaults to null, meaning all time), and optional feed and collection identifiers to filter images by.\n    Accepts optional geo-location filter for search by latitude, longitude and optional distance radius. Images and videos taken with GPS enabled are searchable by geo-location.\n    Returns the matching contents, including their content resource URI to retrieve the complete Markdown text.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Textual match on content name."
            },
            "type": {
              "type": "string",
              "enum": [
                "EMAIL",
                "EVENT",
                "FILE",
                "ISSUE",
                "MESSAGE",
                "PAGE",
                "POST",
                "TEXT"
              ],
              "description": "Filter by content type."
            },
            "fileType": {
              "type": "string",
              "enum": [
                "ANIMATION",
                "AUDIO",
                "CODE",
                "DATA",
                "DOCUMENT",
                "DRAWING",
                "EMAIL",
                "GEOMETRY",
                "IMAGE",
                "MANIFEST",
                "PACKAGE",
                "POINT_CLOUD",
                "SHAPE",
                "UNKNOWN",
                "VIDEO"
              ],
              "description": "Filter by file type."
            },
            "inLast": {
              "type": "string",
              "description": "Recency filter for content ingested 'in last' timespan, optional. Should be ISO 8601 format, for example, 'PT1H' for last hour, 'P1D' for last day, 'P7D' for last week, 'P30D' for last month. Doesn't support weeks or months explicitly."
            },
            "feeds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Feed identifiers to filter contents by, optional."
            },
            "collections": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Collection identifiers to filter contents by, optional."
            },
            "location": {
              "type": "object",
              "properties": {
                "latitude": {
                  "type": "number",
                  "minimum": -90,
                  "maximum": 90,
                  "description": "The latitude, must be between -90 and 90."
                },
                "longitude": {
                  "type": "number",
                  "minimum": -180,
                  "maximum": 180,
                  "description": "The longitude, must be between -180 and 180."
                },
                "distance": {
                  "type": "number",
                  "description": "The distance radius (in meters)."
                }
              },
              "required": [
                "latitude",
                "longitude"
              ],
              "additionalProperties": false,
              "description": "Geo-location filter for search by latitude, longitude and optional distance radius."
            },
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Limit the number of contents to be returned. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "queryCollections",
        "description": "Query collections from Graphlit knowledge base. Do *not* use for retrieving collection by collection identifier - retrieve collection resource instead, with URI 'collections://{id}'.\n    Accepts optional collection name for metadata filtering.\n    Returns the matching collections, including their collection resource URI to retrieve the collection contents.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Textual match on collection name."
            },
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Limit the number of collections to be returned. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "queryFeeds",
        "description": "Query feeds from Graphlit knowledge base. Do *not* use for retrieving feed by feed identifier - retrieve feed resource instead, with URI 'feeds://{id}'.\n    Accepts optional feed name and feed type for metadata filtering.\n    Returns the matching feeds, including their feed resource URI to retrieve the feed contents.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Textual match on feed name."
            },
            "type": {
              "type": "string",
              "enum": [
                "DISCORD",
                "EMAIL",
                "INTERCOM",
                "ISSUE",
                "MICROSOFT_TEAMS",
                "NOTION",
                "REDDIT",
                "RSS",
                "SEARCH",
                "SITE",
                "SLACK",
                "TWITTER",
                "WEB",
                "YOU_TUBE",
                "ZENDESK"
              ],
              "description": "Filter by feed type."
            },
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Limit the number of feeds to be returned. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "isContentDone",
        "description": "Check if content has completed asynchronous ingestion.\n    Accepts a content identifier which was returned from one of the non-feed ingestion tools, like ingestUrl.\n    Returns whether the content is done or not.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Content identifier."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "isFeedDone",
        "description": "Check if an asynchronous feed has completed ingesting all the available content.\n    Accepts a feed identifier which was returned from one of the ingestion tools, like ingestGoogleDriveFiles.\n    Returns whether the feed is done or not.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Feed identifier."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "listNotionDatabases",
        "description": "Lists available Notion databases.\n    Returns a list of Notion databases, where the database identifier can be used with ingestNotionPages to ingest pages into Graphlit knowledge base.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "listLinearProjects",
        "description": "Lists available Linear projects.\n    Returns a list of Linear projects, where the project name can be used with ingestLinearIssues to ingest issues into Graphlit knowledge base.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "listSlackChannels",
        "description": "Lists available Slack channels.\n    Returns a list of Slack channels, where the channel name can be used with ingestSlackMessages to ingest messages into Graphlit knowledge base.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "listSharePointLibraries",
        "description": "Lists available SharePoint libraries.\n    Returns a list of SharePoint libraries, where the selected libraryId can be used with listSharePointFolders to enumerate SharePoint folders in a library.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "listSharePointFolders",
        "description": "Lists available SharePoint folders.\n    Returns a list of SharePoint folders, which can be used with ingestSharePointFiles to ingest files into Graphlit knowledge base.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "libraryId": {
              "type": "string",
              "description": "SharePoint library identifier."
            }
          },
          "required": [
            "libraryId"
          ]
        }
      },
      {
        "name": "ingestSharePointFiles",
        "description": "Ingests files from SharePoint library into Graphlit knowledge base.\n    Accepts a SharePoint libraryId and an optional folderId to ingest files from a specific SharePoint folder.\n    Libraries can be enumerated with listSharePointLibraries and library folders with listSharePointFolders.\n    Accepts an optional read limit for the number of files to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "libraryId": {
              "type": "string",
              "description": "SharePoint library identifier."
            },
            "folderId": {
              "type": "string",
              "description": "SharePoint folder identifier, optional."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "libraryId"
          ]
        }
      },
      {
        "name": "ingestOneDriveFiles",
        "description": "Ingests files from OneDrive folder into Graphlit knowledge base.\n    Accepts an optional read limit for the number of files to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestGoogleDriveFiles",
        "description": "Ingests files from Google Drive folder into Graphlit knowledge base.\n    Accepts an optional read limit for the number of files to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestDropboxFiles",
        "description": "Ingests files from Dropbox folder into Graphlit knowledge base.\n    Accepts optional relative path to Dropbox folder (i.e. /Pictures), and an optional read limit for the number of files to ingest.\n    If no path provided, ingests files from root Dropbox folder.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Relative path to Dropbox folder, optional."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestBoxFiles",
        "description": "Ingests files from Box folder into Graphlit knowledge base.\n    Accepts optional Box folder identifier, and an optional read limit for the number of files to ingest.\n    If no folder identifier provided, ingests files from root Box folder (i.e. \"0\").\n    Folder identifier can be inferred from Box URL. https://app.box.com/folder/123456 -> folder identifier is \"123456\".\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folderId": {
              "type": "string",
              "default": "0",
              "description": "Box folder identifier, optional. Defaults to root folder."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestGitHubFiles",
        "description": "Ingests files from GitHub repository into Graphlit knowledge base.\n    Accepts GitHub repository owner and repository name and an optional read limit for the number of files to ingest.\n    For example, for GitHub repository (https://github.com/openai/tiktoken), 'openai' is the repository owner, and 'tiktoken' is the repository name.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repositoryName": {
              "type": "string",
              "description": "GitHub repository name."
            },
            "repositoryOwner": {
              "type": "string",
              "description": "GitHub repository owner."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "repositoryName",
            "repositoryOwner"
          ]
        }
      },
      {
        "name": "ingestNotionPages",
        "description": "Ingests pages from Notion database into Graphlit knowledge base.\n    Accepts Notion database identifier and an optional read limit for the number of pages to ingest.\n    You can list the available Notion database identifiers with listNotionDatabases.\n    Or, for a Notion URL, https://www.notion.so/Example/Engineering-Wiki-114abc10cb38487e91ec906fc6c6f350, 'Engineering-Wiki-114abc10cb38487e91ec906fc6c6f350' is an example of a Notion database identifier.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "databaseId": {
              "type": "string",
              "description": "Notion database identifier."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of pages to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "databaseId"
          ]
        }
      },
      {
        "name": "ingestMicrosoftTeamsMessages",
        "description": "Ingests messages from Microsoft Teams channel into Graphlit knowledge base.\n    Accepts Microsoft Teams team identifier and channel identifier, and an optional read limit for the number of messages to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string",
              "description": "Microsoft Teams team identifier."
            },
            "channelId": {
              "type": "string",
              "description": "Microsoft Teams channel identifier."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of messages to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "teamId",
            "channelId"
          ]
        }
      },
      {
        "name": "ingestSlackMessages",
        "description": "Ingests messages from Slack channel into Graphlit knowledge base.\n        Accepts Slack channel name and an optional read limit for the number of messages to ingest.\n        Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channelName": {
              "type": "string",
              "description": "Slack channel name."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of messages to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "channelName"
          ]
        }
      },
      {
        "name": "ingestDiscordMessages",
        "description": "Ingests messages from Discord channel into Graphlit knowledge base.\n        Accepts Discord channel name and an optional read limit for the number of messages to ingest.\n        Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channelName": {
              "type": "string",
              "description": "Discord channel name."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of messages to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "channelName"
          ]
        }
      },
      {
        "name": "ingestTwitterPosts",
        "description": "Ingests posts by user from Twitter/X into Graphlit knowledge base.\n     Accepts Twitter/X user name, without the leading @ symbol, and an optional read limit for the number of posts to ingest.\n     Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "userName": {
              "type": "string",
              "description": "Twitter/X user name, without the leading @ symbol, i.e. 'graphlit'."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of posts to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "userName"
          ]
        }
      },
      {
        "name": "ingestTwitterSearch",
        "description": "Searches for recent posts from Twitter/X, and ingests them into Graphlit knowledge base.\n    Accepts search query, and an optional read limit for the number of posts to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "readLimit": {
              "type": "number",
              "description": "Number of posts to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "ingestRedditPosts",
        "description": "Ingests posts from Reddit subreddit into Graphlit knowledge base.\n        Accepts a subreddit name and an optional read limit for the number of posts to ingest.\n        Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "subredditName": {
              "type": "string",
              "description": "Subreddit name."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of posts to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "subredditName"
          ]
        }
      },
      {
        "name": "ingestGoogleEmail",
        "description": "Ingests emails from Google Email account into Graphlit knowledge base.\n    Accepts an optional read limit for the number of emails to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of emails to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestMicrosoftEmail",
        "description": "Ingests emails from Microsoft Email account into Graphlit knowledge base.\n    Accepts an optional read limit for the number of emails to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of emails to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestLinearIssues",
        "description": "Ingests issues from Linear project into Graphlit knowledge base.\n    Accepts Linear project name and an optional read limit for the number of issues to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectName": {
              "type": "string",
              "description": "Linear project name."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of issues to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "projectName"
          ]
        }
      },
      {
        "name": "ingestGitHubIssues",
        "description": "Ingests issues from GitHub repository into Graphlit knowledge base.\n    Accepts GitHub repository owner and repository name and an optional read limit for the number of issues to ingest.\n    For example, for GitHub repository (https://github.com/openai/tiktoken), 'openai' is the repository owner, and 'tiktoken' is the repository name.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repositoryName": {
              "type": "string",
              "description": "GitHub repository name."
            },
            "repositoryOwner": {
              "type": "string",
              "description": "GitHub repository owner."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of issues to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "repositoryName",
            "repositoryOwner"
          ]
        }
      },
      {
        "name": "ingestJiraIssues",
        "description": "Ingests issues from Atlassian Jira repository into Graphlit knowledge base.\n    Accepts Atlassian Jira server URL and project name, and an optional read limit for the number of issues to ingest.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Atlassian Jira server URL."
            },
            "projectName": {
              "type": "string",
              "description": "Atlassian Jira project name."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of issues to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "url",
            "projectName"
          ]
        }
      },
      {
        "name": "webCrawl",
        "description": "Crawls web pages from web site into Graphlit knowledge base.\n    Accepts a URL and an optional read limit for the number of pages to crawl.\n    Uses sitemap.xml to discover pages to be crawled from website.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Web site URL."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of web pages to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "webMap",
        "description": "Enumerates the web pages at or beneath the provided URL using web sitemap. \n    Does *not* ingest web pages into Graphlit knowledge base.\n    Accepts web site URL as string.\n    Returns list of mapped URIs from web site.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Web site URL."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "webSearch",
        "description": "Performs web or podcast search based on search query. Can search for web pages or podcasts/podcast episodes. \n    Format the search query as what would be entered into a Google search. You can use site filtering in the search query, like 'site:twitter.com'.    \n    Accepts search query as string, and optional search service type.    \n    Prefer calling this tool over using 'curl' directly for any web search.\n    *Only* use Podscan search service type to search for podcasts or podcast episodes.\n    Does *not* ingest pages into Graphlit knowledge base. *Does* ingest podcast episodes as transcribed audio files into Graphlit knowledge base.    \n    When searching for podcasts or podcast episodes, *don't* include the term 'podcast' or 'episode' in the search query - that would be redundant.\n    Search service types: Tavily (web pages), Exa (web pages) and Podscan (podcast episodes). Defaults to Exa.\n    Returns URL, title and relevant Markdown text from resulting web pages or podcast episode transcripts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query."
            },
            "searchService": {
              "type": "string",
              "enum": [
                "EXA",
                "PODSCAN",
                "TAVILY"
              ],
              "default": "EXA",
              "description": "Search service type (Tavily, Exa, Podscan). Defaults to Exa."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "ingestRSS",
        "description": "Ingests posts from RSS feed into Graphlit knowledge base.\n    For podcast RSS feeds, audio will be downloaded, transcribed and ingested into Graphlit knowledge base.\n    Accepts RSS URL and an optional read limit for the number of posts to read.\n    Executes asynchronously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "RSS URL."
            },
            "readLimit": {
              "type": "number",
              "description": "Number of issues to posts, optional. Defaults to 25."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "ingestUrl",
        "description": "Ingests content from URL into Graphlit knowledge base.\n    Can scrape web pages, and can ingest individual Word documents, PDFs, audio recordings, videos, images, or any other unstructured data.\n    Executes asynchronously and returns the content identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to ingest content from."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "ingestText",
        "description": "Ingests text as content into Graphlit knowledge base.\n    Accepts a name for the content object, the text itself, and an optional text type (Plain, Markdown, Html). Defaults to Markdown text type.\n    Optionally accepts an identifier for an existing content object. Will overwrite existing content, if provided.\n    Can use for storing long-term textual memories or the output from LLM or other tools as content resources, which can be later searched or retrieved.\n    Executes *synchronously* and returns the content identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the content object."
            },
            "text": {
              "type": "string",
              "description": "Text content to ingest."
            },
            "textType": {
              "type": "string",
              "enum": [
                "HTML",
                "MARKDOWN",
                "PLAIN"
              ],
              "default": "MARKDOWN",
              "description": "Text type (Plain, Markdown, Html). Defaults to Markdown."
            },
            "id": {
              "type": "string",
              "description": "Optional identifier for the content object. Will overwrite existing content, if provided."
            }
          },
          "required": [
            "name",
            "text"
          ]
        }
      },
      {
        "name": "ingestFile",
        "description": "Ingests local file into Graphlit knowledge base.\n    Accepts the path to the file in the local filesystem.\n    Can use for storing *large* long-term textual memories or the output from LLM or other tools as content resources, which can be later searched or retrieved.\n    Executes asynchronously and returns the content identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Path to the file in the local filesystem."
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "screenshotPage",
        "description": "Screenshots web page from URL.\n    Executes *synchronously* and returns the content identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "describeImageUrl",
        "description": "Prompts vision LLM and returns completion. \n    Does *not* ingest image into Graphlit knowledge base.\n    Accepts image URL as string.\n    Returns Markdown text from LLM completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string"
            },
            "url": {
              "type": "string"
            }
          },
          "required": [
            "prompt",
            "url"
          ]
        }
      },
      {
        "name": "describeImageContent",
        "description": "Prompts vision LLM and returns description of image content. \n    Accepts content identifier as string, and optional prompt for image description.\n    Returns Markdown text from LLM completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "prompt": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "publishAudio",
        "description": "Publishes text as audio format, and ingests into Graphlit knowledge base.\n    Accepts a name for the content object, the text itself, and an optional text type (Plain, Markdown, Html). Defaults to Markdown text type.\n    Optionally accepts an ElevenLabs voice identifier.\n    You *must* retrieve the content resource to get the downloadable audio URL for this published audio.\n    Executes *synchronously* and returns the content identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "text": {
              "type": "string"
            },
            "textType": {
              "type": "string",
              "enum": [
                "HTML",
                "MARKDOWN",
                "PLAIN"
              ],
              "default": "MARKDOWN"
            },
            "voice": {
              "type": "string",
              "default": "HqW11As4VRPkApNPkAZp"
            }
          },
          "required": [
            "name",
            "text"
          ]
        }
      },
      {
        "name": "sendWebHookNotification",
        "description": "Sends a webhook notification to the provided URL.\n    Accepts the webhook URL.\n    Also accepts the text to be sent with the webhook, and an optional text type (Plain, Markdown, Html). Defaults to Markdown text type.\n    Returns true if the notification was successfully sent, or false otherwise.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            },
            "text": {
              "type": "string"
            },
            "textType": {
              "type": "string",
              "enum": [
                "HTML",
                "MARKDOWN",
                "PLAIN"
              ],
              "default": "MARKDOWN"
            }
          },
          "required": [
            "url",
            "text"
          ]
        }
      },
      {
        "name": "sendSlackNotification",
        "description": "Sends a Slack notification to the provided Slack channel.\n    Accepts the Slack channel name.\n    Also accepts the text for the Slack message, and an optional text type (Plain, Markdown, Html). Defaults to Markdown text type.\n    Hint: In Slack Markdown, images are displayed by simply putting the URL in angle brackets like <https://example.com/image.jpg> instead of using the traditional Markdown image syntax ![alt text](url). \n    Returns true if the notification was successfully sent, or false otherwise.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channelName": {
              "type": "string"
            },
            "text": {
              "type": "string"
            },
            "textType": {
              "type": "string",
              "enum": [
                "HTML",
                "MARKDOWN",
                "PLAIN"
              ],
              "default": "MARKDOWN"
            }
          },
          "required": [
            "channelName",
            "text"
          ]
        }
      },
      {
        "name": "sendTwitterNotification",
        "description": "Posts a tweet from the configured user account.\n    Accepts the plain text for the tweet.\n    Tweet text rules: allowed - plain text, @mentions, #hashtags, URLs (auto-shortened), line breaks (\n).  \n    Not allowed - markdown, HTML tags, rich text, or custom styles.\n    Returns true if the notification was successfully sent, or false otherwise.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string"
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "sendEmailNotification",
        "description": "Sends an email notification to the provided email address(es).\n    Accepts the email subject and a list of email 'to' addresses.\n    Email addresses should be in RFC 5322 format. i.e. Alice Wonderland <alice@wonderland.net>, or alice@wonderland.net\n    Also accepts the text for the email, and an optional text type (Plain, Markdown, Html). Defaults to Markdown text type.\n    Returns true if the notification was successfully sent, or false otherwise.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "subject": {
              "type": "string"
            },
            "to": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "text": {
              "type": "string"
            },
            "textType": {
              "type": "string",
              "enum": [
                "HTML",
                "MARKDOWN",
                "PLAIN"
              ],
              "default": "MARKDOWN"
            }
          },
          "required": [
            "subject",
            "to",
            "text"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "mac-messages-mcp": {
    "name": "mac-messages-mcp",
    "display_name": "Mac Messages",
    "description": "An MCP server that securely interfaces with your iMessage database via the Model Context Protocol (MCP), allowing LLMs to query and analyze iMessage conversations. It includes robust phone number validation, attachment processing, contact management, group chat handling, and full support for sending and receiving messages.",
    "repository": {
      "type": "git",
      "url": "https://github.com/carterlasalle/mac_messages_mcp"
    },
    "homepage": "https://github.com/carterlasalle/mac_messages_mcp",
    "author": {
      "name": "carterlasalle"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mac-messages-mcp"
        ]
      }
    },
    "tags": [
      "python",
      "mac",
      "messages"
    ],
    "tools": [
      {
        "name": "tool_get_recent_messages",
        "description": "\n    Get recent messages from the Messages app.\n    \n    Args:\n        hours: Number of hours to look back (default: 24)\n        contact: Filter by contact name, phone number, or email (optional)\n                Use \"contact:N\" to select a specific contact from previous matches\n    ",
        "inputSchema": {
          "properties": {
            "hours": {
              "default": 24,
              "title": "Hours",
              "type": "integer"
            },
            "contact": {
              "default": null,
              "title": "Contact",
              "type": "string"
            }
          },
          "title": "tool_get_recent_messagesArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_send_message",
        "description": "\n    Send a message using the Messages app.\n    \n    Args:\n        recipient: Phone number, email, contact name, or \"contact:N\" to select from matches\n                  For example, \"contact:1\" selects the first contact from a previous search\n        message: Message text to send\n        group_chat: Whether to send to a group chat (uses chat ID instead of buddy)\n    ",
        "inputSchema": {
          "properties": {
            "recipient": {
              "title": "Recipient",
              "type": "string"
            },
            "message": {
              "title": "Message",
              "type": "string"
            },
            "group_chat": {
              "default": false,
              "title": "Group Chat",
              "type": "boolean"
            }
          },
          "required": [
            "recipient",
            "message"
          ],
          "title": "tool_send_messageArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_find_contact",
        "description": "\n    Find a contact by name using fuzzy matching.\n    \n    Args:\n        name: The name to search for\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            }
          },
          "required": [
            "name"
          ],
          "title": "tool_find_contactArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_check_db_access",
        "description": "\n    Diagnose database access issues.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "tool_check_db_accessArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_check_contacts",
        "description": "\n    List available contacts in the address book.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "tool_check_contactsArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_check_addressbook",
        "description": "\n    Diagnose AddressBook access issues.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "tool_check_addressbookArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_get_chats",
        "description": "\n    List available group chats from the Messages app.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "tool_get_chatsArguments",
          "type": "object"
        }
      }
    ]
  },
  "llamacloud": {
    "name": "llamacloud",
    "display_name": "LlamaCloud",
    "description": "Integrate the data stored in a managed index on [LlamaCloud](https://cloud.llamaindex.ai/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/run-llama/mcp-server-llamacloud"
    },
    "homepage": "https://github.com/run-llama/mcp-server-llamacloud",
    "author": {
      "name": "run-llama"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "LlamaCloud",
      "TypeScript"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@llamaindex/mcp-server-llamacloud",
          "--index",
          "10k-SEC-Tesla",
          "--description",
          "10k SEC documents from 2023 for Tesla",
          "--index",
          "10k-SEC-Apple",
          "--description",
          "10k SEC documents from 2023 for Apple"
        ],
        "env": {
          "LLAMA_CLOUD_PROJECT_NAME": "<YOUR_PROJECT_NAME>",
          "LLAMA_CLOUD_API_KEY": "<YOUR_API_KEY>"
        }
      }
    },
    "arguments": {
      "LLAMA_CLOUD_PROJECT_NAME": {
        "description": "The name of your LlamaCloud project that you want to use with the transfer tools.",
        "required": true,
        "example": "MyProject"
      },
      "LLAMA_CLOUD_API_KEY": {
        "description": "Your API key for accessing LlamaCloud services, which is necessary for authentication.",
        "required": true,
        "example": "1234567890abcdef"
      }
    },
    "tools": [
      {
        "name": "get_information_10k_sec_tesla",
        "description": "Get information from the 10k-SEC-Tesla index. The index contains 10k SEC documents from 2023 for Tesla",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query used to get information from the 10k-SEC-Tesla index."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_information_10k_sec_apple",
        "description": "Get information from the 10k-SEC-Apple index. The index contains 10k SEC documents from 2023 for Apple",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query used to get information from the 10k-SEC-Apple index."
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "mcp-server-motherduck": {
    "name": "mcp-server-motherduck",
    "description": "Query and analyze data with MotherDuck and local DuckDB",
    "display_name": "MotherDuck MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/motherduckdb/mcp-server-motherduck"
    },
    "homepage": "https://motherduck.com",
    "author": {
      "name": "motherduckdb"
    },
    "license": "MIT",
    "tags": [
      "SQL",
      "DuckDB",
      "MotherDuck",
      "analytics",
      "database"
    ],
    "arguments": {
      "db-path": {
        "description": "Path to the database to connect to (md: for MotherDuck, :memory: for in-memory, or path to local file)",
        "required": true,
        "example": "md:"
      },
      "motherduck-token": {
        "description": "MotherDuck access token for authentication",
        "required": true,
        "example": "<YOUR_MOTHERDUCK_TOKEN_HERE>"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-motherduck",
          "--db-path",
          "md:",
          "--motherduck-token",
          "${input:motherduck_token}"
        ],
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Create a new database and table",
        "description": "Create a new database and table in MotherDuck",
        "prompt": "Create a new database and table in MotherDuck"
      },
      {
        "title": "Query local CSV file",
        "description": "Query data from a local CSV file",
        "prompt": "Query data from my local CSV file"
      },
      {
        "title": "Join data across sources",
        "description": "Join data from local DuckDB with MotherDuck tables",
        "prompt": "Join data from my local DuckDB database with a table in MotherDuck"
      },
      {
        "title": "Analyze S3 data",
        "description": "Analyze data stored in Amazon S3",
        "prompt": "Analyze data stored in Amazon S3"
      }
    ],
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "replicate": {
    "name": "replicate",
    "display_name": "Replicate",
    "description": "Search, run and manage machine learning models on Replicate through a simple tool-based interface. Browse models, create predictions, track their status, and handle generated images.",
    "repository": {
      "type": "git",
      "url": "https://github.com/deepfates/mcp-replicate"
    },
    "homepage": "https://github.com/deepfates/mcp-replicate",
    "author": {
      "name": "deepfates"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Replicate",
      "API"
    ],
    "examples": [
      {
        "title": "Run a model prediction",
        "description": "Creates a prediction using a specified model and input parameters.",
        "prompt": "create_prediction(model_id='model_id_here', input_params='input_params_here')"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "mcp-replicate"
        ],
        "env": {
          "REPLICATE_API_TOKEN": "${REPLICATE_API_TOKEN}"
        }
      }
    },
    "arguments": {
      "REPLICATE_API_TOKEN": {
        "description": "Your Replicate API token to authenticate requests to the Replicate API. Needed for the server to function and fetch models or execute predictions.",
        "required": true,
        "example": "your_token_here"
      }
    },
    "tools": [
      {
        "name": "search_models",
        "description": "Search for models using semantic search",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "list_models",
        "description": "List available models with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Filter by model owner"
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor"
            }
          }
        }
      },
      {
        "name": "list_collections",
        "description": "List available model collections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "type": "string",
              "description": "Pagination cursor"
            }
          }
        }
      },
      {
        "name": "get_collection",
        "description": "Get details of a specific collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "slug": {
              "type": "string",
              "description": "Collection slug"
            }
          },
          "required": [
            "slug"
          ]
        }
      },
      {
        "name": "create_prediction",
        "description": "Create a new prediction using either a model version (for community models) or model name (for official models)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "version": {
              "type": "string",
              "description": "Model version ID to use (for community models)"
            },
            "model": {
              "type": "string",
              "description": "Model name to use (for official models)"
            },
            "input": {
              "type": "object",
              "description": "Input parameters for the model",
              "additionalProperties": true
            },
            "webhook_url": {
              "type": "string",
              "description": "Optional webhook URL for notifications"
            }
          },
          "oneOf": [
            {
              "required": [
                "version",
                "input"
              ]
            },
            {
              "required": [
                "model",
                "input"
              ]
            }
          ]
        }
      },
      {
        "name": "cancel_prediction",
        "description": "Cancel a running prediction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prediction_id": {
              "type": "string",
              "description": "ID of the prediction to cancel"
            }
          },
          "required": [
            "prediction_id"
          ]
        }
      },
      {
        "name": "get_prediction",
        "description": "Get details about a specific prediction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prediction_id": {
              "type": "string",
              "description": "ID of the prediction to get details for"
            }
          },
          "required": [
            "prediction_id"
          ]
        }
      },
      {
        "name": "list_predictions",
        "description": "List recent predictions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of predictions to return",
              "default": 10
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            }
          }
        }
      },
      {
        "name": "get_model",
        "description": "Get details of a specific model including available versions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Model owner"
            },
            "name": {
              "type": "string",
              "description": "Model name"
            }
          },
          "required": [
            "owner",
            "name"
          ]
        }
      },
      {
        "name": "view_image",
        "description": "Display an image in the system's default web browser",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the image to display"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "clear_image_cache",
        "description": "Clear the image viewer cache",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_image_cache_stats",
        "description": "Get statistics about the image cache",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "metoro-mcp-server": {
    "display_name": "Metoro MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/metoro-io/metoro-mcp-server"
    },
    "homepage": "https://metoro.io/",
    "author": {
      "name": "metoro-io"
    },
    "license": "MIT",
    "tags": [
      "kubernetes",
      "observability",
      "eBPF",
      "microservices"
    ],
    "arguments": {
      "METORO_AUTH_TOKEN": {
        "description": "Authentication token for Metoro API access",
        "required": true,
        "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjdXN0b21lcklkIjoiOThlZDU1M2QtYzY4ZC00MDRhLWFhZjItNDM2ODllNWJiMGUzIiwiZW1haWwiOiJ0ZXN0QGNocmlzYmF0dGFyYmVlLmNvbSIsImV4cCI6MTgyMTI0NzIzN30.7G6alDpcZh_OThYj293Jce5rjeOBqAhOlANR_Fl5auw"
      },
      "METORO_API_URL": {
        "description": "URL for the Metoro API",
        "required": true,
        "example": "https://us-east.metoro.io"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "metoro-mcp-server",
        "args": [],
        "description": "Run the Metoro MCP server executable built from Go",
        "env": {
          "METORO_AUTH_TOKEN": "<your auth token>",
          "METORO_API_URL": "https://us-east.metoro.io"
        }
      }
    },
    "examples": [
      {
        "title": "Kubernetes Cluster Interaction",
        "description": "Ask questions about your Kubernetes cluster through Claude Desktop App",
        "prompt": "What services are running in my Kubernetes cluster?"
      }
    ],
    "name": "metoro-mcp-server",
    "description": "This MCP Server allows you to interact with your Kubernetes cluster via the Claude Desktop App!",
    "categories": [
      "MCP Tools"
    ],
    "is_official": true
  },
  "brave-search": {
    "name": "brave-search",
    "display_name": "Brave Search",
    "description": "Web and local search using Brave's Search API",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/brave-search",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "brave",
      "search",
      "web",
      "local"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-brave-search"
        ],
        "env": {
          "BRAVE_API_KEY": "${BRAVE_API_KEY}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "BRAVE_API_KEY",
          "mcp/brave-search"
        ],
        "env": {
          "BRAVE_API_KEY": "${BRAVE_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Web Search Example",
        "description": "Execute a web search with pagination and filtering.",
        "prompt": "brave_web_search(query=\"example search\", count=10, offset=0)"
      },
      {
        "title": "Local Search Example",
        "description": "Search for local businesses and services.",
        "prompt": "brave_local_search(query=\"restaurants near me\", count=5)"
      }
    ],
    "arguments": {
      "BRAVE_API_KEY": {
        "description": "The API key required to authenticate requests to the Brave Search API.",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      }
    },
    "tools": [
      {
        "name": "brave_web_search",
        "description": "Performs a web search using the Brave Search API, ideal for general queries, news, articles, and online content. Use this for broad information gathering, recent events, or when you need diverse web sources. Supports pagination, content filtering, and freshness controls. Maximum 20 results per request, with offset for pagination. ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query (max 400 chars, 50 words)"
            },
            "count": {
              "type": "number",
              "description": "Number of results (1-20, default 10)",
              "default": 10
            },
            "offset": {
              "type": "number",
              "description": "Pagination offset (max 9, default 0)",
              "default": 0
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "brave_local_search",
        "description": "Searches for local businesses and places using Brave's Local Search API. Best for queries related to physical locations, businesses, restaurants, services, etc. Returns detailed information including:\n- Business names and addresses\n- Ratings and review counts\n- Phone numbers and opening hours\nUse this when the query implies 'near me' or mentions specific locations. Automatically falls back to web search if no local results are found.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Local search query (e.g. 'pizza near Central Park')"
            },
            "count": {
              "type": "number",
              "description": "Number of results (1-20, default 5)",
              "default": 5
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ],
    "is_official": true
  },
  "naver": {
    "name": "naver",
    "display_name": "Naver",
    "description": "This MCP server provides tools to interact with various Naver services, such as searching blogs, news, books, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pfldy2850/py-mcp-naver"
    },
    "homepage": "https://github.com/pfldy2850/py-mcp-naver",
    "author": {
      "name": "pfldy2850"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Naver",
      "API",
      "OpenAPI",
      "Search"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pfldy2850/py-mcp-naver.git",
          "src/server.py"
        ],
        "env": {
          "NAVER_CLIENT_ID": "${NAVER_CLIENT_ID}",
          "NAVER_CLIENT_SECRET": "${NAVER_CLIENT_SECRET}"
        }
      }
    },
    "examples": [
      {
        "title": "Search Blog Posts",
        "description": "Search blog posts on Naver using a query.",
        "prompt": "search_blog('your query here')"
      },
      {
        "title": "Search News Articles",
        "description": "Search news articles on Naver using a query.",
        "prompt": "search_news('your query here')"
      },
      {
        "title": "Search Books",
        "description": "Search books on Naver using a query.",
        "prompt": "search_book('your query here')"
      }
    ],
    "arguments": {
      "NAVER_CLIENT_ID": {
        "description": "The Client ID for accessing the Naver Open API, obtained from the Naver developer portal.",
        "required": true,
        "example": "your_naver_client_id"
      },
      "NAVER_CLIENT_SECRET": {
        "description": "The Client Secret for accessing the Naver Open API, obtained from the Naver developer portal.",
        "required": true,
        "example": "your_naver_client_secret"
      }
    },
    "tools": [
      {
        "name": "search_blog",
        "description": "Search blog posts on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for blog posts"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_news",
        "description": "Search news articles on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for news articles"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_book",
        "description": "Search books on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for books"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "get_book_adv",
        "description": "Get detailed book information using title or ISBN.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for book title or ISBN (optional)"
          },
          "d_titl": {
            "type": "string",
            "description": "Book title (optional)"
          },
          "d_isbn": {
            "type": "string",
            "description": "Book ISBN (optional)"
          }
        },
        "required": []
      },
      {
        "name": "adult_check",
        "description": "Check if a search term is adult content.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search term to check for adult content"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_encyc",
        "description": "Search encyclopedia entries on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for encyclopedia entries"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_cafe_article",
        "description": "Search articles in Naver cafes.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for cafe articles"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_kin",
        "description": "Search questions and answers on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for Q&A"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_local",
        "description": "Search local information on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for local information"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'random')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "fix_spelling",
        "description": "Correct spelling errors in a given text.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Text to correct spelling errors"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_webkr",
        "description": "Search web pages on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for web pages"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_image",
        "description": "Search images on Naver with filters.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for images"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          },
          "filter": {
            "type": "string",
            "description": "Filter for image search (default: 'all')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_shop",
        "description": "Search shopping items on Naver with filters.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for shopping items"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          },
          "filter": {
            "type": "string",
            "description": "Filter for shopping search (optional)"
          },
          "exclude": {
            "type": "string",
            "description": "Exclude filter for shopping search (optional)"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_doc",
        "description": "Search documents on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for documents"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "forevervm": {
    "display_name": "ForeverVM MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/jamsocket/forevervm"
    },
    "homepage": "https://forevervm.com/docs/guides/forevervm-mcp-server/",
    "author": {
      "name": "jamsocket"
    },
    "license": "MIT",
    "tags": [
      "python",
      "repl",
      "claude"
    ],
    "arguments": {
      "client": {
        "description": "Client to use",
        "required": true,
        "example": "claude"
      }
    },
    "installations": {
      "cli": {
        "type": "cli",
        "command": "npx",
        "args": [
          "forevervm-mcp",
          "install",
          "--client",
          "${client}"
        ]
      }
    },
    "examples": [
      {
        "title": "Create a Python REPL",
        "description": "Create a new Python REPL environment",
        "prompt": "create-python-repl"
      },
      {
        "title": "Run Python code",
        "description": "Execute Python code in an existing REPL",
        "prompt": "run-python-in-repl"
      }
    ],
    "name": "forevervm",
    "description": "data-color-mode=\"auto\" data-light-theme=\"light\" data-dark-theme=\"dark\"",
    "categories": [
      "System Tools"
    ],
    "is_official": true
  },
  "kibela": {
    "name": "kibela",
    "display_name": "Kibela",
    "description": "Interact with Kibela API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kiwamizamurai/mcp-kibela-server"
    },
    "homepage": "https://github.com/kiwamizamurai/mcp-kibela-server",
    "author": {
      "name": "kiwamizamurai"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Kibela",
      "Integration"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/kiwamizamurai/mcp-kibela-server"
        ],
        "env": {
          "KIBELA_TEAM": "${KIBELA_TEAM}",
          "KIBELA_TOKEN": "${KIBELA_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Search Kibela notes",
        "description": "Search through your Kibela notes using a query.",
        "prompt": "kibela_search_notes(\"my search query\")"
      },
      {
        "title": "Get latest notes",
        "description": "Retrieve your latest notes from Kibela.",
        "prompt": "kibela_get_my_notes()"
      },
      {
        "title": "Get note content",
        "description": "Fetch content of a specific note by ID.",
        "prompt": "kibela_get_note_content(\"note-id\")"
      }
    ],
    "arguments": {
      "KIBELA_TEAM": {
        "description": "Your Kibela team name",
        "required": true,
        "example": "your-team"
      },
      "KIBELA_TOKEN": {
        "description": "Your Kibela API token",
        "required": true,
        "example": "your-token"
      }
    },
    "tools": [
      {
        "name": "kibela_search_notes",
        "description": "Search Kibela notes with given query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "kibela_get_my_notes",
        "description": "Get your latest notes from Kibela",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Number of notes to fetch (max 50)",
              "default": 15
            }
          }
        }
      },
      {
        "name": "kibela_get_note_content",
        "description": "Get content and comments of a specific note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Note ID"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  "whale-tracker-mcp": {
    "name": "whale-tracker-mcp",
    "display_name": "Whale Tracker",
    "description": "A mcp server for tracking cryptocurrency whale transactions.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kukapay/whale-tracker-mcp"
    },
    "homepage": "https://github.com/kukapay/whale-tracker-mcp",
    "author": {
      "name": "kukapay"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "whale tracker",
      "cryptocurrency",
      "API"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kukapay/whale-tracker-mcp",
          "whale-tracker-mcp"
        ],
        "env": {
          "WHALE_TRACKER_API_KEY": "your_api_key_here"
        }
      }
    },
    "examples": [
      {
        "title": "Fetch Recent Transactions",
        "description": "What are the latest whale transactions on Ethereum with a minimum value of $1,000,000?",
        "prompt": "What are the latest whale transactions on Ethereum with a minimum value of $1,000,000?"
      },
      {
        "title": "Get Transaction Details",
        "description": "Tell me about transaction ID 123456789.",
        "prompt": "Tell me about transaction ID 123456789."
      },
      {
        "title": "Analyze Whale Activity",
        "description": "Analyze recent whale transactions on Bitcoin.",
        "prompt": "Analyze recent whale transactions on Bitcoin."
      }
    ],
    "arguments": {
      "WHALE_TRACKER_API_KEY": {
        "description": "Environment variable to load the Whale Alert API key for the server.",
        "required": true,
        "example": "your_api_key_here"
      }
    }
  },
  "flightradar24": {
    "name": "flightradar24",
    "display_name": "Flightradar24",
    "description": "A Claude Desktop MCP server that helps you track flights in real-time using Flightradar24 data.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sunsetcoder/flightradar24-mcp-server"
    },
    "author": {
      "name": "sunsetcoder"
    },
    "license": "MIT",
    "examples": [
      {
        "title": "Check Flight Status",
        "description": "Ask for the status of a specific flight.",
        "prompt": "What's the status of flight UA123?"
      },
      {
        "title": "Show Current Flights at Airport",
        "description": "Request to see all flights currently at an airport.",
        "prompt": "Show me all flights currently at SFO"
      },
      {
        "title": "Emergency Flights Query",
        "description": "Ask if there are emergency flights in the area.",
        "prompt": "Are there any emergency flights in the area?"
      },
      {
        "title": "International Flights Arrival",
        "description": "Request information on international flights arriving within a timeframe.",
        "prompt": "Show me all international flights arriving at SFO in the next 2 hours"
      }
    ],
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Flightradar24",
      "Flight Tracking"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/sunsetcoder/flightradar24-mcp-server"
        ],
        "env": {
          "FR24_API_KEY": "${FR24_API_KEY}",
          "FR24_API_URL": "${FR24_API_URL}"
        }
      }
    },
    "arguments": {
      "FR24_API_KEY": {
        "description": "Flightradar24 API key required for accessing flight data from the Flightradar24 API.",
        "required": true,
        "example": "your_actual_api_key_here"
      },
      "FR24_API_URL": {
        "description": "The base URL for calling the Flightradar24 API for fetching real-time flight data.",
        "required": false,
        "example": "https://fr24api.flightradar24.com"
      }
    }
  },
  "fantasy-pl": {
    "name": "fantasy-pl",
    "display_name": "Fantasy Premier League",
    "description": "Give your coding agent direct access to up-to date Fantasy Premier League data",
    "repository": {
      "type": "git",
      "url": "https://github.com/rishijatia/fantasy-pl-mcp"
    },
    "homepage": "https://github.com/rishijatia/fantasy-pl-mcp",
    "author": {
      "name": "rishijatia"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "FPL",
      "fantasy",
      "football"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "fpl-mcp"
        ]
      }
    },
    "examples": [
      {
        "title": "Compare Players",
        "description": "This example shows how to compare the statistics of two players.",
        "prompt": "Compare Mohamed Salah and Erling Haaland over the last 5 gameweeks."
      },
      {
        "title": "Find Players",
        "description": "This example demonstrates how to find players of a specific team.",
        "prompt": "Find all Arsenal midfielders."
      },
      {
        "title": "Current Gameweek Status",
        "description": "This example prompts for the current gameweek status.",
        "prompt": "What's the current gameweek status?"
      },
      {
        "title": "Top Forwards",
        "description": "This example retrieves the top 5 forwards by points.",
        "prompt": "Show me the top 5 forwards by points."
      }
    ]
  },
  "claudepost": {
    "name": "claudepost",
    "display_name": "Claude Post Email Management",
    "description": "ClaudePost enables seamless email management for Gmail, offering secure features like email search, reading, and sending.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ZilongXue/claude-post"
    },
    "homepage": "https://github.com/ZilongXue/claude-post",
    "author": {
      "name": "Zilong Xue"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Email Management",
      "Natural Language Processing"
    ],
    "examples": [
      {
        "title": "Search Emails",
        "description": "Search for emails using natural language commands.",
        "prompt": "Show me emails from last week."
      },
      {
        "title": "Read Email Content",
        "description": "Request to read specific email content.",
        "prompt": "Show me the content of email #12345."
      },
      {
        "title": "Send Emails",
        "description": "Send emails using voice commands.",
        "prompt": "I want to send an email to john@example.com."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ZilongXue/claude-post",
          "email-client"
        ]
      }
    },
    "tools": [
      {
        "name": "search-emails",
        "description": "Search emails within a date range and/or with specific keywords",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start_date": {
              "type": "string",
              "description": "Start date in YYYY-MM-DD format (optional)"
            },
            "end_date": {
              "type": "string",
              "description": "End date in YYYY-MM-DD format (optional)"
            },
            "keyword": {
              "type": "string",
              "description": "Keyword to search in email subject and body (optional)"
            },
            "folder": {
              "type": "string",
              "description": "Folder to search in ('inbox' or 'sent', defaults to 'inbox')",
              "enum": [
                "inbox",
                "sent"
              ]
            }
          }
        }
      },
      {
        "name": "get-email-content",
        "description": "Get the full content of a specific email by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email_id": {
              "type": "string",
              "description": "The ID of the email to retrieve"
            }
          },
          "required": [
            "email_id"
          ]
        }
      },
      {
        "name": "count-daily-emails",
        "description": "Count emails received for each day in a date range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start_date": {
              "type": "string",
              "description": "Start date in YYYY-MM-DD format"
            },
            "end_date": {
              "type": "string",
              "description": "End date in YYYY-MM-DD format"
            }
          },
          "required": [
            "start_date",
            "end_date"
          ]
        }
      },
      {
        "name": "send-email",
        "description": "CONFIRMATION STEP: Actually send the email after user confirms the details. Before calling this, first show the email details to the user for confirmation. Required fields: recipients (to), subject, and content. Optional: CC recipients.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of recipient email addresses (confirmed)"
            },
            "subject": {
              "type": "string",
              "description": "Confirmed email subject"
            },
            "content": {
              "type": "string",
              "description": "Confirmed email content"
            },
            "cc": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of CC recipient email addresses (optional, confirmed)"
            }
          },
          "required": [
            "to",
            "subject",
            "content"
          ]
        }
      }
    ]
  },
  "quickchart": {
    "name": "quickchart",
    "display_name": "Quickchart",
    "description": "A Model Context Protocol server for generating charts using QuickChart.io",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/Quickchart-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/Quickchart-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "quickchart",
      "chart generation",
      "data visualization"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@gongrzhe/quickchart-mcp-server"
        ]
      }
    },
    "examples": [
      {
        "title": "Basic bar chart",
        "description": "Generate a bar chart using Chart.js configuration.",
        "prompt": "{\"type\":\"bar\",\"data\":{\"labels\":[\"January\",\"February\",\"March\"],\"datasets\":[{\"label\":\"Sales\",\"data\":[65,59,80],\"backgroundColor\":\"rgb(75,192,192)\"}]},\"options\":{\"title\":{\"display\":true,\"text\":\"Monthly Sales\"}}}"
      }
    ],
    "arguments": {
      "client": {
        "description": "Specifies the client type for which the QuickChart Server is installed. In this case, it's for Claude.",
        "required": true,
        "example": "claude"
      }
    },
    "tools": [
      {
        "name": "generate_chart",
        "description": "Generate a chart using QuickChart",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Chart type (bar, line, pie, doughnut, radar, polarArea, scatter, bubble, radialGauge, speedometer)"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Labels for data points"
            },
            "datasets": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "label": {
                    "type": "string"
                  },
                  "data": {
                    "type": "array"
                  },
                  "backgroundColor": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "borderColor": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "additionalConfig": {
                    "type": "object"
                  }
                },
                "required": [
                  "data"
                ]
              }
            },
            "title": {
              "type": "string"
            },
            "options": {
              "type": "object"
            }
          },
          "required": [
            "type",
            "datasets"
          ]
        }
      },
      {
        "name": "download_chart",
        "description": "Download a chart image to a local file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "config": {
              "type": "object",
              "description": "Chart configuration object"
            },
            "outputPath": {
              "type": "string",
              "description": "Path where the chart image should be saved"
            }
          },
          "required": [
            "config",
            "outputPath"
          ]
        }
      }
    ]
  },
  "mcp-grafana": {
    "display_name": "Grafana MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/grafana/mcp-grafana"
    },
    "license": "Apache License, Version 2.0",
    "homepage": "https://github.com/grafana/mcp-grafana",
    "author": {
      "name": "grafana"
    },
    "tags": [
      "grafana",
      "mcp",
      "model context protocol"
    ],
    "arguments": {
      "GRAFANA_URL": {
        "description": "URL of your Grafana instance",
        "required": true,
        "example": "http://localhost:3000"
      },
      "GRAFANA_API_KEY": {
        "description": "Service account token for Grafana authentication",
        "required": true,
        "example": "<your service account token>"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "go",
        "args": [
          "install",
          "github.com/grafana/mcp-grafana/cmd/mcp-grafana@latest"
        ],
        "env": {
          "GOBIN": "$HOME/go/bin"
        },
        "description": "Install from source using Go",
        "recommended": false
      }
    },
    "examples": [
      {
        "title": "Search for dashboards",
        "description": "Search for dashboards in your Grafana instance",
        "prompt": "Find dashboards related to Kubernetes in my Grafana instance"
      },
      {
        "title": "Query Prometheus metrics",
        "description": "Execute a Prometheus query against a datasource",
        "prompt": "Show me the CPU usage for the last hour from my Prometheus datasource"
      },
      {
        "title": "Check current on-call users",
        "description": "Find out who is currently on-call",
        "prompt": "Who is currently on-call according to Grafana OnCall?"
      }
    ],
    "name": "mcp-grafana",
    "description": "A [Model Context Protocol][mcp] (MCP) server for Grafana.",
    "categories": [
      "Analytics"
    ],
    "is_official": true
  },
  "puppeteer": {
    "name": "puppeteer",
    "display_name": "Puppeteer Browser Automation",
    "description": "Browser automation and web scraping",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/puppeteer",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "puppeteer",
      "automation",
      "javascript",
      "screenshots",
      "web"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-puppeteer"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "--init",
          "-e",
          "DOCKER_CONTAINER=true",
          "mcp/puppeteer"
        ]
      }
    },
    "tools": [
      {
        "name": "puppeteer_navigate",
        "description": "Navigate to a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "puppeteer_screenshot",
        "description": "Take a screenshot of the current page or a specific element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the screenshot"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector for element to screenshot"
            },
            "width": {
              "type": "number",
              "description": "Width in pixels (default: 800)"
            },
            "height": {
              "type": "number",
              "description": "Height in pixels (default: 600)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "puppeteer_click",
        "description": "Click an element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to click"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "puppeteer_fill",
        "description": "Fill out an input field",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for input field"
            },
            "value": {
              "type": "string",
              "description": "Value to fill"
            }
          },
          "required": [
            "selector",
            "value"
          ]
        }
      },
      {
        "name": "puppeteer_select",
        "description": "Select an element on the page with Select tag",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to select"
            },
            "value": {
              "type": "string",
              "description": "Value to select"
            }
          },
          "required": [
            "selector",
            "value"
          ]
        }
      },
      {
        "name": "puppeteer_hover",
        "description": "Hover an element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to hover"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "puppeteer_evaluate",
        "description": "Execute JavaScript in the browser console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "script": {
              "type": "string",
              "description": "JavaScript code to execute"
            }
          },
          "required": [
            "script"
          ]
        }
      }
    ],
    "is_official": true
  },
  "sqlite": {
    "name": "sqlite",
    "display_name": "SQLite",
    "description": "Database interaction and business intelligence capabilities",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/sqlite",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "sqlite",
      "database",
      "business insights"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "-v",
          "mcp-test:/mcp",
          "mcp/sqlite",
          "--db-path",
          "/mcp/test.db"
        ]
      }
    },
    "examples": [
      {
        "title": "Interactive SQL Analysis",
        "description": "Guides users through database operations and insights generation.",
        "prompt": "mcp-demo -topic [business_domain]"
      }
    ],
    "tools": [
      {
        "name": "read_query",
        "description": "Execute a SELECT query on the SQLite database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SELECT SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "write_query",
        "description": "Execute an INSERT, UPDATE, or DELETE query on the SQLite database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "create_table",
        "description": "Create a new table in the SQLite database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "CREATE TABLE SQL statement"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "list_tables",
        "description": "List all tables in the SQLite database",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "describe_table",
        "description": "Get the schema information for a specific table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the table to describe"
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "append_insight",
        "description": "Add a business insight to the memo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "insight": {
              "type": "string",
              "description": "Business insight discovered from data analysis"
            }
          },
          "required": [
            "insight"
          ]
        }
      }
    ],
    "is_official": true
  },
  "dbhub": {
    "name": "dbhub",
    "display_name": "DBHub - Universal Database Gateway",
    "description": "Universal database MCP server connecting to MySQL, PostgreSQL, SQLite, DuckDB and etc.",
    "repository": {
      "type": "git",
      "url": "https://github.com/bytebase/dbhub"
    },
    "homepage": "https://github.com/bytebase/dbhub/",
    "author": {
      "name": "bytebase"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Database Gateway",
      "PostgreSQL",
      "MySQL",
      "SQL Server",
      "SQLite"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "bytebase/dbhub",
          "--transport",
          "stdio",
          "--dsn",
          "${DATABASE_URL}"
        ]
      },
      "npx": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@bytebase/dbhub",
          "--transport",
          "stdio",
          "--dsn",
          "${DATABASE_URL}"
        ]
      }
    },
    "arguments": {
      "DATABASE_URL": {
        "description": "The database connection string which includes the user, password, host, port, and database name.",
        "required": true,
        "example": "postgres://user:password@localhost:5432/dbname?sslmode=disable"
      }
    },
    "tools": [
      {
        "name": "list_connectors",
        "description": "Lists all available database connectors and their sample DSNs. Indicates which connector is active based on the current DSN.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "run_query",
        "description": "Executes a SQL query and returns the results.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "SQL query to execute"
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "obsidian-mcp": {
    "name": "obsidian-mcp",
    "display_name": "Obsidian",
    "description": "(by Steven Stavrakis) An MCP server for Obsidian.md with tools for searching, reading, writing, and organizing notes.",
    "repository": {
      "type": "git",
      "url": "https://github.com/StevenStavrakis/obsidian-mcp"
    },
    "homepage": "https://github.com/StevenStavrakis/obsidian-mcp",
    "author": {
      "name": "StevenStavrakis"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Obsidian",
      "AI",
      "Notes",
      "Productivity"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "obsidian-mcp",
          "${OBSIDIAN_VAULT_PATH}",
          "${OBSIDIAN_VAULT_PATH2}"
        ]
      }
    },
    "arguments": {
      "OBSIDIAN_VAULT_PATH": {
        "description": "Path to your Obsidian vault",
        "required": true
      },
      "OBSIDIAN_VAULT_PATH2": {
        "description": "Path to your second Obsidian vault",
        "required": false
      }
    },
    "examples": [
      {
        "title": "Read a note",
        "description": "Read the contents of a note.",
        "prompt": "read-note('note-id')"
      },
      {
        "title": "Create a new note",
        "description": "Create a new note in the vault.",
        "prompt": "create-note('note-name', 'note-content')"
      }
    ],
    "tools": [
      {
        "name": "create-note",
        "description": "Create a new note in the specified vault with markdown content.\n\nExamples:\n- Root note: { \"vault\": \"vault1\", \"filename\": \"note.md\" }\n- Subfolder note: { \"vault\": \"vault2\", \"filename\": \"note.md\", \"folder\": \"journal/2024\" }\n- INCORRECT: { \"filename\": \"journal/2024/note.md\" } (don't put path in filename)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault to create the note in"
            },
            "filename": {
              "type": "string",
              "minLength": 1,
              "description": "Just the note name without any path separators (e.g. 'my-note.md', NOT 'folder/my-note.md'). Will add .md extension if missing"
            },
            "content": {
              "type": "string",
              "minLength": 1,
              "description": "Content of the note in markdown format"
            },
            "folder": {
              "type": "string",
              "description": "Optional subfolder path relative to vault root (e.g. 'journal/subfolder'). Use this for the path instead of including it in filename"
            }
          },
          "required": [
            "vault",
            "filename",
            "content"
          ]
        }
      },
      {
        "name": "list-available-vaults",
        "description": "Lists all available vaults that can be used with other tools",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "edit-note",
        "description": "Edit an existing note in the specified vault.\n\n    There is a limited and discrete list of supported operations:\n    - append: Appends content to the end of the note\n    - prepend: Prepends content to the beginning of the note\n    - replace: Replaces the entire content of the note\n\nExamples:\n- Root note: { \"vault\": \"vault1\", \"filename\": \"note.md\", \"operation\": \"append\", \"content\": \"new content\" }\n- Subfolder note: { \"vault\": \"vault2\", \"filename\": \"note.md\", \"folder\": \"journal/2024\", \"operation\": \"append\", \"content\": \"new content\" }\n- INCORRECT: { \"filename\": \"journal/2024/note.md\" } (don't put path in filename)",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "search-vault",
        "description": "Search for specific content within vault notes (NOT for listing available vaults - use the list-vaults prompt for that).\n\nThis tool searches through note contents and filenames for specific text or tags:\n- Content search: { \"vault\": \"vault1\", \"query\": \"hello world\", \"searchType\": \"content\" }\n- Filename search: { \"vault\": \"vault2\", \"query\": \"meeting-notes\", \"searchType\": \"filename\" }\n- Search both: { \"vault\": \"vault1\", \"query\": \"project\", \"searchType\": \"both\" }\n- Tag search: { \"vault\": \"vault2\", \"query\": \"tag:status/active\" }\n- Search in subfolder: { \"vault\": \"vault1\", \"query\": \"hello\", \"path\": \"journal/2024\" }\n\nNote: To get a list of available vaults, use the list-vaults prompt instead of this search tool.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault to search in"
            },
            "query": {
              "type": "string",
              "minLength": 1,
              "description": "Search query (required). For text search use the term directly, for tag search use tag: prefix"
            },
            "path": {
              "type": "string",
              "description": "Optional subfolder path within the vault to limit search scope"
            },
            "caseSensitive": {
              "type": "boolean",
              "default": false,
              "description": "Whether to perform case-sensitive search (default: false)"
            },
            "searchType": {
              "type": "string",
              "enum": [
                "content",
                "filename",
                "both"
              ],
              "default": "content",
              "description": "Type of search to perform (default: content)"
            }
          },
          "required": [
            "vault",
            "query"
          ]
        }
      },
      {
        "name": "move-note",
        "description": "Move/rename a note while preserving links",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the note"
            },
            "source": {
              "type": "string",
              "minLength": 1,
              "description": "Source path of the note relative to vault root (e.g., 'folder/note.md')"
            },
            "destination": {
              "type": "string",
              "minLength": 1,
              "description": "Destination path relative to vault root (e.g., 'new-folder/new-name.md')"
            }
          },
          "required": [
            "vault",
            "source",
            "destination"
          ]
        }
      },
      {
        "name": "create-directory",
        "description": "Create a new directory in the specified vault",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault where the directory should be created"
            },
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "Path of the directory to create (relative to vault root)"
            },
            "recursive": {
              "type": "boolean",
              "default": true,
              "description": "Create parent directories if they don't exist"
            }
          },
          "required": [
            "vault",
            "path"
          ]
        }
      },
      {
        "name": "delete-note",
        "description": "Delete a note, moving it to .trash by default or permanently deleting if specified",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the note"
            },
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "Path of the note relative to vault root (e.g., 'folder/note.md')"
            },
            "reason": {
              "type": "string",
              "description": "Optional reason for deletion (stored in trash metadata)"
            },
            "permanent": {
              "type": "boolean",
              "default": false,
              "description": "Whether to permanently delete instead of moving to trash (default: false)"
            }
          },
          "required": [
            "vault",
            "path"
          ]
        }
      },
      {
        "name": "add-tags",
        "description": "Add tags to notes in frontmatter and/or content.\n\nExamples:\n- Add to both locations: { \"files\": [\"note.md\"], \"tags\": [\"status/active\"] }\n- Add to frontmatter only: { \"files\": [\"note.md\"], \"tags\": [\"project/docs\"], \"location\": \"frontmatter\" }\n- Add to start of content: { \"files\": [\"note.md\"], \"tags\": [\"type/meeting\"], \"location\": \"content\", \"position\": \"start\" }",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the notes"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of note filenames to process (must have .md extension)"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of tags to add (e.g., 'status/active', 'project/docs')"
            },
            "location": {
              "type": "string",
              "enum": [
                "frontmatter",
                "content",
                "both"
              ],
              "description": "Where to add tags (default: both)"
            },
            "normalize": {
              "type": "boolean",
              "description": "Whether to normalize tag format (e.g., ProjectActive -> project-active) (default: true)"
            },
            "position": {
              "type": "string",
              "enum": [
                "start",
                "end"
              ],
              "description": "Where to add inline tags in content (default: end)"
            }
          },
          "required": [
            "vault",
            "files",
            "tags"
          ]
        }
      },
      {
        "name": "remove-tags",
        "description": "Remove tags from notes in frontmatter and/or content.\n\nExamples:\n- Simple: { \"files\": [\"note.md\"], \"tags\": [\"project\", \"status\"] }\n- With hierarchy: { \"files\": [\"note.md\"], \"tags\": [\"work/active\", \"priority/high\"] }\n- With options: { \"files\": [\"note.md\"], \"tags\": [\"status\"], \"options\": { \"location\": \"frontmatter\" } }\n- Pattern matching: { \"files\": [\"note.md\"], \"options\": { \"patterns\": [\"status/*\"] } }\n- INCORRECT: { \"tags\": [\"#project\"] } (don't include # symbol)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the notes"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of note filenames to process (must have .md extension)"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of tags to remove (without # symbol). Example: ['project', 'work/active']"
            },
            "options": {
              "type": "object",
              "properties": {
                "location": {
                  "type": "string",
                  "enum": [
                    "frontmatter",
                    "content",
                    "both"
                  ],
                  "default": "both",
                  "description": "Where to remove tags from (default: both)"
                },
                "normalize": {
                  "type": "boolean",
                  "default": true,
                  "description": "Whether to normalize tag format (e.g., ProjectActive -> project-active) (default: true)"
                },
                "preserveChildren": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to preserve child tags when removing parent tags (default: false)"
                },
                "patterns": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "default": [],
                  "description": "Tag patterns to match for removal (supports * wildcard) (default: [])"
                }
              },
              "additionalProperties": false,
              "default": {
                "location": "both",
                "normalize": true,
                "preserveChildren": false,
                "patterns": []
              }
            }
          },
          "required": [
            "vault",
            "files",
            "tags"
          ]
        }
      },
      {
        "name": "rename-tag",
        "description": "Safely renames tags throughout the vault while preserving hierarchies.\n\nExamples:\n- Simple rename: { \"oldTag\": \"project\", \"newTag\": \"projects\" }\n- Rename with hierarchy: { \"oldTag\": \"work/active\", \"newTag\": \"projects/current\" }\n- With options: { \"oldTag\": \"status\", \"newTag\": \"state\", \"normalize\": true, \"createBackup\": true }\n- INCORRECT: { \"oldTag\": \"#project\" } (don't include # symbol)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the tags"
            },
            "oldTag": {
              "type": "string",
              "minLength": 1,
              "description": "The tag to rename (without #). Example: 'project' or 'work/active'"
            },
            "newTag": {
              "type": "string",
              "minLength": 1,
              "description": "The new tag name (without #). Example: 'projects' or 'work/current'"
            },
            "createBackup": {
              "type": "boolean",
              "default": true,
              "description": "Whether to create a backup before making changes (default: true)"
            },
            "normalize": {
              "type": "boolean",
              "default": true,
              "description": "Whether to normalize tag names (e.g., ProjectActive -> project-active) (default: true)"
            },
            "batchSize": {
              "type": "number",
              "minimum": 1,
              "maximum": 100,
              "default": 50,
              "description": "Number of files to process in each batch (1-100) (default: 50)"
            }
          },
          "required": [
            "vault",
            "oldTag",
            "newTag"
          ]
        }
      },
      {
        "name": "read-note",
        "description": "Read the content of an existing note in the vault.\n\nExamples:\n- Root note: { \"vault\": \"vault1\", \"filename\": \"note.md\" }\n- Subfolder note: { \"vault\": \"vault1\", \"filename\": \"note.md\", \"folder\": \"journal/2024\" }\n- INCORRECT: { \"filename\": \"journal/2024/note.md\" } (don't put path in filename)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the note"
            },
            "filename": {
              "type": "string",
              "minLength": 1,
              "description": "Just the note name without any path separators (e.g. 'my-note.md', NOT 'folder/my-note.md')"
            },
            "folder": {
              "type": "string",
              "description": "Optional subfolder path relative to vault root"
            }
          },
          "required": [
            "vault",
            "filename"
          ]
        }
      }
    ]
  },
  "mcp-server-qdrant": {
    "display_name": "Qdrant MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/qdrant/mcp-server-qdrant"
    },
    "homepage": "https://github.com/qdrant/mcp-server-qdrant/",
    "author": {
      "name": "qdrant"
    },
    "license": "Apache License 2.0",
    "tags": [
      "vector-search",
      "qdrant",
      "memory",
      "semantic-search"
    ],
    "arguments": {
      "QDRANT_URL": {
        "description": "URL of the Qdrant server",
        "required": false,
        "example": "http://localhost:6333"
      },
      "QDRANT_API_KEY": {
        "description": "API key for the Qdrant server",
        "required": false,
        "example": "your-api-key"
      },
      "COLLECTION_NAME": {
        "description": "Name of the collection to use",
        "required": true,
        "example": "my-collection"
      },
      "QDRANT_LOCAL_PATH": {
        "description": "Path to the local Qdrant database (alternative to QDRANT_URL)",
        "required": false,
        "example": "/path/to/qdrant/database"
      },
      "EMBEDDING_PROVIDER": {
        "description": "Embedding provider to use (currently only \"fastembed\" is supported)",
        "required": false,
        "example": "fastembed"
      },
      "EMBEDDING_MODEL": {
        "description": "Name of the embedding model to use",
        "required": false,
        "example": "sentence-transformers/all-MiniLM-L6-v2"
      },
      "TOOL_STORE_DESCRIPTION": {
        "description": "Custom description for the store tool",
        "required": false,
        "example": "Store reusable code snippets for later retrieval."
      },
      "TOOL_FIND_DESCRIPTION": {
        "description": "Custom description for the find tool",
        "required": false,
        "example": "Search for relevant code snippets based on natural language descriptions."
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-qdrant"
        ],
        "env": {
          "QDRANT_URL": "http://localhost:6333",
          "QDRANT_API_KEY": "your_api_key",
          "COLLECTION_NAME": "my-collection",
          "EMBEDDING_MODEL": "sentence-transformers/all-MiniLM-L6-v2"
        },
        "description": "Run using uvx without specific installation",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Basic Usage",
        "description": "Store and retrieve information from Qdrant",
        "prompt": "I want to store some information in Qdrant and then retrieve it later. Can you help me with that?"
      },
      {
        "title": "Code Snippet Storage",
        "description": "Store and retrieve code snippets with descriptions",
        "prompt": "I need to store this function that calculates Fibonacci numbers and retrieve it later when I need it."
      }
    ],
    "name": "mcp-server-qdrant",
    "description": "This repository is an example of how to create a MCP server for Qdrant, a vector search engine.",
    "categories": [
      "Databases"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "qdrant-store",
        "description": "Keep the memory for later use, when you are asked to remember something.",
        "inputSchema": {
          "properties": {
            "information": {
              "title": "Information",
              "type": "string"
            },
            "metadata": {
              "additionalProperties": true,
              "default": null,
              "title": "Metadata",
              "type": "object"
            }
          },
          "required": [
            "information"
          ],
          "title": "storeArguments",
          "type": "object"
        }
      },
      {
        "name": "qdrant-find",
        "description": "Look up memories in Qdrant. Use this tool when you need to: \n - Find memories by their content \n - Access memories for further analysis \n - Get some personal information about the user",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "findArguments",
          "type": "object"
        }
      }
    ]
  },
  "scholarly": {
    "name": "scholarly",
    "display_name": "scholarly",
    "description": "A MCP server to search for scholarly and academic articles.",
    "repository": {
      "type": "git",
      "url": "https://github.com/adityak74/mcp-scholarly"
    },
    "homepage": "https://github.com/adityak74/mcp-scholarly",
    "author": {
      "name": "adityak74"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "scholarly",
      "academic"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-scholarly"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/scholarly"
        ]
      }
    },
    "arguments": {
      "keyword": {
        "description": "The keyword to search for articles in arXiv.",
        "required": true,
        "example": "machine learning"
      }
    },
    "tools": [
      {
        "name": "search-arxiv",
        "description": "Search arxiv for articles related to the given keyword.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string"
            }
          },
          "required": [
            "keyword"
          ]
        }
      },
      {
        "name": "search-google-scholar",
        "description": "Search google scholar for articles related to the given keyword.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string"
            }
          },
          "required": [
            "keyword"
          ]
        }
      }
    ]
  },
  "fingertip": {
    "name": "fingertip",
    "display_name": "Fingertip",
    "description": "MCP server for Fingertip.com to search and create new sites.",
    "repository": {
      "type": "git",
      "url": "https://github.com/fingertip-com/fingertip-mcp"
    },
    "homepage": "https://github.com/fingertip-com/fingertip-mcp",
    "author": {
      "name": "fingertip-com"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Fingertip",
      "AI Assistants"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@fingertip/mcp"
        ]
      }
    }
  },
  "mcp-server-esignatures": {
    "display_name": "eSignatures MCP server",
    "repository": {
      "type": "git",
      "url": "https://github.com/esignaturescom/mcp-server-esignatures"
    },
    "homepage": "https://esignatures.com",
    "author": {
      "name": "esignaturescom"
    },
    "license": "MIT",
    "tags": [
      "contracts",
      "templates",
      "collaborators",
      "esignatures"
    ],
    "arguments": {
      "ESIGNATURES_SECRET_TOKEN": {
        "description": "Your eSignatures API secret token",
        "required": true,
        "example": "your-esignatures-api-secret-token"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-esignatures"
        ],
        "env": {
          "ESIGNATURES_SECRET_TOKEN": "your-esignatures-api-secret-token"
        },
        "description": "Published server installation",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Creating a Draft Contract",
        "description": "Generate a draft NDA contract for review",
        "prompt": "Generate a draft NDA contract for a publisher, which I can review and send. Signer: John Doe, ACME Corp, john@acme.com"
      },
      {
        "title": "Sending a Contract",
        "description": "Send an NDA based on a template",
        "prompt": "Send an NDA based on my template to John Doe, ACME Corp, john@acme.com. Set the term to 2 years."
      },
      {
        "title": "Updating templates",
        "description": "Review templates for legal compliance",
        "prompt": "Review my templates for legal compliance, and ask me about updating each one individually"
      },
      {
        "title": "Inviting template collaborators",
        "description": "Invite collaborators to edit templates",
        "prompt": "Invite John Doe to edit the NDA template, email: john@acme.com"
      }
    ],
    "name": "mcp-server-esignatures",
    "description": "MCP server for eSignatures (https://esignatures.com)",
    "categories": [
      "Productivity"
    ],
    "tools": [
      {
        "name": "create_contract",
        "description": "Creates a new contract. The contract can be a draft which the user can customize/send, or the contract can be sent instantly. So called 'signature fields' like Name/Date/signature-line must be left out, they are all handled automatically. Contract owners can customize the content by replacing {{placeholder fields}} inside the content, and the signers can fill in Signer fields when they sign the contract.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "template_id": {
              "type": "string",
              "description": "GUID of a mobile-friendly contract template within eSignatures. The template provides content, title, and labels. Required unless document_elements is provided."
            },
            "title": {
              "type": "string",
              "description": "Sets the contract's title, which appears as the first line in contracts and PDF files, in email subjects, and overrides the template's title."
            },
            "locale": {
              "type": "string",
              "description": "Language for signer page and emails.",
              "enum": [
                "es",
                "hu",
                "da",
                "id",
                "ro",
                "sk",
                "pt",
                "hr",
                "sl",
                "de",
                "it",
                "pl",
                "rs",
                "sv",
                "en",
                "ja",
                "en-GB",
                "fr",
                "cz",
                "vi",
                "no",
                "zh-CN",
                "nl"
              ]
            },
            "metadata": {
              "type": "string",
              "description": "Custom data for contract owners and webhook notifications; e.g. internal IDs."
            },
            "expires_in_hours": {
              "type": "string",
              "description": "Sets contract expiry time in hours; expired contracts can't be signed. Expiry period can be extended per contract in eSignatures."
            },
            "custom_webhook_url": {
              "type": "string",
              "description": "Overrides default webhook HTTPS URL for this contract, defined on the API page in eSignatures. Retries 6 times with 1 hour delays, timeout is 20 seconds."
            },
            "assigned_user_email": {
              "type": "string",
              "description": "Assigns an eSignatures user as contract owner with edit/view/send rights and notification settings. Contract owners get email notifications for signings and full contract completion if enabled on their Profile."
            },
            "labels": {
              "type": "array",
              "description": "Assigns labels to the contract, overriding template labels. Labels assist in organizing contracts without using folders.",
              "items": {
                "type": "string"
              }
            },
            "test": {
              "type": "string",
              "description": "Marks contract as 'demo' with no fees; adds DEMO stamp, disables reminders.",
              "enum": [
                "yes",
                "no"
              ]
            },
            "save_as_draft": {
              "type": "string",
              "description": "Saves contract as draft for further editing; draft can be edited and sent via UI. URL: https://esignatures.com/contracts/contract_id/edit, where contract_id is in the API response.",
              "enum": [
                "yes",
                "no"
              ]
            },
            "signers": {
              "type": "array",
              "description": "List of individuals required to sign the contract. Only include specific persons with their contact details; do not add generic signers.",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Signer's name."
                  },
                  "email": {
                    "type": "string",
                    "description": "Signer's email address."
                  },
                  "mobile": {
                    "type": "string",
                    "description": "Signer's mobile number (E.123 format)."
                  },
                  "company_name": {
                    "type": "string",
                    "description": "Signer's company name."
                  },
                  "signing_order": {
                    "type": "string",
                    "description": "Order in which signers receive the contract; same number signers are notified together. By default, sequential."
                  },
                  "auto_sign": {
                    "type": "string",
                    "description": "Automatically signs document if 'yes'; only for your signature not for other signers."
                  },
                  "signature_request_delivery_methods": {
                    "type": "array",
                    "description": "Methods for delivering signature request. Empty list skips sending. Default calculated. Requires contact details.",
                    "items": {
                      "type": "string",
                      "enum": [
                        "email",
                        "sms"
                      ]
                    }
                  },
                  "signed_document_delivery_method": {
                    "type": "string",
                    "description": "Method to deliver signed document (email, sms). Usually required by law. Default calculated.",
                    "enum": [
                      "email",
                      "sms"
                    ]
                  },
                  "multi_factor_authentications": {
                    "type": "array",
                    "description": "Authentication methods for signers (sms_verification_code, email_verification_code). Requires the relevant contact details.",
                    "items": {
                      "type": "string",
                      "enum": [
                        "sms_verification_code",
                        "email_verification_code"
                      ]
                    }
                  },
                  "redirect_url": {
                    "type": "string",
                    "description": "URL for signer redirection post-signing."
                  }
                },
                "required": [
                  "name"
                ]
              }
            },
            "placeholder_fields": {
              "type": "array",
              "description": "Replaces text placeholders in templates when creating a contract. Example: {{interest_rate}}. Do not add placeholder values when creating a draft.",
              "items": {
                "type": "object",
                "properties": {
                  "api_key": {
                    "type": "string",
                    "description": "The template's placeholder key, e.g., for {{interest_rate}}, api_key is 'interest_rate'."
                  },
                  "value": {
                    "type": "string",
                    "description": "Text that replaces the placeholder."
                  },
                  "document_elements": {
                    "type": "array",
                    "description": "Allows insertion of custom elements like headers, text, images into placeholders.",
                    "items": {
                      "type": "object",
                      "oneOf": [
                        {
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "Header lines. Do not add the title of the template/contract as the first line; it will already be included at the beginning of the contracts.",
                              "enum": [
                                "text_header_one",
                                "text_header_two",
                                "text_header_three"
                              ]
                            },
                            "text": {
                              "type": "string"
                            },
                            "text_alignment": {
                              "type": "string",
                              "enum": [
                                "center",
                                "right",
                                "justified"
                              ],
                              "default": "left"
                            }
                          },
                          "required": [
                            "type",
                            "text"
                          ]
                        },
                        {
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "For paragraphs and non-list text content.",
                              "enum": [
                                "text_normal"
                              ]
                            },
                            "text": {
                              "type": "string"
                            },
                            "text_alignment": {
                              "type": "string",
                              "enum": [
                                "center",
                                "right",
                                "justified"
                              ],
                              "default": "left"
                            },
                            "text_styles": {
                              "type": "array",
                              "description": "An array defining text style ranges within the element. For Placeholder fields, ensure the moustache brackets around the placeholder also match the style. Example for '{{rate}} percent': [{offset:0, length:8, style:'bold'}]",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "offset": {
                                    "type": "integer",
                                    "description": "Start index of styled text (0-based)"
                                  },
                                  "length": {
                                    "type": "integer",
                                    "description": "Number of characters in the styled range"
                                  },
                                  "style": {
                                    "type": "string",
                                    "description": "Style to apply",
                                    "enum": [
                                      "bold",
                                      "italic",
                                      "underline"
                                    ]
                                  }
                                }
                              }
                            },
                            "depth": {
                              "type": "integer",
                              "default": 0,
                              "description": "Indentation level of text, defaults to 0."
                            }
                          },
                          "required": [
                            "type",
                            "text"
                          ]
                        },
                        {
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "For list items. Use ordered_list_item for sequential/numbered lists, unordered_list_item for bullet points. Lists continue at the same indentation level until interrupted by another element type which is not a list or indented paragraph.",
                              "enum": [
                                "ordered_list_item",
                                "unordered_list_item"
                              ]
                            },
                            "text": {
                              "type": "string"
                            },
                            "depth": {
                              "type": "integer",
                              "default": 0,
                              "description": "Depth of list nesting, default 0. For ordered lists, numbering persists at the same or deeper indentation levels; paragraphs don't interrupt numbering."
                            }
                          },
                          "required": [
                            "type",
                            "text"
                          ]
                        },
                        {
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "Signer fields allow input or selection by signers. Do not add any signer fields for collecting signatures, names, dates, company names or titles or anything similar at the end of documents. Radio buttons group automatically, do not insert any other elements (like text) between radio buttons that should be grouped together. Instead, place descriptive text before or after the complete radio button group.",
                              "enum": [
                                "signer_field_text",
                                "signer_field_text_area",
                                "signer_field_date",
                                "signer_field_dropdown",
                                "signer_field_checkbox",
                                "signer_field_radiobutton",
                                "signer_field_file_upload"
                              ]
                            },
                            "text": {
                              "type": "string"
                            },
                            "signer_field_assigned_to": {
                              "type": "string",
                              "description": "Specifies which signer(s) can interact with this field based on signing order. 'first_signer' means only the first signer to open and sign can fill the field; others with the same or later order cannot. The same rule applies for 'second_signer' and 'last_signer'. 'every_signer' shows the field to each signer, with separate values in the final PDF. Examples: 'Primary contact for property issues' (first signer) and 'My mobile number' (every signer).",
                              "enum": [
                                "first_signer",
                                "second_signer",
                                "last_signer",
                                "every_signer"
                              ]
                            },
                            "signer_field_required": {
                              "type": "string",
                              "enum": [
                                "yes",
                                "no"
                              ]
                            },
                            "signer_field_dropdown_options": {
                              "type": "string",
                              "description": "Options for dropdown fields, separated by newline \n characters"
                            },
                            "signer_field_id": {
                              "type": "string",
                              "description": "Unique ID for the Signer field, used in Webhook notifications for value inclusion. If not specified, values are excluded from Webhook notifications and CSV exports."
                            }
                          },
                          "required": [
                            "type",
                            "text",
                            "signer_field_assigned_to"
                          ]
                        },
                        {
                          "properties": {
                            "type": {
                              "type": "string",
                              "enum": [
                                "image"
                              ]
                            },
                            "image_base64": {
                              "type": "string",
                              "description": "The base64-encoded png or jpg image (max 0.5MB)."
                            },
                            "image_alignment": {
                              "type": "string",
                              "enum": [
                                "center",
                                "right"
                              ],
                              "default": "left"
                            },
                            "image_height_rem": {
                              "type": "number",
                              "minimum": 2,
                              "maximum": 38
                            }
                          },
                          "required": [
                            "type",
                            "image_base64"
                          ]
                        },
                        {
                          "properties": {
                            "type": {
                              "type": "string",
                              "enum": [
                                "table"
                              ]
                            },
                            "table_cells": {
                              "type": "array",
                              "items": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "text": {
                                      "type": "string"
                                    },
                                    "styles": {
                                      "type": "array",
                                      "items": {
                                        "type": "string",
                                        "enum": [
                                          "bold",
                                          "italic"
                                        ]
                                      }
                                    },
                                    "alignment": {
                                      "type": "string",
                                      "enum": [
                                        "center",
                                        "right"
                                      ],
                                      "default": "left"
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "required": [
                            "type",
                            "table_cells"
                          ]
                        },
                        {
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "Nested template inclusion. Maximum depth: 1 level",
                              "enum": [
                                "template"
                              ]
                            },
                            "template_id": {
                              "type": "string",
                              "description": "ID of the template to insert; Placeholder fields apply within this template too."
                            }
                          },
                          "required": [
                            "type",
                            "template_id"
                          ]
                        }
                      ]
                    }
                  }
                }
              }
            },
            "document_elements": {
              "type": "array",
              "description": "Customize document content with headers, text, images, etc. Owners can manually replace {{placeholder fields}} in the eSignatures editor, and signers can fill in Signer fields. Use placeholders for signer names unless names are already provided. The contract title is automatically added as the first line.",
              "items": {
                "type": "object",
                "oneOf": [
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Header lines. Do not add the title of the template/contract as the first line; it will already be included at the beginning of the contracts.",
                        "enum": [
                          "text_header_one",
                          "text_header_two",
                          "text_header_three"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "text_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right",
                          "justified"
                        ],
                        "default": "left"
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "For paragraphs and non-list text content.",
                        "enum": [
                          "text_normal"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "text_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right",
                          "justified"
                        ],
                        "default": "left"
                      },
                      "text_styles": {
                        "type": "array",
                        "description": "An array defining text style ranges within the element. For Placeholder fields, ensure the moustache brackets around the placeholder also match the style. Example for '{{rate}} percent': [{offset:0, length:8, style:'bold'}]",
                        "items": {
                          "type": "object",
                          "properties": {
                            "offset": {
                              "type": "integer",
                              "description": "Start index of styled text (0-based)"
                            },
                            "length": {
                              "type": "integer",
                              "description": "Number of characters in the styled range"
                            },
                            "style": {
                              "type": "string",
                              "description": "Style to apply",
                              "enum": [
                                "bold",
                                "italic",
                                "underline"
                              ]
                            }
                          }
                        }
                      },
                      "depth": {
                        "type": "integer",
                        "default": 0,
                        "description": "Indentation level of text, defaults to 0."
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "For list items. Use ordered_list_item for sequential/numbered lists, unordered_list_item for bullet points. Lists continue at the same indentation level until interrupted by another element type which is not a list or indented paragraph.",
                        "enum": [
                          "ordered_list_item",
                          "unordered_list_item"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "depth": {
                        "type": "integer",
                        "default": 0,
                        "description": "Depth of list nesting, default 0. For ordered lists, numbering persists at the same or deeper indentation levels; paragraphs don't interrupt numbering."
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Signer fields allow input or selection by signers. Do not add any signer fields for collecting signatures, names, dates, company names or titles or anything similar at the end of documents. Radio buttons group automatically, do not insert any other elements (like text) between radio buttons that should be grouped together. Instead, place descriptive text before or after the complete radio button group.",
                        "enum": [
                          "signer_field_text",
                          "signer_field_text_area",
                          "signer_field_date",
                          "signer_field_dropdown",
                          "signer_field_checkbox",
                          "signer_field_radiobutton",
                          "signer_field_file_upload"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "signer_field_assigned_to": {
                        "type": "string",
                        "description": "Specifies which signer(s) can interact with this field based on signing order. 'first_signer' means only the first signer to open and sign can fill the field; others with the same or later order cannot. The same rule applies for 'second_signer' and 'last_signer'. 'every_signer' shows the field to each signer, with separate values in the final PDF. Examples: 'Primary contact for property issues' (first signer) and 'My mobile number' (every signer).",
                        "enum": [
                          "first_signer",
                          "second_signer",
                          "last_signer",
                          "every_signer"
                        ]
                      },
                      "signer_field_required": {
                        "type": "string",
                        "enum": [
                          "yes",
                          "no"
                        ]
                      },
                      "signer_field_dropdown_options": {
                        "type": "string",
                        "description": "Options for dropdown fields, separated by newline \n characters"
                      },
                      "signer_field_id": {
                        "type": "string",
                        "description": "Unique ID for the Signer field, used in Webhook notifications for value inclusion. If not specified, values are excluded from Webhook notifications and CSV exports."
                      }
                    },
                    "required": [
                      "type",
                      "text",
                      "signer_field_assigned_to"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "image"
                        ]
                      },
                      "image_base64": {
                        "type": "string",
                        "description": "The base64-encoded png or jpg image (max 0.5MB)."
                      },
                      "image_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right"
                        ],
                        "default": "left"
                      },
                      "image_height_rem": {
                        "type": "number",
                        "minimum": 2,
                        "maximum": 38
                      }
                    },
                    "required": [
                      "type",
                      "image_base64"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "table"
                        ]
                      },
                      "table_cells": {
                        "type": "array",
                        "items": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "text": {
                                "type": "string"
                              },
                              "styles": {
                                "type": "array",
                                "items": {
                                  "type": "string",
                                  "enum": [
                                    "bold",
                                    "italic"
                                  ]
                                }
                              },
                              "alignment": {
                                "type": "string",
                                "enum": [
                                  "center",
                                  "right"
                                ],
                                "default": "left"
                              }
                            }
                          }
                        }
                      }
                    },
                    "required": [
                      "type",
                      "table_cells"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Nested template inclusion. Maximum depth: 1 level",
                        "enum": [
                          "template"
                        ]
                      },
                      "template_id": {
                        "type": "string",
                        "description": "ID of the template to insert; Placeholder fields apply within this template too."
                      }
                    },
                    "required": [
                      "type",
                      "template_id"
                    ]
                  }
                ]
              }
            },
            "signer_fields": {
              "type": "array",
              "description": "Set default values for Signer fields.",
              "items": {
                "type": "object",
                "properties": {
                  "signer_field_id": {
                    "type": "string",
                    "description": "Signer field ID of the Signer field, defined in the template or document_elements."
                  },
                  "default_value": {
                    "type": "string",
                    "description": "Default input value (use '1' for checkboxes and radio buttons, 'YYYY-mm-dd' for dates)."
                  },
                  "select_position": {
                    "type": "string",
                    "description": "Pre-selected option index for dropdowns (0-based)."
                  }
                },
                "required": [
                  "signer_field_id"
                ]
              }
            },
            "emails": {
              "type": "object",
              "description": "Customize email communications for signing and final documents.",
              "properties": {
                "signature_request_subject": {
                  "type": "string",
                  "description": "Email subject for signature request emails."
                },
                "signature_request_text": {
                  "type": "string",
                  "description": "Email body of signature request email; use __FULL_NAME__ for personalization. First line is bold and larger."
                },
                "final_contract_subject": {
                  "type": "string",
                  "description": "Email subject for the final contract email."
                },
                "final_contract_text": {
                  "type": "string",
                  "description": "Body of final contract email; use __FULL_NAME__ for personalization. First line is bold and larger."
                },
                "cc_email_addresses": {
                  "type": "array",
                  "description": "Email addresses CC'd when sending the signed contract PDF.",
                  "items": {
                    "type": "string"
                  }
                },
                "reply_to": {
                  "type": "string",
                  "description": "Custom reply-to email address (defaults to support email if not set)."
                }
              }
            },
            "custom_branding": {
              "type": "object",
              "description": "Customize branding for documents and emails.",
              "properties": {
                "company_name": {
                  "type": "string",
                  "description": "Custom company name shown as the sender."
                },
                "logo_url": {
                  "type": "string",
                  "description": "URL for custom logo (PNG, recommended 400px size)."
                }
              }
            },
            "contract_source": {
              "type": "string",
              "enum": [
                "mcpserver"
              ],
              "description": "Identifies the originating system. Currently only mcpserver supported for MCP requests."
            },
            "mcp_query": {
              "type": "string",
              "description": "The original text query that the user typed which triggered this MCP command execution. Used for logging and debugging purposes."
            }
          },
          "required": [
            "contract_source",
            "mcp_query"
          ]
        }
      },
      {
        "name": "query_contract",
        "description": "Responds with the contract details, contract_id, status, final PDF url if present, title, labels, metadata, expiry time if present, and signer details with all signer events (signer events are included only for recent contracts, with rate limiting).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_id": {
              "type": "string",
              "description": "GUID of the contract (draft contracts can't be queried, only sent contracts)."
            }
          },
          "required": [
            "contract_id"
          ]
        }
      },
      {
        "name": "withdraw_contract",
        "description": "Withdraws a sent contract.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_id": {
              "type": "string",
              "description": "GUID of the contract to be withdrawn."
            }
          },
          "required": [
            "contract_id"
          ]
        }
      },
      {
        "name": "delete_contract",
        "description": "Deletes a contract. The contract can only be deleted if it's a test contract or a draft contract.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_id": {
              "type": "string",
              "description": "GUID of the contract to be deleted."
            }
          },
          "required": [
            "contract_id"
          ]
        }
      },
      {
        "name": "list_recent_contracts",
        "description": "Returns the the details of the latest 100 contracts.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "create_template",
        "description": "Creates a reusable contract template for contracts to be based on.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "Title for the new template; used for contracts based on this template."
            },
            "labels": {
              "type": "array",
              "description": "Assign labels for organizing templates and contracts; labels are inherited by contracts.",
              "items": {
                "type": "string"
              }
            },
            "document_elements": {
              "type": "array",
              "description": "Customize template content with headers, text, images. Owners can manually replace {{placeholder fields}} in the eSignatures contract editor, and signers can fill in Signer fields when signing the document. Use placeholders for signer names if needed, instead of Signer fields. Contract title auto-inserts as the first line.",
              "items": {
                "type": "object",
                "oneOf": [
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Header lines. Do not add the title of the template/contract as the first line; it will already be included at the beginning of the contracts.",
                        "enum": [
                          "text_header_one",
                          "text_header_two",
                          "text_header_three"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "text_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right",
                          "justified"
                        ],
                        "default": "left"
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "For paragraphs and non-list text content.",
                        "enum": [
                          "text_normal"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "text_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right",
                          "justified"
                        ],
                        "default": "left"
                      },
                      "text_styles": {
                        "type": "array",
                        "description": "An array defining text style ranges within the element. For Placeholder fields, ensure the moustache brackets around the placeholder also match the style. Example for '{{rate}} percent': [{offset:0, length:8, style:'bold'}]",
                        "items": {
                          "type": "object",
                          "properties": {
                            "offset": {
                              "type": "integer",
                              "description": "Start index of styled text (0-based)"
                            },
                            "length": {
                              "type": "integer",
                              "description": "Number of characters in the styled range"
                            },
                            "style": {
                              "type": "string",
                              "description": "Style to apply",
                              "enum": [
                                "bold",
                                "italic",
                                "underline"
                              ]
                            }
                          }
                        }
                      },
                      "depth": {
                        "type": "integer",
                        "default": 0,
                        "description": "Indentation level of text, defaults to 0."
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "For list items. Use ordered_list_item for sequential/numbered lists, unordered_list_item for bullet points. Lists continue at the same indentation level until interrupted by another element type which is not a list or indented paragraph.",
                        "enum": [
                          "ordered_list_item",
                          "unordered_list_item"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "depth": {
                        "type": "integer",
                        "default": 0,
                        "description": "Depth of list nesting, default 0. For ordered lists, numbering persists at the same or deeper indentation levels; paragraphs don't interrupt numbering."
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Signer fields allow input or selection by signers. Do not add any signer fields for collecting signatures, names, dates, company names or titles or anything similar at the end of documents. Radio buttons group automatically, do not insert any other elements (like text) between radio buttons that should be grouped together. Instead, place descriptive text before or after the complete radio button group.",
                        "enum": [
                          "signer_field_text",
                          "signer_field_text_area",
                          "signer_field_date",
                          "signer_field_dropdown",
                          "signer_field_checkbox",
                          "signer_field_radiobutton",
                          "signer_field_file_upload"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "signer_field_assigned_to": {
                        "type": "string",
                        "description": "Specifies which signer(s) can interact with this field based on signing order. 'first_signer' means only the first signer to open and sign can fill the field; others with the same or later order cannot. The same rule applies for 'second_signer' and 'last_signer'. 'every_signer' shows the field to each signer, with separate values in the final PDF. Examples: 'Primary contact for property issues' (first signer) and 'My mobile number' (every signer).",
                        "enum": [
                          "first_signer",
                          "second_signer",
                          "last_signer",
                          "every_signer"
                        ]
                      },
                      "signer_field_required": {
                        "type": "string",
                        "enum": [
                          "yes",
                          "no"
                        ]
                      },
                      "signer_field_dropdown_options": {
                        "type": "string",
                        "description": "Options for dropdown fields, separated by newline \n characters"
                      },
                      "signer_field_id": {
                        "type": "string",
                        "description": "Unique ID for the Signer field, used in Webhook notifications for value inclusion. If not specified, values are excluded from Webhook notifications and CSV exports."
                      }
                    },
                    "required": [
                      "type",
                      "text",
                      "signer_field_assigned_to"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "image"
                        ]
                      },
                      "image_base64": {
                        "type": "string",
                        "description": "The base64-encoded png or jpg image (max 0.5MB)."
                      },
                      "image_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right"
                        ],
                        "default": "left"
                      },
                      "image_height_rem": {
                        "type": "number",
                        "minimum": 2,
                        "maximum": 38
                      }
                    },
                    "required": [
                      "type",
                      "image_base64"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "table"
                        ]
                      },
                      "table_cells": {
                        "type": "array",
                        "items": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "text": {
                                "type": "string"
                              },
                              "styles": {
                                "type": "array",
                                "items": {
                                  "type": "string",
                                  "enum": [
                                    "bold",
                                    "italic"
                                  ]
                                }
                              },
                              "alignment": {
                                "type": "string",
                                "enum": [
                                  "center",
                                  "right"
                                ],
                                "default": "left"
                              }
                            }
                          }
                        }
                      }
                    },
                    "required": [
                      "type",
                      "table_cells"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Nested template inclusion. Maximum depth: 1 level",
                        "enum": [
                          "template"
                        ]
                      },
                      "template_id": {
                        "type": "string",
                        "description": "ID of the template to insert; Placeholder fields apply within this template too."
                      }
                    },
                    "required": [
                      "type",
                      "template_id"
                    ]
                  }
                ]
              }
            }
          },
          "required": [
            "title",
            "document_elements"
          ]
        }
      },
      {
        "name": "update_template",
        "description": "Updates the title, labels or the content of a contract template.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "The new title of the template."
            },
            "labels": {
              "type": "array",
              "description": "List of labels to be assigned to the template.",
              "items": {
                "type": "string"
              }
            },
            "document_elements": {
              "type": "array",
              "description": "The content of the template like headers, text, and images for the document.",
              "items": {
                "type": "object",
                "oneOf": [
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Header lines. Do not add the title of the template/contract as the first line; it will already be included at the beginning of the contracts.",
                        "enum": [
                          "text_header_one",
                          "text_header_two",
                          "text_header_three"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "text_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right",
                          "justified"
                        ],
                        "default": "left"
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "For paragraphs and non-list text content.",
                        "enum": [
                          "text_normal"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "text_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right",
                          "justified"
                        ],
                        "default": "left"
                      },
                      "text_styles": {
                        "type": "array",
                        "description": "An array defining text style ranges within the element. For Placeholder fields, ensure the moustache brackets around the placeholder also match the style. Example for '{{rate}} percent': [{offset:0, length:8, style:'bold'}]",
                        "items": {
                          "type": "object",
                          "properties": {
                            "offset": {
                              "type": "integer",
                              "description": "Start index of styled text (0-based)"
                            },
                            "length": {
                              "type": "integer",
                              "description": "Number of characters in the styled range"
                            },
                            "style": {
                              "type": "string",
                              "description": "Style to apply",
                              "enum": [
                                "bold",
                                "italic",
                                "underline"
                              ]
                            }
                          }
                        }
                      },
                      "depth": {
                        "type": "integer",
                        "default": 0,
                        "description": "Indentation level of text, defaults to 0."
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "For list items. Use ordered_list_item for sequential/numbered lists, unordered_list_item for bullet points. Lists continue at the same indentation level until interrupted by another element type which is not a list or indented paragraph.",
                        "enum": [
                          "ordered_list_item",
                          "unordered_list_item"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "depth": {
                        "type": "integer",
                        "default": 0,
                        "description": "Depth of list nesting, default 0. For ordered lists, numbering persists at the same or deeper indentation levels; paragraphs don't interrupt numbering."
                      }
                    },
                    "required": [
                      "type",
                      "text"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Signer fields allow input or selection by signers. Do not add any signer fields for collecting signatures, names, dates, company names or titles or anything similar at the end of documents. Radio buttons group automatically, do not insert any other elements (like text) between radio buttons that should be grouped together. Instead, place descriptive text before or after the complete radio button group.",
                        "enum": [
                          "signer_field_text",
                          "signer_field_text_area",
                          "signer_field_date",
                          "signer_field_dropdown",
                          "signer_field_checkbox",
                          "signer_field_radiobutton",
                          "signer_field_file_upload"
                        ]
                      },
                      "text": {
                        "type": "string"
                      },
                      "signer_field_assigned_to": {
                        "type": "string",
                        "description": "Specifies which signer(s) can interact with this field based on signing order. 'first_signer' means only the first signer to open and sign can fill the field; others with the same or later order cannot. The same rule applies for 'second_signer' and 'last_signer'. 'every_signer' shows the field to each signer, with separate values in the final PDF. Examples: 'Primary contact for property issues' (first signer) and 'My mobile number' (every signer).",
                        "enum": [
                          "first_signer",
                          "second_signer",
                          "last_signer",
                          "every_signer"
                        ]
                      },
                      "signer_field_required": {
                        "type": "string",
                        "enum": [
                          "yes",
                          "no"
                        ]
                      },
                      "signer_field_dropdown_options": {
                        "type": "string",
                        "description": "Options for dropdown fields, separated by newline \n characters"
                      },
                      "signer_field_id": {
                        "type": "string",
                        "description": "Unique ID for the Signer field, used in Webhook notifications for value inclusion. If not specified, values are excluded from Webhook notifications and CSV exports."
                      }
                    },
                    "required": [
                      "type",
                      "text",
                      "signer_field_assigned_to"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "image"
                        ]
                      },
                      "image_base64": {
                        "type": "string",
                        "description": "The base64-encoded png or jpg image (max 0.5MB)."
                      },
                      "image_alignment": {
                        "type": "string",
                        "enum": [
                          "center",
                          "right"
                        ],
                        "default": "left"
                      },
                      "image_height_rem": {
                        "type": "number",
                        "minimum": 2,
                        "maximum": 38
                      }
                    },
                    "required": [
                      "type",
                      "image_base64"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "table"
                        ]
                      },
                      "table_cells": {
                        "type": "array",
                        "items": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "text": {
                                "type": "string"
                              },
                              "styles": {
                                "type": "array",
                                "items": {
                                  "type": "string",
                                  "enum": [
                                    "bold",
                                    "italic"
                                  ]
                                }
                              },
                              "alignment": {
                                "type": "string",
                                "enum": [
                                  "center",
                                  "right"
                                ],
                                "default": "left"
                              }
                            }
                          }
                        }
                      }
                    },
                    "required": [
                      "type",
                      "table_cells"
                    ]
                  },
                  {
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Nested template inclusion. Maximum depth: 1 level",
                        "enum": [
                          "template"
                        ]
                      },
                      "template_id": {
                        "type": "string",
                        "description": "ID of the template to insert; Placeholder fields apply within this template too."
                      }
                    },
                    "required": [
                      "type",
                      "template_id"
                    ]
                  }
                ]
              }
            }
          }
        }
      },
      {
        "name": "query_template",
        "description": "Responds with the template details, template_id, title, labels, created_at, list of the Placeholder fields in the template, list of Signer fields int he template, and the full content inside document_elements",
        "inputSchema": {
          "type": "object",
          "properties": {
            "template_id": {
              "type": "string",
              "description": "GUID of the template."
            }
          },
          "required": [
            "template_id"
          ]
        }
      },
      {
        "name": "delete_template",
        "description": "Deletes a contract template.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "template_id": {
              "type": "string",
              "description": "GUID of the template to be deleted."
            }
          },
          "required": [
            "template_id"
          ]
        }
      },
      {
        "name": "list_templates",
        "description": "Lists the templates.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "keboola-mcp-server": {
    "display_name": "Keboola MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/keboola/keboola-mcp-server"
    },
    "license": "MIT",
    "homepage": "https://github.com/keboola/keboola-mcp-server",
    "author": {
      "name": "keboola"
    },
    "tags": [
      "keboola",
      "data",
      "storage",
      "snowflake"
    ],
    "arguments": {
      "api-url": {
        "description": "Keboola Connection API URL",
        "required": true,
        "example": "https://connection.YOUR_REGION.keboola.com"
      },
      "KBC_STORAGE_TOKEN": {
        "description": "Keboola Storage API token",
        "required": true,
        "example": "your-keboola-storage-token"
      },
      "KBC_WORKSPACE_USER": {
        "description": "Snowflake workspace username",
        "required": true,
        "example": "your-workspace-user"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/keboola/keboola-mcp-server.git",
          "keboola-mcp",
          "--api-url",
          "${api-url}"
        ],
        "env": {
          "KBC_STORAGE_TOKEN": "your-keboola-storage-token",
          "KBC_WORKSPACE_USER": "your-workspace-user"
        },
        "description": "Run the server using Python",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "List buckets and tables",
        "description": "Get a list of all buckets and tables in your Keboola project",
        "prompt": "List all the buckets and tables in my Keboola project."
      },
      {
        "title": "Preview table data",
        "description": "Preview data from a specific table",
        "prompt": "Show me a preview of the data in table [table_id]."
      }
    ],
    "name": "keboola-mcp-server",
    "description": "<a href=\"https://glama.ai/mcp/servers/72mwt1x862\"><img width=\"380\" height=\"200\" src=\"https://glama.ai/mcp/servers/72mwt1x862/badge\" alt=\"Keboola Explorer Server MCP server\" /></a>",
    "categories": [
      "Analytics"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "list_bucket_info",
        "description": "List information about all buckets in the project.",
        "inputSchema": {
          "properties": {},
          "title": "list_bucket_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "get_bucket_metadata",
        "description": "Get detailed information about a specific bucket.",
        "inputSchema": {
          "properties": {
            "bucket_id": {
              "description": "Unique ID of the bucket.",
              "title": "Bucket Id",
              "type": "string"
            }
          },
          "required": [
            "bucket_id"
          ],
          "title": "get_bucket_metadataArguments",
          "type": "object"
        }
      },
      {
        "name": "list_bucket_tables",
        "description": "List all tables in a specific bucket with their basic information.",
        "inputSchema": {
          "properties": {
            "bucket_id": {
              "description": "Unique ID of the bucket.",
              "title": "Bucket Id",
              "type": "string"
            }
          },
          "required": [
            "bucket_id"
          ],
          "title": "list_bucket_tablesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_table_metadata",
        "description": "Get detailed information about a specific table including its DB identifier and column information.",
        "inputSchema": {
          "properties": {
            "table_id": {
              "description": "Unique ID of the table.",
              "title": "Table Id",
              "type": "string"
            }
          },
          "required": [
            "table_id"
          ],
          "title": "get_table_metadataArguments",
          "type": "object"
        }
      },
      {
        "name": "query_table",
        "description": "\n    Executes an SQL SELECT query to get the data from the underlying snowflake database.\n    * When constructing the SQL SELECT query make sure to use the fully qualified table names\n      that include the database name, schema name and the table name.\n    * The fully qualified table name can be found in the table information, use a tool to get the information\n      about tables. The fully qualified table name can be found in the response for that tool.\n    * Snowflake is case-sensitive so always wrap the column names in double quotes.\n\n    Examples:\n    * SQL queries must include the fully qualified table names including the database name, e.g.:\n      SELECT * FROM \"db_name\".\"db_schema_name\".\"table_name\";\n    ",
        "inputSchema": {
          "properties": {
            "sql_query": {
              "description": "SQL SELECT query to run.",
              "title": "Sql Query",
              "type": "string"
            }
          },
          "required": [
            "sql_query"
          ],
          "title": "query_tableArguments",
          "type": "object"
        }
      },
      {
        "name": "list_components",
        "description": "List all available components and their configurations.",
        "inputSchema": {
          "properties": {},
          "title": "list_componentsArguments",
          "type": "object"
        }
      },
      {
        "name": "list_component_configs",
        "description": "List all configurations for a specific component.",
        "inputSchema": {
          "properties": {
            "component_id": {
              "title": "Component Id",
              "type": "string"
            }
          },
          "required": [
            "component_id"
          ],
          "title": "list_component_configsArguments",
          "type": "object"
        }
      }
    ]
  },
  "anki": {
    "name": "anki",
    "display_name": "Anki",
    "description": "An MCP server for interacting with your [Anki](https://apps.ankiweb.net/) decks and cards.",
    "repository": {
      "type": "git",
      "url": "https://github.com/scorzeth/anki-mcp-server"
    },
    "homepage": "https://github.com/scorzeth/anki-mcp-server",
    "author": {
      "name": "scorzeth"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Anki",
      "Cards",
      "Review"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/scorzeth/anki-mcp-server"
        ],
        "description": "Run with npx (requires npm install)"
      }
    },
    "tools": [
      {
        "name": "update_cards",
        "description": "After the user answers cards you've quizzed them on, use this tool to mark them answered and update their ease",
        "inputSchema": {
          "type": "object",
          "properties": {
            "answers": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "cardId": {
                    "type": "number",
                    "description": "Id of the card to answer"
                  },
                  "ease": {
                    "type": "number",
                    "description": "Ease of the card between 1 (Again) and 4 (Easy)"
                  }
                }
              }
            }
          }
        }
      },
      {
        "name": "add_card",
        "description": "Create a new flashcard in Anki for the user. Must use HTML formatting only. IMPORTANT FORMATTING RULES:\n1. Must use HTML tags for ALL formatting - NO markdown\n2. Use <br> for ALL line breaks\n3. For code blocks, use <pre> with inline CSS styling\n4. Example formatting:\n   - Line breaks: <br>\n   - Code: <pre style=\"background-color: transparent; padding: 10px; border-radius: 5px;\">\n   - Lists: <ol> and <li> tags\n   - Bold: <strong>\n   - Italic: <em>",
        "inputSchema": {
          "type": "object",
          "properties": {
            "front": {
              "type": "string",
              "description": "The front of the card. Must use HTML formatting only."
            },
            "back": {
              "type": "string",
              "description": "The back of the card. Must use HTML formatting only."
            }
          },
          "required": [
            "front",
            "back"
          ]
        }
      },
      {
        "name": "get_due_cards",
        "description": "Returns a given number (num) of cards due for review.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "num": {
              "type": "number",
              "description": "Number of due cards to get"
            }
          },
          "required": [
            "num"
          ]
        }
      },
      {
        "name": "get_new_cards",
        "description": "Returns a given number (num) of new and unseen cards.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "num": {
              "type": "number",
              "description": "Number of new cards to get"
            }
          },
          "required": [
            "num"
          ]
        }
      }
    ]
  },
  "obsidian-markdown-notes": {
    "name": "obsidian-markdown-notes",
    "display_name": "Obsidian Markdown Notes",
    "description": "Read and search through your Obsidian vault or any directory containing Markdown notes",
    "repository": {
      "type": "git",
      "url": "https://github.com/calclavia/mcp-obsidian"
    },
    "homepage": "https://github.com/calclavia/mcp-obsidian",
    "author": {
      "name": "calclavia"
    },
    "license": "APGL-3.0",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "obsidian"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/calclavia/mcp-obsidian.git",
          "${OBSIDIAN_VAULT_PATH}"
        ]
      }
    },
    "arguments": {
      "OBSIDIAN_VAULT_PATH": {
        "description": "Path to your Obsidian vault",
        "required": true
      }
    },
    "tools": [
      {
        "name": "read_notes",
        "description": "Read the contents of multiple notes. Each note's content is returned with its path as a reference. Failed reads for individual notes won't stop the entire operation. Reading too many at once may result in an error.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "paths"
          ]
        }
      },
      {
        "name": "search_notes",
        "description": "Searches for a note by its name. The search is case-insensitive and matches partial names. Queries can also be a valid regex. Returns paths of the notes that match the query.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "fireproof-mcp": {
    "display_name": "Model Context Protocol and Fireproof Demo: JSON Document Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/fireproof-storage/mcp-database-server"
    },
    "license": "MIT",
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "/path/to/fireproof-mcp/build/index.js"
        ],
        "description": "Run the server using Node.js after installing dependencies and building"
      }
    },
    "homepage": "https://github.com/fireproof-storage/mcp-database-server",
    "author": {
      "name": "fireproof-storage"
    },
    "tags": [
      "fireproof",
      "database",
      "MCP",
      "Model Context Protocol",
      "JSON",
      "document store"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "description": "Using the server with Claude Desktop",
        "prompt": "Configure Claude Desktop to use the Fireproof MCP server by adding the server config to the appropriate location."
      }
    ],
    "name": "fireproof-mcp",
    "description": "Immutable ledger database with live synchronization",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "lingo-dev": {
    "display_name": "Lingo.dev MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/lingodotdev/lingo.dev"
    },
    "homepage": "https://lingo.dev",
    "author": {
      "name": "lingodotdev"
    },
    "license": "Apache-2.0",
    "tags": [
      "translation",
      "localization",
      "mcp"
    ],
    "arguments": {
      "api-key": {
        "description": "Your Lingo.dev project API key",
        "required": true,
        "example": "<api-key>"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "lingo.dev",
          "mcp",
          "${api-key}"
        ],
        "description": "Run the Lingo.dev MCP server using npx",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Translate content",
        "description": "Ask the AI tool to translate content using Lingo.dev",
        "prompt": "Translate this text to Spanish: 'Hello world'"
      }
    ],
    "name": "lingo-dev",
    "description": "The [Model Context Protocol](https://modelcontextprotocol.io/introduction) (MCP) is a standard for connecting Large Language Models (LLMs) to external services. This guide will walk you through how to connect AI tools to Lingo.dev using MCP.",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "veyrax-mcp": {
    "display_name": "VeyraX MCP",
    "repository": {
      "type": "git",
      "url": "https://github.com/VeyraX/veyrax-mcp"
    },
    "homepage": "https://www.veyrax.com",
    "author": {
      "name": "VeyraX"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "MCP",
      "Model Context Protocol",
      "AI tools",
      "LLM integration"
    ],
    "arguments": {
      "VEYRAX_API_KEY": {
        "description": "Your VeyraX API key found in your account settings",
        "required": true
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "path/to/veyrax-mcp/build/src/index.js",
          "--config",
          "\"{\\\"VEYRAX_API_KEY\\\":\\\"${VEYRAX_API_KEY}\\\"}\""
        ]
      }
    },
    "examples": [
      {
        "title": "Getting Started with VeyraX MCP",
        "description": "Basic setup for VeyraX MCP",
        "prompt": "How do I set up VeyraX MCP in my environment?"
      }
    ],
    "name": "veyrax-mcp",
    "description": "Single tool to control all 100+ API integrations, and UI components",
    "categories": [
      "MCP Tools"
    ],
    "is_official": true
  },
  "mcp-server-neon": {
    "display_name": "Neon MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/neondatabase/mcp-server-neon"
    },
    "homepage": "https://neon.tech",
    "author": {
      "name": "neondatabase"
    },
    "license": "MIT",
    "tags": [
      "database",
      "postgres",
      "neon",
      "mcp",
      "llm"
    ],
    "arguments": {
      "NEON_API_KEY": {
        "description": "Neon API key - you can generate one through the Neon console",
        "required": true
      }
    },
    "installations": {
      "cli": {
        "type": "cli",
        "command": "npx",
        "args": [
          "@neondatabase/mcp-server-neon",
          "init",
          "$NEON_API_KEY"
        ],
        "package": "@neondatabase/mcp-server-neon",
        "env": {},
        "description": "Install via npm",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "List projects",
        "description": "List all Neon projects",
        "prompt": "List me all my Neon projects"
      },
      {
        "title": "Create database and table",
        "description": "Create a new Postgres database and add a users table",
        "prompt": "Let's create a new Postgres database, and call it \"my-database\". Let's then create a table called users with the following columns: id, name, email, and password."
      },
      {
        "title": "Run migration",
        "description": "Run a migration to alter a table",
        "prompt": "I want to run a migration on my project called \"my-project\" that alters the users table to add a new column called \"created_at\"."
      },
      {
        "title": "Project summary",
        "description": "Get a summary of all projects and data",
        "prompt": "Can you give me a summary of all of my Neon projects and what data is in each one?"
      }
    ],
    "name": "mcp-server-neon",
    "description": "This lets you use Claude Desktop, or any MCP Client, to use natural language to accomplish things with Neon.",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "video-editor": {
    "name": "video-editor",
    "display_name": "Video Editor",
    "description": "A Model Context Protocol Server to add, edit, and search videos with [Video Jungle](https://www.video-jungle.com/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/burningion/video-editing-mcp"
    },
    "homepage": "https://github.com/burningion/video-editing-mcp",
    "author": {
      "name": "burningion"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "video",
      "editing",
      "API"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/burningion/video-editing-mcp",
          "video-editor-mcp",
          "${YOURAPIKEY}"
        ]
      }
    },
    "examples": [
      {
        "title": "Add Video Example",
        "description": "Shows how to add a video from a URL.",
        "prompt": "can you download the video at https://www.youtube.com/shorts/RumgYaH5XYw and name it fly traps?"
      },
      {
        "title": "Search Videos Example",
        "description": "Example of searching videos with a keyword.",
        "prompt": "can you search my videos for fly traps?"
      },
      {
        "title": "Generate Edit Example",
        "description": "Creates an edit from found video segments.",
        "prompt": "can you create an edit of all the times the video says \"fly trap\"?"
      }
    ],
    "arguments": {
      "YOURAPIKEY": {
        "description": "API key required to authenticate and communicate with Video Jungle services.",
        "required": true,
        "example": "YOURAPIKEY"
      }
    },
    "tools": [
      {
        "name": "add-video",
        "description": "Upload video from URL. Begins analysis of video to allow for later information retrieval for automatic video editing an search.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "url": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "url"
          ]
        }
      },
      {
        "name": "search-remote-videos",
        "description": "Default method to search videos. Will return videos including video_ids, which allow for information retrieval and building video edits.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Text search query"
            },
            "limit": {
              "type": "integer",
              "default": 10,
              "minimum": 1,
              "description": "Maximum number of results to return"
            },
            "project_id": {
              "type": "string",
              "format": "uuid",
              "description": "Project ID to scope the search"
            },
            "duration_min": {
              "type": "number",
              "minimum": 0,
              "description": "Minimum video duration in seconds"
            },
            "duration_max": {
              "type": "number",
              "minimum": 0,
              "description": "Maximum video duration in seconds"
            }
          },
          "created_after": {
            "type": "string",
            "format": "date-time",
            "description": "Filter videos created after this datetime"
          },
          "created_before": {
            "type": "string",
            "format": "date-time",
            "description": "Filter videos created before this datetime"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "description": "Set of tags to filter by"
          },
          "include_segments": {
            "type": "boolean",
            "default": true,
            "description": "Whether to include video segments in results"
          },
          "include_related": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include related videos"
          },
          "query_audio": {
            "type": "string",
            "description": "Audio search query"
          },
          "query_img": {
            "type": "string",
            "description": "Image search query"
          },
          "oneOf": [
            {
              "required": [
                "query"
              ]
            }
          ]
        }
      },
      {
        "name": "search-local-videos",
        "description": "Search user's local videos in Photos app by keyword",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string"
            },
            "start_date": {
              "type": "string",
              "description": "ISO 8601 formatted datetime string (e.g. 2024-01-21T15:30:00Z)"
            },
            "end_date": {
              "type": "string",
              "description": "ISO 8601 formatted datetime string (e.g. 2024-01-21T15:30:00Z)"
            }
          },
          "required": [
            "keyword"
          ]
        }
      },
      {
        "name": "generate-edit-from-videos",
        "description": "Generate an edit from videos, from within a specific project. Creates a new project to work within no existing project ID (UUID) is passed ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Either an existing Project UUID or String. A UUID puts the edit in an existing project, and a string creates a new project with that name."
            },
            "name": {
              "type": "string",
              "description": "Video Edit name"
            },
            "open_editor": {
              "type": "boolean",
              "description": "Open a live editor with the project's edit"
            },
            "resolution": {
              "type": "string",
              "description": "Video resolution. Examples include '1920x1080', '1280x720'"
            },
            "edit": {
              "type": "array",
              "cuts": {
                "video_id": {
                  "type": "string",
                  "description": "Video UUID"
                },
                "video_start_time": {
                  "type": "string",
                  "description": "Clip start time in 00:00:00.000 format"
                },
                "video_end_time": {
                  "type": "string",
                  "description": "Clip end time in 00:00:00.000 format"
                }
              }
            }
          },
          "required": [
            "edit",
            "cuts",
            "name",
            "project_id"
          ]
        }
      },
      {
        "name": "generate-edit-from-single-video",
        "description": "Generate a compressed video edit from a single video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string"
            },
            "resolution": {
              "type": "string"
            },
            "video_id": {
              "type": "string"
            },
            "edit": {
              "type": "array",
              "cuts": {
                "video_start_time": "time",
                "video_end_time": "time"
              }
            }
          },
          "required": [
            "edit",
            "project_id",
            "video_id",
            "cuts"
          ]
        }
      },
      {
        "name": "update-video-edit",
        "description": "Update an existing video edit within a specific project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "UUID of the project containing the edit"
            },
            "edit_id": {
              "type": "string",
              "description": "UUID of the video edit to update"
            },
            "name": {
              "type": "string",
              "description": "Video Edit name"
            },
            "description": {
              "type": "string",
              "description": "Description of the video edit"
            },
            "video_output_format": {
              "type": "string",
              "description": "Output format for the video (e.g., 'mp4', 'webm')"
            },
            "video_output_resolution": {
              "type": "string",
              "description": "Video resolution. Examples include '1920x1080', '1280x720'"
            },
            "video_output_fps": {
              "type": "number",
              "description": "Frames per second for the output video"
            },
            "video_series_sequential": {
              "type": "array",
              "description": "Array of video clips in sequential order",
              "items": {
                "type": "object",
                "properties": {
                  "video_id": {
                    "type": "string",
                    "description": "Video UUID"
                  },
                  "video_start_time": {
                    "type": "string",
                    "description": "Clip start time in 00:00:00.000 format"
                  },
                  "video_end_time": {
                    "type": "string",
                    "description": "Clip end time in 00:00:00.000 format"
                  }
                }
              }
            },
            "audio_overlay": {
              "type": "object",
              "description": "Audio overlay settings and assets"
            },
            "rendered": {
              "type": "boolean",
              "description": "Whether the edit has been rendered"
            }
          },
          "required": [
            "project_id",
            "edit_id"
          ]
        }
      },
      {
        "name": "create-video-bar-chart-from-two-axis-data",
        "description": "Create a video bar chart from two-axis data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x_values": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "y_values": {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            "x_label": {
              "type": "string"
            },
            "y_label": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "filename": {
              "type": "string"
            }
          },
          "required": [
            "x_values",
            "y_values",
            "x_label",
            "y_label",
            "title"
          ]
        }
      },
      {
        "name": "create-video-line-chart-from-two-axis-data",
        "description": "Create a video line chart from two-axis data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x_values": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "y_values": {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            "x_label": {
              "type": "string"
            },
            "y_label": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "filename": {
              "type": "string"
            }
          },
          "required": [
            "x_values",
            "y_values",
            "x_label",
            "y_label",
            "title"
          ]
        }
      }
    ]
  },
  "mongodb": {
    "name": "mongodb",
    "display_name": "MongoDB",
    "description": "A Model Context Protocol Server for MongoDB.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kiliczsh/mcp-mongo-server"
    },
    "homepage": "https://github.com/kiliczsh/mcp-mongo-server",
    "author": {
      "name": "kiliczsh"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "MongoDB",
      "LLM"
    ],
    "arguments": {
      "MONGODB_URI": {
        "description": "The connection string for the MongoDB database.",
        "required": true,
        "example": "mongodb://muhammed:kilic@mongodb.localhost/sample_namespace"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-mongo-server",
          "${MONGODB_URI}"
        ]
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Execute a MongoDB query with optional execution plan analysis",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to query"
            },
            "filter": {
              "type": "object",
              "description": "MongoDB query filter"
            },
            "projection": {
              "type": "object",
              "description": "Fields to include/exclude"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of documents to return"
            },
            "explain": {
              "type": "string",
              "description": "Optional: Get query execution information (queryPlanner, executionStats, or allPlansExecution)",
              "enum": [
                "queryPlanner",
                "executionStats",
                "allPlansExecution"
              ]
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "aggregate",
        "description": "Execute a MongoDB aggregation pipeline with optional execution plan analysis",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to aggregate"
            },
            "pipeline": {
              "type": "array",
              "description": "Aggregation pipeline stages"
            },
            "explain": {
              "type": "string",
              "description": "Optional: Get aggregation execution information (queryPlanner, executionStats, or allPlansExecution)",
              "enum": [
                "queryPlanner",
                "executionStats",
                "allPlansExecution"
              ]
            }
          },
          "required": [
            "collection",
            "pipeline"
          ]
        }
      },
      {
        "name": "update",
        "description": "Update documents in a MongoDB collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to update"
            },
            "filter": {
              "type": "object",
              "description": "Filter to select documents to update"
            },
            "update": {
              "type": "object",
              "description": "Update operations to apply ($set, $unset, $inc, etc.)"
            },
            "upsert": {
              "type": "boolean",
              "description": "Create a new document if no documents match the filter"
            },
            "multi": {
              "type": "boolean",
              "description": "Update multiple documents that match the filter"
            }
          },
          "required": [
            "collection",
            "filter",
            "update"
          ]
        }
      },
      {
        "name": "serverInfo",
        "description": "Get MongoDB server information including version, storage engine, and other details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "includeDebugInfo": {
              "type": "boolean",
              "description": "Include additional debug information about the server"
            }
          }
        }
      },
      {
        "name": "insert",
        "description": "Insert one or more documents into a MongoDB collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to insert into"
            },
            "documents": {
              "type": "array",
              "description": "Array of documents to insert",
              "items": {
                "type": "object"
              }
            },
            "ordered": {
              "type": "boolean",
              "description": "Optional: If true, perform an ordered insert of the documents. If false, perform an unordered insert"
            },
            "writeConcern": {
              "type": "object",
              "description": "Optional: Write concern for the insert operation"
            },
            "bypassDocumentValidation": {
              "type": "boolean",
              "description": "Optional: Allow insert to bypass schema validation"
            }
          },
          "required": [
            "collection",
            "documents"
          ]
        }
      },
      {
        "name": "createIndex",
        "description": "Create one or more indexes on a MongoDB collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to create indexes on"
            },
            "indexes": {
              "type": "array",
              "description": "Array of index specifications",
              "items": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "object",
                    "description": "Index key pattern, e.g. { field: 1 } for ascending, { field: -1 } for descending"
                  },
                  "name": {
                    "type": "string",
                    "description": "Optional: Name of the index"
                  },
                  "unique": {
                    "type": "boolean",
                    "description": "Optional: If true, creates a unique index"
                  },
                  "sparse": {
                    "type": "boolean",
                    "description": "Optional: If true, creates a sparse index"
                  },
                  "background": {
                    "type": "boolean",
                    "description": "Optional: If true, creates the index in the background"
                  },
                  "expireAfterSeconds": {
                    "type": "number",
                    "description": "Optional: Specifies the TTL for documents (time to live)"
                  },
                  "partialFilterExpression": {
                    "type": "object",
                    "description": "Optional: Filter expression for partial indexes"
                  }
                },
                "required": [
                  "key"
                ]
              }
            },
            "writeConcern": {
              "type": "object",
              "description": "Optional: Write concern for the index creation"
            },
            "commitQuorum": {
              "type": [
                "string",
                "number"
              ],
              "description": "Optional: Number of voting members required to create index"
            }
          },
          "required": [
            "collection",
            "indexes"
          ]
        }
      },
      {
        "name": "count",
        "description": "Count the number of documents in a collection that match a query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to count documents in"
            },
            "query": {
              "type": "object",
              "description": "Optional: Query filter to select documents to count"
            },
            "limit": {
              "type": "integer",
              "description": "Optional: Maximum number of documents to count"
            },
            "skip": {
              "type": "integer",
              "description": "Optional: Number of documents to skip before counting"
            },
            "hint": {
              "type": "object",
              "description": "Optional: Index hint to force query plan"
            },
            "readConcern": {
              "type": "object",
              "description": "Optional: Read concern for the count operation"
            },
            "maxTimeMS": {
              "type": "integer",
              "description": "Optional: Maximum time to allow the count to run"
            },
            "collation": {
              "type": "object",
              "description": "Optional: Collation rules for string comparison"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "listCollections",
        "description": "List all collections in the MongoDB database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "nameOnly": {
              "type": "boolean",
              "description": "Optional: If true, returns only the collection names instead of full collection info"
            },
            "filter": {
              "type": "object",
              "description": "Optional: Filter to apply to the collections"
            }
          }
        }
      }
    ]
  },
  "data-exploration": {
    "name": "data-exploration",
    "display_name": "Data Exploration",
    "description": "MCP server for autonomous data exploration on .csv-based datasets, providing intelligent insights with minimal effort. NOTE: Will execute arbitrary Python code on your machine, please use with caution!",
    "repository": {
      "type": "git",
      "url": "https://github.com/reading-plus-ai/mcp-server-data-exploration"
    },
    "homepage": "https://github.com/reading-plus-ai/mcp-server-data-exploration",
    "author": {
      "name": "reading-plus-ai"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "data",
      "exploration"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-ds"
        ]
      }
    },
    "examples": [
      {
        "title": "California Real Estate Listing Prices",
        "description": "Exploring housing price trends in California using a dataset.",
        "prompt": "csv_path: Local path to the CSV file, topic: Housing price trends in California."
      },
      {
        "title": "Weather in London",
        "description": "Investigating daily weather history in London using a dataset.",
        "prompt": "csv_path: Local path to the CSV file, topic: Weather in London."
      }
    ],
    "tools": [
      {
        "name": "load_csv",
        "description": "\nLoad CSV File Tool\n\nPurpose:\nLoad a local CSV file into a DataFrame.\n\nUsage Notes:\n\t\u2022\tIf a df_name is not provided, the tool will automatically assign names sequentially as df_1, df_2, and so on.\n",
        "inputSchema": {
          "properties": {
            "csv_path": {
              "title": "Csv Path",
              "type": "string"
            },
            "df_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Df Name"
            }
          },
          "required": [
            "csv_path"
          ],
          "title": "LoadCsv",
          "type": "object"
        }
      },
      {
        "name": "run_script",
        "description": "\nPython Script Execution Tool\n\nPurpose:\nExecute Python scripts for specific data analytics tasks.\n\nAllowed Actions\n\t1.\tPrint Results: Output will be displayed as the script\u2019s stdout.\n\t2.\t[Optional] Save DataFrames: Store DataFrames in memory for future use by specifying a save_to_memory name.\n\nProhibited Actions\n\t1.\tOverwriting Original DataFrames: Do not modify existing DataFrames to preserve their integrity for future tasks.\n\t2.\tCreating Charts: Chart generation is not permitted.\n",
        "inputSchema": {
          "properties": {
            "script": {
              "title": "Script",
              "type": "string"
            },
            "save_to_memory": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Save To Memory"
            }
          },
          "required": [
            "script"
          ],
          "title": "RunScript",
          "type": "object"
        }
      }
    ]
  },
  "tmdb": {
    "name": "tmdb",
    "display_name": "TMDB",
    "description": "This MCP server integrates with The Movie Database (TMDB) API to provide movie information, search capabilities, and recommendations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Laksh-star/mcp-server-tmdb"
    },
    "homepage": "https://github.com/Laksh-star/mcp-server-tmdb",
    "author": {
      "name": "Laksh-star"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "tmdb",
      "movies",
      "recommendations"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/Laksh-star/mcp-server-tmdb"
        ],
        "env": {
          "TMDB_API_KEY": "${TMDB_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Search for Movies",
        "description": "Search for movies by title or keywords",
        "prompt": "\"Search for movies about artificial intelligence\""
      },
      {
        "title": "Get Trending Movies",
        "description": "Get today's or this week's trending movies",
        "prompt": "\"What are the trending movies today?\""
      },
      {
        "title": "Get Movie Recommendations",
        "description": "Get movie recommendations based on a movie ID",
        "prompt": "\"Get movie recommendations based on movie ID 550\""
      },
      {
        "title": "Get Movie Details",
        "description": "Get details of a specific movie by ID",
        "prompt": "\"Tell me about the movie with ID 550\""
      }
    ],
    "arguments": {
      "TMDB_API_KEY": {
        "description": "API key used to authenticate requests to the TMDB API.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "search_movies",
        "description": "Search for movies by title or keywords",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query for movie titles"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_recommendations",
        "description": "Get movie recommendations based on a movie ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "movieId": {
              "type": "string",
              "description": "TMDB movie ID to get recommendations for"
            }
          },
          "required": [
            "movieId"
          ]
        }
      },
      {
        "name": "get_trending",
        "description": "Get trending movies for a time window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timeWindow": {
              "type": "string",
              "enum": [
                "day",
                "week"
              ],
              "description": "Time window for trending movies"
            }
          },
          "required": [
            "timeWindow"
          ]
        }
      }
    ]
  },
  "minima": {
    "name": "minima",
    "display_name": "Minima",
    "description": "MCP server for RAG on local files",
    "repository": {
      "type": "git",
      "url": "https://github.com/dmayboroda/minima"
    },
    "homepage": "https://github.com/dmayboroda/minima",
    "author": {
      "name": "dmayboroda"
    },
    "license": "MPLv2",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "ChatGPT",
      "Integration",
      "Local",
      "Open Source"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/dmayboroda/minima.git@main#subdirectory=mcp-server",
          "minima"
        ]
      }
    },
    "arguments": {
      "LOCAL_FILES_PATH": {
        "description": "Specify the root folder for indexing (on your cloud or local pc). Indexing is a recursive process, meaning all documents within subfolders of this root folder will also be indexed. Supported file types: .pdf, .xls, .docx, .txt, .md, .csv.",
        "required": true,
        "example": "/Users/davidmayboroda/Downloads/PDFs/"
      },
      "EMBEDDING_MODEL_ID": {
        "description": "Specify the embedding model to use. Currently, only Sentence Transformer models are supported. Testing has been done with sentence-transformers/all-mpnet-base-v2, but other Sentence Transformer models can be used.",
        "required": false,
        "example": "sentence-transformers/all-mpnet-base-v2"
      },
      "EMBEDDING_SIZE": {
        "description": "Define the embedding dimension provided by the model, which is needed to configure Qdrant vector storage. Ensure this value matches the actual embedding size of the specified EMBEDDING_MODEL_ID.",
        "required": false,
        "example": "768"
      },
      "OLLAMA_MODEL": {
        "description": "Set up the Ollama model, use an ID available on the Ollama site. Please, use LLM model here, not an embedding.",
        "required": false,
        "example": "qwen2:0.5b"
      },
      "RERANKER_MODEL": {
        "description": "Specify the reranker model. Currently, we have tested with BAAI rerankers. You can explore all available rerankers using a specific link.",
        "required": false,
        "example": "BAAI/bge-reranker-base"
      },
      "USER_ID": {
        "description": "Just use your email here, this is needed to authenticate custom GPT to search in your data.",
        "required": true,
        "example": "user@gmail.com"
      },
      "PASSWORD": {
        "description": "Put any password here, this is used to create a firebase account for the email specified above.",
        "required": true,
        "example": "password"
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Find a context in local files (PDF, CSV, DOCX, MD, TXT)",
        "inputSchema": {
          "properties": {
            "text": {
              "description": "context to find",
              "title": "Text",
              "type": "string"
            }
          },
          "required": [
            "text"
          ],
          "title": "Query",
          "type": "object"
        }
      }
    ]
  },
  "fastn-ai-unified-api-mcp-server": {
    "name": "fastn-ai-unified-api-mcp-server",
    "display_name": "Fastn AI Unified API",
    "description": "A remote, dynamic MCP server with a unified API that connects to 1,000+ tools, actions, and workflows, featuring built-in authentication and monitoring.",
    "repository": {
      "type": "git",
      "url": "https://github.com/fastnai/mcp-fastn"
    },
    "homepage": "https://github.com/fastnai/mcp-fastn",
    "author": {
      "name": "fastnai"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "Fastn",
      "Dynamic Tool Registration",
      "API-Driven Operations"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/fastnai/mcp-fastn",
          "fastn",
          "--api_key",
          "${YOUR_API_KEY}",
          "--space_id",
          "${YOUR_WORKSPACE_ID}"
        ]
      }
    },
    "arguments": {
      "YOUR_API_KEY": {
        "description": "The API key is required to authenticate and access the Fastn server's features and services.",
        "required": true,
        "example": "your_actual_api_key_here"
      },
      "YOUR_WORKSPACE_ID": {
        "description": "The unique identifier for your workspace in Fastn, which directs the server to the correct environment and settings.",
        "required": true,
        "example": "your_actual_workspace_id_here"
      }
    }
  },
  "sentry": {
    "name": "sentry",
    "display_name": "Sentry",
    "description": "Retrieving and analyzing issues from Sentry.io",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/sentry",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "sentry",
      "monitoring",
      "errors",
      "debugging"
    ],
    "examples": [
      {
        "title": "Retrieve issue details from Sentry",
        "description": "Use this command to get detailed information about a specific Sentry issue using its ID or URL.",
        "prompt": "sentry-issue {issue_id_or_url}"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-sentry",
          "--auth-token",
          "${YOUR_SENTRY_TOKEN}"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "mcp/sentry",
          "--auth-token",
          "${YOUR_SENTRY_TOKEN}"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp_server_sentry",
          "--auth-token",
          "${YOUR_SENTRY_TOKEN}"
        ]
      }
    },
    "arguments": {
      "YOUR_SENTRY_TOKEN": {
        "description": "An authentication token required to access your Sentry account and retrieve issue details.",
        "required": true,
        "example": "abc123def456"
      }
    },
    "tools": [
      {
        "name": "get_sentry_issue",
        "description": "Retrieve and analyze a Sentry issue by ID or URL. Use this tool when you need to:\n                - Investigate production errors and crashes\n                - Access detailed stacktraces from Sentry\n                - Analyze error patterns and frequencies\n                - Get information about when issues first/last occurred\n                - Review error counts and status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id_or_url": {
              "type": "string",
              "description": "Sentry issue ID or URL to analyze"
            }
          },
          "required": [
            "issue_id_or_url"
          ]
        }
      }
    ],
    "is_official": true
  },
  "mcp-proxy": {
    "name": "mcp-proxy",
    "display_name": "MCP Proxy",
    "description": "Connect to MCP servers that run on SSE transport, or expose stdio servers as an SSE server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sparfenyuk/mcp-proxy"
    },
    "homepage": "https://github.com/sparfenyuk/mcp-proxy",
    "author": {
      "name": "sparfenyuk"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "proxy",
      "sse",
      "stdio"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-proxy"
        ]
      }
    }
  },
  "dataset-viewer": {
    "name": "dataset-viewer",
    "display_name": "Dataset Viewer",
    "description": "Browse and analyze Hugging Face datasets with features like search, filtering, statistics, and data export",
    "repository": {
      "type": "git",
      "url": "https://github.com/privetin/dataset-viewer"
    },
    "homepage": "https://github.com/privetin/dataset-viewer",
    "author": {
      "name": "privetin",
      "url": "https://github.com/privetin"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Hugging Face",
      "datasets",
      "data analysis"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/privetin/dataset-viewer",
          "dataset-viewer"
        ]
      }
    },
    "examples": [
      {
        "title": "Validate a dataset",
        "description": "Check if a dataset exists and is accessible.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\"}"
      },
      {
        "title": "Get dataset information",
        "description": "Retrieve detailed information about a dataset.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\"}"
      },
      {
        "title": "Search dataset contents",
        "description": "Search for text within a dataset.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\",\"config\": \"plain_text\",\"split\": \"train\",\"query\": \"great movie\"}"
      },
      {
        "title": "Filter and sort rows",
        "description": "Filter rows using SQL-like conditions and sort them.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\",\"config\": \"plain_text\",\"split\": \"train\",\"where\": \"label = 'positive'\",\"orderby\": \"text DESC\",\"page\": 0}"
      },
      {
        "title": "Get dataset statistics",
        "description": "Get statistics about a dataset split.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\",\"config\": \"plain_text\",\"split\": \"train\"}"
      }
    ],
    "arguments": {
      "HUGGINGFACE_TOKEN": {
        "description": "Your Hugging Face API token for accessing private datasets",
        "required": false,
        "example": ""
      }
    },
    "tools": [
      {
        "name": "get_info",
        "description": "Get detailed information about a Hugging Face dataset including description, features, splits, and statistics. Run validate first to check if the dataset exists and is accessible.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset"
          ]
        }
      },
      {
        "name": "get_rows",
        "description": "Get paginated rows from a Hugging Face dataset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "page": {
              "type": "integer",
              "description": "Page number (0-based), returns 100 rows per page",
              "default": 0
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split"
          ]
        }
      },
      {
        "name": "get_first_rows",
        "description": "Get first rows from a Hugging Face dataset split",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split"
          ]
        }
      },
      {
        "name": "search_dataset",
        "description": "Search for text within a Hugging Face dataset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "query": {
              "type": "string",
              "description": "Text to search for in the dataset"
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split",
            "query"
          ]
        }
      },
      {
        "name": "filter",
        "description": "Filter rows in a Hugging Face dataset using SQL-like conditions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "where": {
              "type": "string",
              "description": "SQL-like WHERE clause to filter rows",
              "examples": [
                "column = \"value\"",
                "score > 0.5",
                "text LIKE \"%query%\""
              ]
            },
            "orderby": {
              "type": "string",
              "description": "SQL-like ORDER BY clause to sort results",
              "optional": true,
              "examples": [
                "column ASC",
                "score DESC",
                "name ASC, id DESC"
              ]
            },
            "page": {
              "type": "integer",
              "description": "Page number for paginated results (100 rows per page)",
              "default": 0,
              "minimum": 0
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split",
            "where"
          ]
        }
      },
      {
        "name": "get_statistics",
        "description": "Get statistics about a Hugging Face dataset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split"
          ]
        }
      },
      {
        "name": "get_parquet",
        "description": "Export Hugging Face dataset split as Parquet file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset"
          ]
        }
      },
      {
        "name": "validate",
        "description": "Check if a Hugging Face dataset exists and is accessible",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset"
          ]
        }
      }
    ]
  },
  "intercom": {
    "name": "intercom",
    "display_name": "Intercom Support Server",
    "description": "An MCP-compliant server for retrieving customer support tickets from Intercom. This tool enables AI assistants like Claude Desktop and Cline to access and analyze your Intercom support tickets.",
    "repository": {
      "type": "git",
      "url": "https://github.com/raoulbia-ai/mcp-server-for-intercom"
    },
    "homepage": "https://github.com/raoulbia-ai/mcp-server-for-intercom",
    "author": {
      "name": "raoulbia-ai"
    },
    "license": "Apache-2.0",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Intercom",
      "support-tickets",
      "API"
    ],
    "examples": [
      {
        "title": "List Tickets Example",
        "description": "Retrieve support tickets from Intercom between specific dates",
        "prompt": "{\"startDate\":\"15/01/2025\",\"endDate\":\"21/01/2025\",\"keyword\":\"billing\"}"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/raoulbia-ai/mcp-server-for-intercom"
        ],
        "env": {
          "INTERCOM_ACCESS_TOKEN": "your-intercom-access-token"
        }
      }
    },
    "arguments": {
      "INTERCOM_ACCESS_TOKEN": {
        "description": "Your Intercom API token used to authenticate requests to the Intercom API.",
        "required": true,
        "example": "your_intercom_api_token"
      }
    }
  },
  "xero-mcp-server@john-zhang-dev": {
    "name": "@john-zhang-dev/xero-mcp-server",
    "display_name": "Xero",
    "description": "Enabling clients to interact with Xero system for streamlined accounting, invoicing, and business operations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/john-zhang-dev/xero-mcp"
    },
    "license": "MIT",
    "examples": [
      {
        "title": "Visualize my financial position over the last month",
        "description": "",
        "prompt": "Visualize my financial position over the last month"
      },
      {
        "title": "Track my spendings over last week",
        "description": "",
        "prompt": "Track my spendings over last week"
      },
      {
        "title": "Add all transactions from the monthly statement into my revenue account (account code 201) as receive money",
        "description": "",
        "prompt": "Add all transactions from the monthly statement into my revenue account (account code 201) as receive money"
      }
    ],
    "author": {
      "name": "john-zhang-dev"
    },
    "homepage": "https://github.com/john-zhang-dev/xero-mcp",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "xero-mcp@latest"
        ],
        "env": {
          "XERO_CLIENT_ID": "${XERO_CLIENT_ID}",
          "XERO_CLIENT_SECRET": "${XERO_CLIENT_SECRET}",
          "XERO_REDIRECT_URI": "${XERO_REDIRECT_URI}"
        }
      }
    },
    "arguments": {
      "XERO_CLIENT_ID": {
        "description": "The Client ID obtained from the Xero Developer center after creating an OAuth 2.0 app, required for authentication.",
        "required": true,
        "example": "YOUR_CLIENT_ID"
      },
      "XERO_CLIENT_SECRET": {
        "description": "The Client Secret generated in the Xero Developer center, necessary for authenticating requests.",
        "required": true,
        "example": "YOUR_CLIENT_SECRET"
      },
      "XERO_REDIRECT_URI": {
        "description": "The URI to redirect to after authentication, should typically match the redirect URI specified in the OAuth 2.0 app settings.",
        "required": false,
        "example": "http://localhost:5000/callback"
      }
    },
    "categories": [
      "Finance"
    ],
    "tools": [
      {
        "name": "authenticate",
        "description": "Authenticate with Xero using OAuth2",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_bank_transactions",
        "description": "Creates one or more spent or received money transaction. Only use this tool when user has directly and explicitly ask you to create transactions.",
        "inputSchema": {
          "type": "object",
          "description": "Transactions with an array of BankTransaction objects to create",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/Pagination"
            },
            "Warnings": {
              "description": "Displays array of warning messages from the API",
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ValidationError"
              }
            },
            "BankTransactions": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/BankTransaction"
              }
            }
          },
          "example": "{ bankTransactions: [{ type: \"SPEND\", date: \"2023-01-01\", reference: \"INV-001\", subTotal: \"100\", total: \"115\", totalTax: \"15\", lineItems: [{ accountCode: \"401\", description: \"taxi fare\", lineAmount: \"115\" }], contact: { contactId: \"00000000-0000-0000-0000-000000000000\", name: \"John Doe\" }, \"bankAccount\": { \"accountID\": \"6f7594f2-f059-4d56-9e67-47ac9733bfe9\", \"Code\": \"088\", \"Name\": \"Business Wells Fargo\" } }]}"
        }
      },
      {
        "name": "create_contacts",
        "description": "Creates one or multiple contacts in a Xero organisation. Only use this tool when user has directly and explicitly ask you to create contact.",
        "inputSchema": {
          "type": "object",
          "description": "Contacts with an array of Contact objects to create",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/Pagination"
            },
            "Warnings": {
              "description": "Displays array of warning messages from the API",
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ValidationError"
              }
            },
            "Contacts": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Contact"
              }
            }
          },
          "example": "{ contacts: [{ name: \"John Doe\" }]}"
        }
      },
      {
        "name": "get_balance_sheet",
        "description": "Returns a balance sheet for the end of the month of the specified date. It also returns the value at the end of the same month for the previous year.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_accounts",
        "description": "Retrieves the full chart of accounts",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_bank_transactions",
        "description": "Retrieves any spent or received money transactions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "description": "Filter bank transactions. See example",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31)"
            }
          }
        }
      },
      {
        "name": "list_contacts",
        "description": "Retrieves all contacts in a Xero organisation",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_invoices",
        "description": "Retrieves sales invoices or purchase bills",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "description": "Filter invoices. See example",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31), DueDate < DateTime(2015, 12, 31)"
            }
          }
        }
      },
      {
        "name": "list_journals",
        "description": "Retrieves journals",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_organisations",
        "description": "Retrieves Xero organisation details",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_payments",
        "description": "Retrieves payments for invoices and credit notes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "description": "Filter payments. See example",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31)"
            }
          }
        }
      },
      {
        "name": "list_quotes",
        "description": "Retrieves sales quotes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "vega-lite": {
    "name": "vega-lite",
    "display_name": "Vega-Lite Data Visualization",
    "description": "Generate visualizations from fetched data using the VegaLite format and renderer.",
    "repository": {
      "type": "git",
      "url": "https://github.com/isaacwasserman/mcp-vegalite-server"
    },
    "homepage": "https://github.com/isaacwasserman/mcp-vegalite-server",
    "author": {
      "name": "isaacwasserman"
    },
    "license": "[NOT FOUND]",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "visualization",
      "data",
      "vega-lite"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/isaacwasserman/mcp-vegalite-server",
          "mcp_server_vegalite"
        ]
      }
    },
    "examples": [
      {
        "title": "Saving Data",
        "description": "Use the save_data tool to save a table of data for visualization.",
        "prompt": "save_data(name='my_table', data=[{'x': 1, 'y': 2}, {'x': 2, 'y': 3}])"
      },
      {
        "title": "Visualizing Data",
        "description": "Use the visualize_data tool to visualize saved data using Vega-Lite syntax.",
        "prompt": "visualize_data(data_name='my_table', vegalite_specification='{\"mark\": \"point\", \"encoding\": {\"x\":{\"field\":\"x\",\"type\":\"quantitative\"},\"y\":{\"field\":\"y\",\"type\":\"quantitative\"}}}')"
      }
    ],
    "tools": [
      {
        "name": "save_data",
        "description": "A tool which allows you to save data to a named table for later use in visualizations.\nWhen to use this tool:\n- Use this tool when you have data that you want to visualize later.\nHow to use this tool:\n- Provide the name of the table to save the data to (for later reference) and the data itself.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the table to save the data to"
            },
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "description": "Row of the table as a dictionary/object"
              },
              "description": "The data to save"
            }
          },
          "required": [
            "name",
            "data"
          ]
        }
      },
      {
        "name": "visualize_data",
        "description": "A tool which allows you to produce a data visualization using the Vega-Lite grammar.\nWhen to use this tool:\n- At times, it will be advantageous to provide the user with a visual representation of some data, rather than just a textual representation.\n- This tool is particularly useful when the data is complex or has many dimensions, making it difficult to understand in a tabular format. It is not useful for singular data points.\nHow to use this tool:\n- Prior to visualization, data must be saved to a named table using the save_data tool.\n- After saving the data, use this tool to visualize the data by providing the name of the table with the saved data and a Vega-Lite specification.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data_name": {
              "type": "string",
              "description": "The name of the data table to visualize"
            },
            "vegalite_specification": {
              "type": "string",
              "description": "The vegalite v5 specification for the visualization. Do not include the data field, as this will be added automatically."
            }
          },
          "required": [
            "data_name",
            "vegalite_specification"
          ]
        }
      }
    ]
  },
  "glean": {
    "name": "glean",
    "display_name": "Glean",
    "description": "A server that uses Glean API to search and chat.",
    "repository": {
      "type": "git",
      "url": "https://github.com/longyi1207/glean-mcp-server"
    },
    "homepage": "https://github.com/longyi1207/glean-mcp-server",
    "author": {
      "name": "longyi1207",
      "url": "https://github.com/longyi1207"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "glean",
      "search",
      "chat",
      "docker"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/longyi1207/glean-mcp-server"
        ],
        "env": {
          "GLEAN_API_KEY": "YOUR_API_KEY_HERE",
          "GLEAN_DOMAIN": "YOUR_DOMAIN_HERE"
        }
      }
    },
    "arguments": {
      "GLEAN_API_KEY": {
        "description": "The API key required to authenticate with the Glean API.",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      },
      "GLEAN_DOMAIN": {
        "description": "The domain used for the Glean API service operations.",
        "required": true,
        "example": "YOUR_DOMAIN_HERE"
      }
    }
  },
  "google-drive": {
    "name": "google-drive",
    "display_name": "Google Drive",
    "description": "File access and search capabilities for Google Drive",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/gdrive",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "google drive",
      "files",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-gdrive"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-v",
          "mcp-gdrive:/gdrive-server",
          "-e",
          "GDRIVE_CREDENTIALS_PATH=/gdrive-server/credentials.json",
          "mcp/gdrive"
        ]
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Search for files in Google Drive.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query"
          }
        },
        "required": [
          "query"
        ]
      }
    ],
    "is_official": true
  },
  "excel": {
    "name": "excel",
    "display_name": "Excel",
    "description": "Excel manipulation including data reading/writing, worksheet management, formatting, charts, and pivot table.",
    "repository": {
      "type": "git",
      "url": "https://github.com/haris-musa/excel-mcp-server"
    },
    "homepage": "https://github.com/haris-musa/excel-mcp-server",
    "author": {
      "name": "haris-musa"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Excel Manipulation",
      "Python"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/haris-musa/excel-mcp-server",
          "excel-mcp-server"
        ],
        "env": {
          "EXCEL_FILES_PATH": "${EXCEL_FILES_PATH}"
        }
      }
    },
    "arguments": {
      "EXCEL_FILES_PATH": {
        "description": "Directory where Excel files will be stored.",
        "required": false,
        "example": "/path/to/excel/files"
      }
    },
    "tools": [
      {
        "name": "create_workbook",
        "description": "Creates a new Excel workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          }
        },
        "required": [
          "filepath"
        ]
      },
      {
        "name": "create_worksheet",
        "description": "Creates a new worksheet in an existing workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name"
        ]
      },
      {
        "name": "get_workbook_metadata",
        "description": "Get metadata about workbook including sheets and ranges.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "include_ranges": {
            "type": "boolean"
          }
        },
        "required": [
          "filepath"
        ]
      },
      {
        "name": "write_data_to_excel",
        "description": "Write data to Excel worksheet.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "data": {
            "type": "array"
          },
          "start_cell": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "data"
        ]
      },
      {
        "name": "read_data_from_excel",
        "description": "Read data from Excel worksheet.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          },
          "preview_only": {
            "type": "boolean"
          }
        },
        "required": [
          "filepath",
          "sheet_name"
        ]
      },
      {
        "name": "format_range",
        "description": "Apply formatting to a range of cells.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          },
          "bold": {
            "type": "boolean"
          },
          "italic": {
            "type": "boolean"
          },
          "underline": {
            "type": "boolean"
          },
          "font_size": {
            "type": "integer"
          },
          "font_color": {
            "type": "string"
          },
          "bg_color": {
            "type": "string"
          },
          "border_style": {
            "type": "string"
          },
          "border_color": {
            "type": "string"
          },
          "number_format": {
            "type": "string"
          },
          "alignment": {
            "type": "string"
          },
          "wrap_text": {
            "type": "boolean"
          },
          "merge_cells": {
            "type": "boolean"
          },
          "protection": {
            "type": "object"
          },
          "conditional_format": {
            "type": "object"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell"
        ]
      },
      {
        "name": "merge_cells",
        "description": "Merge a range of cells.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell",
          "end_cell"
        ]
      },
      {
        "name": "unmerge_cells",
        "description": "Unmerge a previously merged range of cells.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell",
          "end_cell"
        ]
      },
      {
        "name": "apply_formula",
        "description": "Apply Excel formula to cell.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "cell": {
            "type": "string"
          },
          "formula": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "cell",
          "formula"
        ]
      },
      {
        "name": "validate_formula_syntax",
        "description": "Validate Excel formula syntax without applying it.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "cell": {
            "type": "string"
          },
          "formula": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "cell",
          "formula"
        ]
      },
      {
        "name": "create_chart",
        "description": "Create chart in worksheet.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "data_range": {
            "type": "string"
          },
          "chart_type": {
            "type": "string"
          },
          "target_cell": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "x_axis": {
            "type": "string"
          },
          "y_axis": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "data_range",
          "chart_type",
          "target_cell"
        ]
      },
      {
        "name": "create_pivot_table",
        "description": "Create pivot table in worksheet.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "data_range": {
            "type": "string"
          },
          "target_cell": {
            "type": "string"
          },
          "rows": {
            "type": "array"
          },
          "values": {
            "type": "array"
          },
          "columns": {
            "type": "array"
          },
          "agg_func": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "data_range",
          "target_cell",
          "rows",
          "values"
        ]
      },
      {
        "name": "copy_worksheet",
        "description": "Copy worksheet within workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "source_sheet": {
            "type": "string"
          },
          "target_sheet": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "source_sheet",
          "target_sheet"
        ]
      },
      {
        "name": "delete_worksheet",
        "description": "Delete worksheet from workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name"
        ]
      },
      {
        "name": "rename_worksheet",
        "description": "Rename worksheet in workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "old_name": {
            "type": "string"
          },
          "new_name": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "old_name",
          "new_name"
        ]
      },
      {
        "name": "copy_range",
        "description": "Copy a range of cells to another location.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "source_start": {
            "type": "string"
          },
          "source_end": {
            "type": "string"
          },
          "target_start": {
            "type": "string"
          },
          "target_sheet": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "source_start",
          "source_end",
          "target_start"
        ]
      },
      {
        "name": "delete_range",
        "description": "Delete a range of cells and shift remaining cells.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          },
          "shift_direction": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell",
          "end_cell"
        ]
      },
      {
        "name": "validate_excel_range",
        "description": "Validate if a range exists and is properly formatted.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell"
        ]
      }
    ]
  },
  "edubase": {
    "display_name": "EduBase MCP server",
    "repository": {
      "type": "git",
      "url": "https://github.com/EduBase/MCP"
    },
    "homepage": "https://www.edubase.net",
    "author": {
      "name": "EduBase"
    },
    "license": "MIT",
    "tags": [
      "education",
      "learning",
      "quiz",
      "assessment",
      "API"
    ],
    "arguments": {
      "EDUBASE_API_URL": {
        "description": "URL to the EduBase API",
        "required": true,
        "example": "https://domain.edubase.net/api"
      },
      "EDUBASE_API_APP": {
        "description": "Your integration app ID",
        "required": true,
        "example": "your_integration_app_id"
      },
      "EDUBASE_API_KEY": {
        "description": "Your integration secret key",
        "required": true,
        "example": "your_integration_secret_key"
      }
    },
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "EDUBASE_API_URL",
          "-e",
          "EDUBASE_API_APP",
          "-e",
          "EDUBASE_API_KEY",
          "edubase/mcp"
        ],
        "env": {
          "EDUBASE_API_URL": "https://domain.edubase.net/api",
          "EDUBASE_API_APP": "your_integration_app_id",
          "EDUBASE_API_KEY": "your_integration_secret_key"
        },
        "description": "Run using Docker",
        "recommended": false
      },
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "/path/to/dist/index.js"
        ],
        "env": {
          "EDUBASE_API_URL": "https://domain.edubase.net/api",
          "EDUBASE_API_APP": "your_integration_app_id",
          "EDUBASE_API_KEY": "your_integration_secret_key"
        },
        "description": "Run using Node.js",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Collaborative Education Management",
        "description": "Collaboratively creating and uploading questions, scheduling exams and analyzing user results with Claude",
        "prompt": "I'd like to create a new quiz in EduBase with 5 multiple choice questions about basic algebra."
      }
    ],
    "name": "edubase",
    "description": "<img src=\"https://static.edubase.net/media/brand/title/color.png\" alt=\"EduBase logo\" height=\"150\" />",
    "categories": [
      "MCP Tools"
    ],
    "tools": [
      {
        "name": "edubase_get_question",
        "description": "Check existing question. Questions are the lowest level in the EduBase hierarchy, serving as the building blocks for Quiz sets.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "external unique question identifier"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "edubase_post_question",
        "description": "Publish or update a question. Questions are the atomic building blocks of the EduBase Quiz system and represent the lowest level in the hierarchy (Questions -> Quiz sets -> Exams).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "External unique question identifier for question management.\nOn repeated uploads, the questions are updated (rather then added) based on this value, which can be an arbitrary text.\nIf the question already exists at upload time with the same external identifier (in the given folder or Quiz set), the existing question will be updated instead of being added as a new one.\n- Use cases:\n - Integration with external systems\n - Version control\n - Batch updates\n - Content synchronization\n- Best practices:\n - Use consistent naming conventions\n - Include version, source or date information\n - Consider hierarchical IDs for related content\nExample:\n- id=MATHEMATICS_ARITHMETIC_BASIC_ADDITION_STATIC_001\n- type=numerical\n- question=What is 2+2?\n- answer=4"
            },
            "type": {
              "type": "string",
              "description": "Type of the question.\nEduBase supports various question types to accommodate different assessment needs:\n- Basic Types:\n - GENERIC: Strict matching including spaces and punctuation\n - TEXT: Basic text input with flexible matching (ignores spaces and punctuation)\n - FREE-TEXT: Extended text response with semi-automatic grading\n - READING: Non-assessed text display for complex question groups\n- Choice-Based Types:\n - CHOICE: Single correct answer selection\n - MULTIPLE-CHOICE: Multiple correct answers\n - ORDER: Sequence arrangement (arrange items in correct order)\n - TRUE/FALSE: Statement evaluation (true statements in ANSWER, false in OPTIONS)\n- Numerical Types:\n - NUMERIC: Numerical value validation with fractions, constants, intervals\n - DATE/TIME: Calendar date validation with adjustable precision\n - EXPRESSION: Mathematical expression evaluation\n- Advanced Types:\n - MATRIX/MATRIX:EXPRESSION: Matrix evaluation (format: [a;b|c;d] for 2x2)\n - SET/SET:TEXT: Unordered collection validation\n - FILE: File submission evaluation\nExample:\ntype=numerical"
            },
            "question": {
              "type": "string",
              "description": "The main question text that will be displayed to the test taker.\nSupports rich formatting options:\n- LaTeX Support (requires QUESTION_FORMAT=LATEX):\n - Inline: $$...$$\n - Block: $$$$...$$$$\n - IMPORTANT: When using LaTeX in questions, you MUST use double dollar signs ($$...$$) for inline math or quadruple dollar signs ($$$$...$$$$) for block math.\n - Single dollar signs ($...$) are NOT supported and will not render correctly. The inline or block method must be used, as $...$ won't work!\n- Parameters: Use curly braces {parameter_name} (defined in PARAMETERS field)\n- Quick expressions: Use ~~~expression~~~ for simple parameter calculations, e.g., area of a circle is ~~~{r}*{r}*pi~~~\n- Style formatting with EduTags:\n - Bold: [[B]]...[[/B]]\n - Italic: [[I]]...[[/I]]\n - Underline: [[U]]...[[/U]]\n - Subscript: [[SUB]]...[[/SUB]], Superscript: [[SUP]]...[[/SUP]]\n - Code: [[CODE]]...[[/CODE]], [[CODEBLOCK]]...[[/CODEBLOCK]]\n - Colors: [[COLOR:{color}]]...[[/COLOR]], [[BACKGROUND:{color}]]...[[/BACKGROUND]]\n- Tables: Use [[..]] format with semicolons for columns, vertical bars for rows, e.g., [[Header 1; Header 2 | Data 1; Data 2]]\n- Answer placeholders: [[___]] (3 underscores), for fill-in-the-gaps\nExample:\nquestion=Calculate the area of a circle with radius {r} using $$A = \\pi r^2$$"
            },
            "question_format": {
              "type": "string",
              "description": "Controls question text rendering.\n- NORMAL: Default text formatting with standard font size, recommended for most tasks\n- LATEX: Enables LaTeX for mathematical, scientific notations (using KaTeX)\n- LONG: Smaller font with automatic paragraph breaks (ideal for lengthy text)\nExample:\nquestion_format=LATEX"
            },
            "answer": {
              "type": "string",
              "description": "The correct answer(s) for the question.\n- For multiple answers, separate with triple-and operator (\"&&&\")\n- Parameters can be used in curly braces {param_name}\n- LaTeX Support (requires QUESTION_FORMAT=LATEX):\n - Inline: $$...$$\n - Block: $$$$...$$$$\n - IMPORTANT: When using LaTeX in answer, you MUST use double dollar signs ($$...$$) for inline math or quadruple dollar signs ($$$$...$$$$) for block math.\n - Single dollar signs ($...$) are NOT supported and will not render correctly. The inline or block method must be used, as $...$ won't work!\n- Usage by question type:\n - CHOICE: The correct option\n - MULTIPLE-CHOICE: All correct options\n - TEXT/NUMERICAL/EXPRESSION: Expected response(s)\n - ORDER: Items in correct sequence\n - TRUE/FALSE: True statements (false statements go in OPTIONS)\n - MATRIX types: Use format [a;b|c;d] for matrices\n - SET types: Unordered collection of elements\nExample:\nanswer=Paris\nanswer=sin(x)^2+cos(x)^2 # with type = EXPRESSION\nanswer=$$sin^2(x)+cos^2(x)$$ # with type = CHOICE so it renders correctly"
            },
            "language": {
              "type": "string",
              "description": "The language of the question.\n- Alpha-2 code according to ISO 639-1\nExample:\nlanguage=hu  # Hungarian"
            },
            "image": {
              "type": "string",
              "description": "Attach an image to the question.\nSupported formats: PNG, JPEG, WebP\nFormat: filename=data, where data is either a base64-encoded image or a URL"
            },
            "answer_order": {
              "type": "string",
              "description": "Controls whether the sequence of multiple answers matters.\n- Plus sign (+) to indicate YES\n- Blank field or minus sign (-) indicates NO (default)\n- When using answer_label, this is automatically activated\n- Essential for questions where sequence is important (e.g., steps in a process)\nExample:\nanswer_order=+\nExample API call:\nid=europe_cities_population\ntype=text\nquestion=List the following European cities in descending order by population (largest first)\nanswer=London &&& Madrid &&& Paris\nanswer_order=+"
            },
            "answer_label": {
              "type": "string",
              "description": "Text displayed in/above the input field during the test.\n- Separate multiple labels with triple-and operators (\"&&&\")\n- Automatically activates the answer_order function\n- Perfect for multi-part questions where each part needs clear labeling\n- Useful for creating pairing/matching questions\nExample:\nanswer_label=a) Distance (km) &&& b) Time (hours) &&& c) Speed (km/h)\nExample API call:\nid=basic_math\ntype=numerical\nquestion=Given the number 16:\\n\\na) What is double this number?\\n\\nb) What is half of this number?\\n\\nc) What is this number plus 10?\nanswer=32 &&& 8 &&& 26\nanswer_label=a) Double &&& b) Half &&& c) Plus 10\npoints=3"
            },
            "answer_hide": {
              "type": "string",
              "description": "Controls whether correct answers are hidden on the results page.\n- Plus sign (+) to indicate YES\n- Blank field or minus sign (-) indicates NO (default)\n- Useful for test security and preventing answer sharing\n- Critical for reusable questions and practice tests\nExample:\nanswer_hide=+\nExample API call:\nid=uk_countries\ntype=text\nquestion=Name any of the countries within the United Kingdom!\nanswer=England &&& Northern Ireland &&& Scotland &&& Wales\nanswer_require=1\nanswer_hide=+"
            },
            "answer_indefinite": {
              "type": "string",
              "description": "Allows users to add any number of input fields using + and - buttons.\n- Plus sign (+) to indicate YES\n- Blank field or minus sign (-) indicates NO (default)\n- Answer labels will not appear when this is enabled\n- Ideal for brainstorming exercises or questions with variable number of answers\nExample:\nanswer_indefinite=+\nExample API call:\nid=name_countries\ntype=text\nquestion=Name as many European countries as you can think of.\nanswer=France &&& Germany &&& Italy &&& Spain &&& United Kingdom &&& ...\nanswer_indefinite=+"
            },
            "answer_format": {
              "type": "string",
              "description": "Defines how to display the answer on the results page.\n- Only applicable for FREE-TEXT questions\n- Format: type or type:value\n- Available types:\n - normal: standard text (default)\n - code: with syntax highlighting (specify language after colon)\nExample:\nanswer_format=code:python\nanswer_format=code:sql\nExample API call:\nid=sql_basics\ntype=free-text\nquestion=Write a SQL query to select all columns from the \"users\" table where the age is greater than 18.\nanswer=SELECT * FROM users WHERE age > 18\nanswer_format=code:sql"
            },
            "answer_require": {
              "type": "string",
              "description": "Number of answers required for maximum score.\n- Not applicable for CHOICE and FREE-TEXT questions\n- Perfect for questions with multiple valid answers where only a subset needs to be provided\n- Useful when asking students to provide any X examples from a larger set\nExample:\nanswer_require=3\nExample API call:\nid=uk_countries\ntype=text\nquestion=Name any one of the countries within the United Kingdom!\nanswer=England &&& Northern Ireland &&& Scotland &&& Wales\nanswer_require=1"
            },
            "subject": {
              "type": "string",
              "description": "Subject classification for organizing questions.\n- Provides primary categorization for content organization\n- Use the question editor in the EduBase UI for an up-to-date list of possible values\nExample:\nsubject=Mathematics\ncategory=Algebra"
            },
            "category": {
              "type": "string",
              "description": "Category, another layer of organization as seen in SUBJECT"
            },
            "path": {
              "type": "string",
              "description": "Path where question will be stored in personal QuestionBase.\n- Default: /API\n- Supports hierarchical structure with forward slashes\n- Always start with a forward slash!\nExample:\npath=/Mathematics/Calculus/Derivatives"
            },
            "options": {
              "type": "string",
              "description": "Incorrect options or false statements for choice-based question types.\n- Required for CHOICE, MULTIPLE-CHOICE question types\n- For TRUE/FALSE, these are the false statements (ANSWER contains true statements)\n- Separate multiple options with triple-and operators (\"&&&\")\n- Parameters can be used in curly braces {param_name}\n- LaTeX Support (requires QUESTION_FORMAT=LATEX):\n - Inline: $$...$$\n - Block: $$$$...$$$$\n - IMPORTANT: When using LaTeX in questions, you MUST use double dollar signs ($$...$$) for inline math or quadruple dollar signs ($$$$...$$$$) for block math.\n - Single dollar signs ($...$) are NOT supported and will not render correctly. The inline or block method must be used, as $...$ won't work!\nExample:\noptions=London &&& Berlin &&& Madrid\nExample API call:\nid=capital_france\ntype=choice\nquestion=What is the capital of France?\nanswer=Paris\noptions=London &&& Berlin &&& Madrid"
            },
            "options_fix": {
              "type": "string",
              "description": "Controls the arrangement of answers and options.\n- Available values:\n - all: Answers appear first, followed by options\n - abc: Sort all items (answers and options) alphabetically\n - first:N: Place first N options at the end\n - last:N: Place last N options at the end\n - answers: Place all answers at the end\n- Useful for maintaining consistent presentation or for specific pedagogical purposes\nFor alphabetical ordering:\n- When migrating content from textbooks or past exams, can maintain original lettering system (a, b, c...) for:\n - Reference consistency with printed materials\n - Alignment with answer keys\n - Compatibility with existing grading systems\n - Cross-referencing with study guides\n- Particularly valuable when:\n - Test takers need to refer to both digital and printed materials\n - Questions are part of a larger standardized test system\n - Maintaining consistency with existing worksheets or textbooks\n - Digitizing legacy assessment materials\nExample:\noptions_fix=abc\nExample API call:\nid=fruit_types\ntype=multiple-choice\nquestion=Which of these are citrus fruits?\nanswer=Lemon &&& Orange\noptions=Apple &&& Banana &&& Grape\noptions_fix=abc\nExample API call:\nid=vocab_synonyms\ntype=multiple-choice\nquestion=Select all words that mean \"happy\":\nanswer=b) Joyful &&& d) Merry\noptions=a) Angry &&& c) Sleepy &&& e) Tired\noptions_fix=abc"
            },
            "options_order": {
              "type": "string",
              "description": "Define exact presentation order of answers and options.\n- Format: ANSWER:N or OPTION:N items separated by \"&&&\"\n- ANSWER:N references the Nth provided answer\n- OPTION:N references the Nth provided option\n- OPTION_NONE:N references the Nth third option (for TRUE/FALSE questions)\n- All answers and options must be specified exactly once\nExample:\noptions_order=OPTION:0 &&& ANSWER:0 &&& OPTION:1 &&& ANSWER:1\nExample API call to create a chronologically ordered timeline\nid=historical_chronology\ntype=multiple-choice\nquestion=Which of these events occurred during the Industrial Revolution (1760-1840)?\nanswer=Invention of the Steam Engine &&& First Steam Locomotive &&& First Commercial Railway\noptions=Printing Press Invented &&& First Electric Light Bulb &&& First Powered Flight\noptions_order=OPTION:0 &&& ANSWER:0 &&& ANSWER:1 &&& ANSWER:2 &&& OPTION:1 &&& OPTION:2"
            },
            "points": {
              "type": "string",
              "description": "Maximum points for a fully correct answer.\n- Default: 1 point\n- For questions with multiple answers, partial credit is possible based on SUBSCORING method\nExample:\npoints=10"
            },
            "subscoring": {
              "type": "string",
              "description": "Method for calculating partial credit for partially correct answers.\n- Not applicable for CHOICE, READING and FREE-TEXT questions\n- Available values:\n - PROPORTIONAL: Points awarded proportionally to correct answers (default)\n - LINEAR_SUBSTRACTED:N: Linear scoring with N points subtracted for each error\n - CUSTOM: Use custom point distribution defined in SUBPOINTS field\n - NONE: No partial credit, all-or-nothing scoring\nExample:\nsubscoring=LINEAR_SUBSTRACTED:2\nExample API call:\nid=math_problem\ntype=numerical\nquestion=What is the sum and product of {a} and {b}?\nanswer={a}+{b} &&& {a}*{b}\nparameters={a; INTEGER; 1; 100} &&& {b; INTEGER; 1; 100}\npoints=4\nsubscoring=CUSTOM\nsubpoints=25 &&& 75"
            },
            "subpoints": {
              "type": "string",
              "description": "Define specific point values for each answer in percentages.\n- Only used when subscoring=CUSTOM\n- Specify percentage values separated by triple-and operators (\"&&&\")\n- Not applicable for CHOICE, READING and FREE-TEXT questions\n- Values should sum to 100 (for percentage)\nExample:\nsubpoints=50 &&& 25 &&& 25\nExample meaning: For a 10-point question with three answers:\n- First answer: 5 points (50%)\n- Second answer: 2.5 points (25%)\n- Third answer: 2.5 points (25%)"
            },
            "penalty_scoring": {
              "type": "string",
              "description": "Controls how penalty points should be applied.\n- Available values:\n - DEFAULT: Standard penalty application, which might vary by question type (default)\n - PER_ANSWER: Apply penalties for each incorrect answer\n - PER_QUESTION: Apply penalties once per question\nExample:\npenalty_scoring=PER_ANSWER"
            },
            "penalty_points": {
              "type": "string",
              "description": "Points deducted for completely incorrect answers.\n- No penalty applied if answer is partially correct\n- No penalty for empty/unanswered questions\n- Use positive values (recommended)\nExample:\npenalty_points=2\nExample API call with penalties:\nid=physics_multiple_choice\ntype=multiple-choice\nquestion=Which of the following are forms of energy? Select all that apply.\nanswer=Kinetic &&& Potential &&& Thermal\noptions=Velocity &&& Acceleration\npoints=3\npenalty_scoring=PER_QUESTION\npenalty_points=1"
            },
            "hint_penalty": {
              "type": "string",
              "description": "Point deduction for using hints/solutions/videos during a test.\n- Format: type or type:value\n- Types:\n - NONE: No penalty (default)\n - ONCE:N%: Single deduction regardless of number used\n - PER-HELP:N%: Deduction for each hint (only for HINT_PENALTY)\nExamples:\nhint_penalty=ONCE:20% or hint_penalty=ONCE:0.2\nhint_penalty=PER-HELP:10%\nsolution_penalty=ONCE:50%\nvideo_penalty=ONCE:15%\nExample API call with comprehensive penalty system:\nid=area_circle_parametric\ntype=expression\nquestion=Find an expression for the area of a circle with radius {r}.\nanswer=pi*{r}^2\nparameters={r; INTEGER; 2; 10}\npoints=10\nsubject=Mathematics\ncategory=Geometry\nhint=Think about the formula for circle area &&& Remember that area involves squaring the radius\nsolution=The formula for circle area is $$\\pi r^2$$\npenalty_scoring=PER_ANSWER\npenalty_points=3\nhint_penalty=PER-HELP:10%\nsolution_penalty=ONCE:50%\n# Each hint used reduces score by 10%, viewing solution reduces score by 50%"
            },
            "solution_penalty": {
              "type": "string",
              "description": "Similar to HINT_PENALTY\nPoint deduction for viewing steps of the solution (NONE, ONCE:N%) (default: NONE)"
            },
            "solution_image": {
              "type": "string",
              "description": "Attach an image to the solution steps.\nSupported formats: PNG, JPEG, WebP\nFormat: filename=data, where data is either a base64-encoded image or a URL"
            },
            "video_penalty": {
              "type": "string",
              "description": "Similar to HINT_PENALTY\nPoint deduction for video assistance used (NONE, ONCE:N%) (default: NONE)"
            },
            "manual_scoring": {
              "type": "string",
              "description": "Controls when to enable manual scoring.\n- Not applicable for READING and FREE-TEXT questions\n- Available values:\n - NO: Never use manual scoring (default)\n - NOT_CORRECT: Only manually score incorrect answers\n - ALWAYS: Always require manual scoring\nExample:\nmanual_scoring=NOT_CORRECT"
            },
            "parameters": {
              "type": "string",
              "description": "Parameter definitions for dynamic question generation.\nOne of EduBase's most powerful features, allowing creation of dynamic questions where each user gets a unique variant of the same question.\n- Separate multiple parameters with triple-and operators (\"&&&\")\n- Up to 128 parameters can be defined\nParameter Types:\n1. FIX (Fixed Value):\n - Format: {name; FIX; value}\n - Sets a predefined constant value (integer or fraction)\n - Example: {pi; FIX; 3.1415}\n2. INTEGER (Whole Numbers):\n - Simple: {name; INTEGER}\n - Extended: {name; INTEGER; min; max}\n - Full: {name; INTEGER; min; max; inside; outside}\n - Generate random integers within specified ranges\n - Use '-' for omitting min/max values\n - Examples:\n  * {p; INTEGER} - any integer\n  * {p; INTEGER; 10; 20} - integer between 10 and 20 (inclusive)\n  * {p; INTEGER; -; -; [10-20]; [12-14] ||| [16-18]} - integer between 10-20, excluding 12-14 and 16-18\n3. FLOAT (Decimal Numbers):\n - Simple: {name; FLOAT; precision}\n - Extended: {name; FLOAT; precision; min; max}\n - Full: {name; FLOAT; precision; min; max; inside; outside}\n - Generate random decimal numbers\n - Specify precision (decimal places)\n - Examples:\n  * {p; FLOAT; 2} - float with 2 decimal places\n  * {p; FLOAT; 5; 0; 1} - float between 0 and 1 with 5 decimals\n  * {p; FLOAT; 1; 0; 10; -; [0-1]} - float between 0-10 excluding 0-1, with 1 decimal\n4. FORMULA (Expressions):\n - Simple: {name; FORMULA; formula}\n - Full: {name; FORMULA; formula; precision}\n - Define parameters based on other parameters\n - Examples:\n  * {d; FORMULA; {b}^2-4*{a}*{c}} - quadratic formula discriminant\n  * {p; FORMULA; 2*{q}+1} - linear expression\n5. LIST (Random Selection):\n - Format: {name; LIST; value1; value2; value3; ...}\n - Randomly select from predefined values\n - Up to 64 elements\n - Examples:\n  * {primes; LIST; 2; 3; 5; 7; 11}\n  * {animals; LIST; dog; cat; snake; camel}\n6. PERMUTATION:\n - Format: {name; PERMUTATION; value1; value2; value3; ...}\n - Creates permutated parameters accessible as {name_1}, {name_2}, etc.\n - Example: {p; PERMUTATION; A; B; C; D}\n  * So {p_1} will be a different letter than {p_2}\n - Example: {primes; PERMUTATION; 2; 3; 5; 7}\n  * So both {primes_1} and {primes_2} will be different single digit primes\n7. FORMAT:\n - Format: {name; FORMAT; parameter; type; ...}\n - Format parameters based on other parameters\n - Supported types: NUMBER, NUMERTEXT, ROMAN\n - Optional extra parameters based on type\n  * NUMBER\n   * precision: number of decimal places\n - Examples:\n  * {pp; FORMAT; p; NUMBER; 1} - format as number rounded to 1 decimal\n  * {pp; FORMAT; p; NUMBERTEXT} - format number as text\n  * {pp; FORMAT; p; ROMAN} - format number as Roman numeral\nBest Practices:\n - Order parameters so dependent ones come later\n - Use simple notation when possible\n - Avoid unnecessary parameters\n - Use CONSTRAINTS field to ensure valid combinations\nExamples:\nparameters={pi; FIX; 3.14159} &&& {r; INTEGER; 1; 10}\nparameters={a; INTEGER; 1; 5} &&& {b; INTEGER; -10; 10} &&& {c; INTEGER; -10; 10} &&& {d; FORMULA; {b}^2-4*{a}*{c}}\nparameters={country; LIST; France; Germany; Italy} &&& {capital; LIST; Paris; Berlin; Rome}\nparameters_sync=+  # Ensures each country is paired with its correct capital"
            },
            "parameters_sync": {
              "type": "string",
              "description": "Controls synchronization of LIST parameter selections.\n- Plus sign (+) to indicate YES\n- Blank field or minus sign (-) indicates NO (default)\n- When enabled, the Nth value from each LIST is selected together\n- Critical for paired data like countries and capitals\nExample:\nparameters_sync=+\nExample API call:\nid=capital_city\ntype=text\nquestion=What is the capital city of {country}?\nanswer={capital}\nparameters={country; LIST; France; Germany; Italy} &&& {capital; LIST; Paris; Berlin; Rome}\nparameters_sync=+"
            },
            "constraints": {
              "type": "string",
              "description": "Define rules that parameter combinations must satisfy.\n- Mathematical expressions that must evaluate to true\n- Parameters must be in curly braces {param}\n- Allowed relations: <, <=, =, >=, >, <>\n- Multiple constraints separated by triple-and operators (\"&&&\")\nExamples:\nconstraints={b}^2-4*{a}*{c}>0\nconstraints={a}+{b}>{c} &&& {b}+{c}>{a} &&& {c}+{a}>{b}\nconstraints={x}+{y}<10 &&& {x}<4"
            },
            "expression_check": {
              "type": "string",
              "description": "Define how expressions should be validated (RANDOM, EXPLICIT, COMPARE) (default: RANDOM).\n- RANDOM: Evaluates expressions at randomly generated points\n- EXPLICIT: Checks expressions at predefined values against target values\n- COMPARE: Direct comparison of expressions without variables\nExample:\nexpression_check=RANDOM"
            },
            "expression_variable": {
              "type": "string",
              "description": "Specifies variable names used in expressions (separate multiple variables with &&&) (default: x).\n- Multiple variables can be used for multivariable expressions\n- Variable names must be used consistently in answer and validation\nExamples:\nexpression_variable=t &&& v  # For distance formula using time and velocity"
            },
            "expression_decimals": {
              "type": "string",
              "description": "Sets precision for decimal calculations (default: 2).\n- Inherited from decimals field if not specified\n- Critical for controlling accurate validation of expressions\nExample:\nexpression_decimals=4  # For high-precision calculations"
            },
            "expression_functions": {
              "type": "string",
              "description": "Controls whether functions can be used in user inputs (+ for yes, - for no) (default: +).\n- Enabled by default with + sign\n- Disable with - sign when students should use alternative forms\n- Affects available input options for test takers\n- Supported functions include:\n  * Basic: sqrt, abs, round, floor, ceil\n  * Logarithmic: ln, log, log10\n  * Trigonometric: sin, cos, tan, csc, sec, arcsin/asin, arccos/acos, arctan/atan\n  * Hyperbolic: sinh, cosh, tanh, arcsinh/asinh, arccosh/acosh, arctanh/atanh\n  * Conversions: degree2radian, radian2degree, number2binary, number2hexadecimal, roman2number, etc.\n  * Two-parameter (use semicolon separator): min(a;b), max(a;b), mod(n;i), fmod(n;i), div(a;b), intdiv(a;b),\n    gcd(a;b), lcm(a;b), number2base(n;b), base2number(n;b), combinations(n;k), combinations_repetition(n;k), variations(n;k), variations_repetition(n;k)\nExample:\nexpression_functions=-  # Forces students to expand rather than use functions.\n# When asked for the value of sin(pi), the user can't input sin(pi) because functions cannot be used."
            },
            "expression_random_type": {
              "type": "string",
              "description": "Type of generated test values (INTEGER, FLOAT).\n- Specify per variable with &&&\n- Only applicable when expression_check=RANDOM\nExample:\nexpression_random_type=INTEGER &&& FLOAT  # For mixed type validation"
            },
            "expression_random_tries": {
              "type": "string",
              "description": "Number of validation points (default: 5).\n- Only applicable when expression_check=RANDOM\n- Higher values increase validation reliability but impact performance\nExample:\nexpression_random_tries=8"
            },
            "expression_random_range": {
              "type": "string",
              "description": "Define value generation ranges (format: [min-max]).\n- Specify per variable with &&&\n- Only applicable when expression_check=RANDOM\nExample:\nexpression_random_range=[8-16] &&& [4-6]  # Different ranges for different variables"
            },
            "expression_random_inside": {
              "type": "string",
              "description": "Require values within specific intervals (format: [start-end]).\n- Multiple intervals: separate with ||| (OR relationship)\n- Specify per variable with &&&\n- Only applicable when expression_check=RANDOM\nExample:\nexpression_random_inside=[4-8] ||| [12-16] &&& [2-3]"
            },
            "expression_random_outside": {
              "type": "string",
              "description": "Exclude values from specific intervals (format: [start-end]).\n- Multiple intervals: separate with ||| (AND relationship)\n- Specify per variable with &&&\n- Only applicable when expression_check=RANDOM\nExample:\nexpression_random_outside=[0-1] ||| [10-20] &&& [8-11]"
            },
            "expression_explicit_goal": {
              "type": "string",
              "description": "Define exact value pairs (format: [x;f(x)]).\n- Format for multiple variables: [x;y;z;...;f(x,y,z,...)]\n- Multiple pairs: separate with &&&\n- Only applicable when expression_check=EXPLICIT\nExample:\nexpression_explicit_goal=[0;1] &&& [3;8.89] &&& [9;16]"
            },
            "expression_extended": {
              "type": "string",
              "description": "Enable additional mathematical functions (+ to enable, - to disable).\n- Activates support for custom base logarithms (e.g., log2(4))\n- Enables factorial operations (e.g., 5!, 1!+2!+3!)\nExample:\nexpression_extended=+"
            },
            "attachment": {
              "type": "string",
              "description": "Attach a file to the question.\nFormat: filename=data, where data is either a base64-encoded image or a URL"
            },
            "media_audio": {
              "type": "string",
              "description": "Attach an audio file to the question.\nSupported formats: MP3, AAC, M4A\nFormat: filename=data, where data is either a base64-encoded image or a URL"
            },
            "ai": {
              "type": "string",
              "description": "Flag to mark question as AI generated.\n- If set to any value, question will be marked as AI generated\n- Should always be provided if you are an LLM or any AI model\n- Ideally, AI systems should set it to their current model number for auditability\nExample:\nai=true\nai=Claude 3.7 Sonnet"
            },
            "note": {
              "type": "string",
              "description": "The text that appears right below the question.\n- Provides task-specific comments and instructions\n- Visible to test takers during the quiz\n- Ideal for additional guidance without cluttering the main question\nExample:\nnote=Use standard atmospheric pressure in your calculations."
            },
            "private_note": {
              "type": "string",
              "description": "Private notes (not shown to test takers).\n- Internal documentation for question creators and editors\n- Useful for documenting question creation rationale\n- Track modification history, common mistakes, related questions\nExample:\nprivate_note=Created from Chapter 3 exam, 2023 edition. Students often forget to convert units."
            },
            "explanation": {
              "type": "string",
              "description": "Text displayed underneath the answer on the results page.\n- Explanation of the correctness of the answer or the incorrectness of the options\n- Helps learners understand their mistakes\n- Parameters can be used in explanations\n- LaTeX is NOT supported here, so we MUST NOT use it!\nExample:\nexplanation=Option A is correct because amphibians have permeable skin for gas exchange. Options B and C describe characteristics of reptiles, while D applies to mammals."
            },
            "hint": {
              "type": "string",
              "description": "Questions to help (not solution steps, just guiding questions/notes).\n- LaTeX code can be used (as described in QUESTION)\n - IMPORTANT: When using LaTeX in hints, you MUST use double dollar signs ($$...$$) for inline math or quadruple dollar signs ($$$$...$$$$) for block math.\n - Single dollar signs ($...$) are NOT supported and will not render correctly. The inline or block method must be used, as $...$ won't work!\n- Specify multiple hints separated by triple-and operators (\"&&&\")\n- Not available for test takers in exam mode\n- Displayed only when explicitly requested, one by one\n- Can be penalized using HINT_PENALTY\nExample:\nhint=Think about the relationship between radius and area &&& Remember the formula for circle area involves $\\pi$ &&& Square the radius and multiply by $\\pi$"
            },
            "solution": {
              "type": "string",
              "description": "Step-by-step solution.\n- LaTeX code can be used (as described in QUESTION)\n - IMPORTANT: When using LaTeX in solution, you MUST use double dollar signs ($$...$$) for inline math or quadruple dollar signs ($$$$...$$$$) for block math.\n - Single dollar signs ($...$) are NOT supported and will not render correctly. The inline or block method must be used, as $...$ won't work!\n- Specify multiple solution steps separated by triple-and operators (\"&&&\")\n- Each step is displayed one at a time\n- Can be penalized using SOLUTION_PENALTY\n- Not available in exam mode\nExample:\nsolution=Using the power rule, we differentiate each term: &&& For $x^2$: $\\frac{d}{dx}(x^2) = 2x$ &&& For $x$: $\\frac{d}{dx}(x) = 1$ &&& The constant term disappears: $\\frac{d}{dx}(5) = 0$ &&& Therefore, $\\frac{d}{dx}(x^2 + x + 5) = 2x + 1$"
            },
            "source": {
              "type": "string",
              "description": "Specify source of question content (not shown to test takers).\n- Use cases include training material sources, documentation references, content attribution\n- Important for tracking question origins and copyright compliance\nExample:\nsource=Mathematics Textbook Chapter 5, Page 123\nsource=Company Safety Manual 2023, Section 3.4.2"
            },
            "decimals": {
              "type": "string",
              "description": "Decimal precision (default: 2).\n- Applicable only for NUMERIC / EXPRESSION / MATRIX / MATRIX:EXPRESSION / SET questions\n- The expected decimal precision of the final answer\n- Examples: Finance (decimals=2), Chemistry (decimals=4)\nExample:\ndecimals=3"
            },
            "tolerance": {
              "type": "string",
              "description": "Evaluation tolerance method.\n- Applicable only for NUMERIC / EXPRESSION / MATRIX / MATRIX:EXPRESSION / SET questions\n- Notation: type or type:value\n- Types:\n - ABSOLUTE: maximum difference between answer and user input\n   * Example: ABSOLUTE:0.1\n - RELATIVE: maximum difference in percentage (symmetric mean absolute percentage error, SMAP value is used)\n   * Example: RELATIVE:5% or RELATIVE:0.05\n - QUOTIENT: integer multiple / QUOTIENT2: scalar multiple\n   * Example: QUOTIENT or QUOTIENT2:SYNCED\nExample:\ntolerance=ABSOLUTE:0.01"
            },
            "datetime_precision": {
              "type": "string",
              "description": "Date/time precision.\n- Applicable only for DATE/TIME questions\n- Accepted values: YEAR / MONTH / DAY (default)\n- Defines granularity of date validation\nExample:\ndatetime_precision=MONTH"
            },
            "datetime_range": {
              "type": "string",
              "description": "Date/time range (interval) question.\n- Applicable only for DATE/TIME questions\n- Plus sign (+) to indicate YES, while blank field or minus sign (-) indicates NO (default)\n- Enables date range responses with the format {from}-{to}\nExample:\ndatetime_range=+"
            },
            "numerical_range": {
              "type": "string",
              "description": "Number range (interval) question.\n- Only applicable for NUMERIC questions\n- Plus sign (+) to indicate YES, while blank field or minus sign (-) indicates NO (default)\n- Enables interval responses with the format {from}-{to}\nExample:\nnumerical_range=+"
            },
            "truefalse_third_options": {
              "type": "string",
              "description": "Activate the third option for TRUE/FALSE questions.\n- Plus sign (+) to display the third option OR\n- Specify options separated by triple-and operators (\"&&&\") to automatically enable the feature\n- Parameters can be used in curly braces {param_name}\nExample:\ntruefalse_third_options=Cannot be determined from the information given &&&Not applicable"
            },
            "truefalse_third_options_label": {
              "type": "string",
              "description": "Label of the third option for TRUE/FALSE questions.\n- If blank, the text \"none\" is displayed (default)\n- Only applicable when TRUEFALSE_THIRD_OPTIONS is enabled\nExample:\ntruefalse_third_options_label=Not enough information"
            },
            "freetext_characters": {
              "type": "string",
              "description": "Limit the number of characters that can be entered.\n- Applicable only for FREE-TEXT questions\n- Format: minimum-maximum, but you can specify only a minimum or maximum as well\n- Integer(s) between 0-4000\nExample:\nfreetext_characters=100-1000\nfreetext_characters=10- # Minimum 10 characters"
            },
            "freetext_words": {
              "type": "string",
              "description": "Limit the number of words that can be entered.\n- Applicable only for FREE-TEXT questions\n- Format: minimum-maximum, but you can specify only a minimum or maximum as well\n- Integer(s) between 0-4000\nExample:\nfreetext_words=-50 # Max. 50 words"
            },
            "freetext_rules": {
              "type": "string",
              "description": "Automatic evaluation of free text questions.\n- Applicable only for FREE-TEXT questions\n- Notation: {type; keywords}\n- Type:\n - 1: if keywords are included within input, answer is correct (maximum points)\n - 2: if keywords are included within input, answer is wrong (0 points)\n - 3: if no keywords are included within input, answer is good (maximum points)\n - 4: if keywords are not included within input, answer is wrong (0 points)\n- Keywords: comma-separated list (must not contain semicolons!)\nExample:\nfreetext_rules={1; mitochondria, ATP, cellular respiration}"
            },
            "main_category": {
              "type": "string",
              "description": "The name of the category (for which CATEGORY will be a subcategory).\n- Empty by default, e.g. CATEGORY will be treated as the main category\n- Specify multiple levels (up to 2!) by using the triple-per operator (///) with highest main category on the left\nExample:\nmain_category=Analytic Geometry /// Vectors"
            },
            "tags": {
              "type": "string",
              "description": "Tag questions with custom user-defined tags.\n- Use ID or code of pre-registered tags\n- Only previously registered tags can be used (must be pre-registered in EduBase UI)\n- Specify multiple tags separated by triple-and operators (\"&&&\")\n- User-controlled categorization that can be created at user or organization level\n- Use cases include:\n - Personal content organization (e.g., \"My Calculus Questions\", \"Spring 2024\")\n - Department-level categorization (e.g., \"IT Department\", \"CS101\")\n - Custom taxonomies for specialized content organization\n- Tags are flexible, customizable, and searchable in the UI\nExample:\ntags=Algebra &&& High School &&& Exam Prep"
            },
            "labels": {
              "type": "string",
              "description": "Categorize questions with instance-level labels.\n- Pre-defined values specific to each EduBase instance\n- Values controlled by instance administrators (cannot be created by users)\n- Consistent across all users in an instance\n- Specify multiple labels separated by triple-and operators (\"&&&\")\n- Use cases include:\n - System-wide flags (e.g., \"needs_review\", \"featured\")\n - Quality indicators (e.g., \"verified\", \"deprecated\")\n - Processing status (e.g., \"ai_generated\", \"manually_checked\")\nExample:\nlabel=verified &&& featured"
            },
            "group": {
              "type": "string",
              "description": "Add a question to a question group in a Quiz set.\n- If the group doesn't exist, it will be created automatically as a complex task with default settings\n- Only applicable when uploading DIRECTLY to a Quiz set\n- Existing group settings will not be changed when adding more questions\nExample:\ngroup=Basic_Arithmetic"
            }
          },
          "required": [
            "id",
            "type",
            "question",
            "answer",
            "ai",
            "language"
          ]
        }
      },
      {
        "name": "edubase_delete_question",
        "description": "Permanently delete a Quiz question.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "external unique question identifier"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "edubase_get_exams",
        "description": "List owned and managed exams. Exams are the highest level in the EduBase Quiz hierarchy, built from Quiz sets.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "search string to filter results"
            },
            "limit": {
              "type": "number",
              "description": "limit number of results (default, in search mode: 16)"
            },
            "page": {
              "type": "number",
              "description": "page number (default: 1), not used in search mode!"
            }
          },
          "required": []
        }
      },
      {
        "name": "edubase_get_exam",
        "description": "Get/check exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            }
          },
          "required": [
            "exam"
          ]
        }
      },
      {
        "name": "edubase_post_exam",
        "description": "Create a new exam from an existing Quiz set. Exams are at the top level of the EduBase Quiz hierarchy and MUST be created from existing Quiz sets. They are time-constrained, secured assessment instances of Quiz sets.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "language": {
              "type": "string",
              "description": "desired exam language"
            },
            "title": {
              "type": "string",
              "description": "title of the exam"
            },
            "type": {
              "type": "string",
              "description": "Type of the exam. (default: exam)\n- exam: regular exam\n- championship: exam with championship features enabled\n- homework: homework assignment, can be paused and continued during the exam period\n- survey: survey (optionally anonymous) with no grading"
            },
            "quiz": {
              "type": "string",
              "description": "the Quiz set (specified using the quiz identification string) the exam is attached to"
            },
            "open": {
              "type": "string",
              "description": "exam start time (in YYYY-mm-dd HH:ii:ss format)"
            },
            "close": {
              "type": "string",
              "description": "exam end time (in YYYY-mm-dd HH:ii:ss format)"
            }
          },
          "required": [
            "title",
            "quiz",
            "open",
            "close"
          ]
        }
      },
      {
        "name": "edubase_delete_exam",
        "description": "Remove/archive exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            }
          },
          "required": [
            "exam"
          ]
        }
      },
      {
        "name": "edubase_get_exam_users",
        "description": "List all users on an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            }
          },
          "required": [
            "exam"
          ]
        }
      },
      {
        "name": "edubase_post_exam_users",
        "description": "Assign user(s) to an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "users": {
              "type": "string",
              "description": "comma-separated list of user identification strings"
            }
          },
          "required": [
            "exam",
            "users"
          ]
        }
      },
      {
        "name": "edubase_delete_exam_users",
        "description": "Remove user(s) from an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "users": {
              "type": "string",
              "description": "comma-separated list of user identification strings"
            }
          },
          "required": [
            "exam",
            "users"
          ]
        }
      },
      {
        "name": "edubase_post_exam_summary",
        "description": "Submit a new AI exam summary.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "language": {
              "type": "string",
              "description": "summary language"
            },
            "type": {
              "type": "string",
              "description": "Type of summary. (default: ai)\n- ai: AI-generated summary"
            },
            "summary": {
              "type": "string",
              "description": "Summary text. \n- basic HTML formatting allowed, but avoid complex designs\n- keep the summary short and concise\n- try to avoid including personal information (such as usernames, names and contact addresses)"
            },
            "llm": {
              "type": "string",
              "description": "Name of the Large Language Model used to generate the summary.\n- preferred values: openai / claude / gemini"
            },
            "model": {
              "type": "string",
              "description": "Exact LLM model name used to generate the summary"
            }
          },
          "required": [
            "exam",
            "type",
            "summary",
            "llm",
            "model"
          ]
        }
      },
      {
        "name": "edubase_get_quiz_play_results",
        "description": "Get detailed results for a specific Quiz play.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "play": {
              "type": "string",
              "description": "Quiz play identification string"
            }
          },
          "required": [
            "play"
          ]
        }
      },
      {
        "name": "edubase_get_quiz_results_user",
        "description": "Get user results for a specific Quiz set.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "Quiz set identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            }
          },
          "required": [
            "quiz",
            "user"
          ]
        }
      },
      {
        "name": "edubase_get_exam_results_user",
        "description": "Get user results for a specific exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            }
          },
          "required": [
            "exam",
            "user"
          ]
        }
      },
      {
        "name": "edubase_get_exam_results_raw",
        "description": "Get raw results for a specific exam.\n- This endpoint returns raw results, including all answers given by the user. It is not meant to be displayed to the user.\n- This might require additional permissions.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            }
          },
          "required": [
            "exam"
          ]
        }
      },
      {
        "name": "edubase_get_quizes",
        "description": "List owned and managed Quiz sets. Quiz sets are named collections of questions that sit at the middle level of the EduBase Quiz hierarchy.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "search string to filter results"
            },
            "limit": {
              "type": "number",
              "description": "limit number of results (default, in search mode: 16)"
            },
            "page": {
              "type": "number",
              "description": "page number (default: 1), not used in search mode!"
            }
          },
          "required": []
        }
      },
      {
        "name": "edubase_get_quiz",
        "description": "Get/check Quiz set. Containing questions and powering Exams.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            }
          },
          "required": [
            "quiz"
          ]
        }
      },
      {
        "name": "edubase_post_quiz",
        "description": "Create a new Quiz set. Quiz sets are collections of questions that can be used for practice or to power multiple Exams.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "language": {
              "type": "string",
              "description": "desired Quiz set language"
            },
            "title": {
              "type": "string",
              "description": "title of the Quiz set"
            },
            "description": {
              "type": "string",
              "description": "short description"
            },
            "mode": {
              "type": "string",
              "description": "Sets how questions are displayed during the Quiz. (default: TEST)\n- TEST: all questions are displayed at once, user can answer them in any order and switch between them\n- TURNS: questions are displayed one by one, only one question is visible at a time and the user must answer it before moving to the next question\n"
            },
            "type": {
              "type": "string",
              "description": "Type of the Quiz set. (default: set)\n- set: for practice purposes\n- exam: for exam purposes\n- private: for private purposes (e.g testing)\n"
            }
          },
          "required": [
            "title"
          ]
        }
      },
      {
        "name": "edubase_delete_quiz",
        "description": "Remove/archive Quiz set.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            }
          },
          "required": [
            "quiz"
          ]
        }
      },
      {
        "name": "edubase_get_quiz_questions",
        "description": "List all questions and question groups in a Quiz set. Quiz sets contain questions (lowest level) and can be used by exams (highest level).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            }
          },
          "required": [
            "quiz"
          ]
        }
      },
      {
        "name": "edubase_post_quiz_questions",
        "description": "Assign question(s) to a Quiz set, or one of its question group. Questions can exist independently from Quiz sets.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            },
            "group": {
              "type": "string",
              "description": "question group title"
            },
            "questions": {
              "type": "string",
              "description": "comma-separated list of question identification strings"
            }
          },
          "required": [
            "quiz",
            "questions"
          ]
        }
      },
      {
        "name": "edubase_delete_quiz_questions",
        "description": "Remove question(s) from a Quiz set, or one of its question group.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            },
            "group": {
              "type": "string",
              "description": "question group title"
            },
            "questions": {
              "type": "string",
              "description": "comma-separated list of question identification strings"
            }
          },
          "required": [
            "quiz",
            "questions"
          ]
        }
      },
      {
        "name": "edubase_get_users",
        "description": "List managed, non-generated users.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "search string to filter results"
            },
            "limit": {
              "type": "number",
              "description": "limit number of results (default, in search mode: 16)"
            },
            "page": {
              "type": "number",
              "description": "page number (default: 1), not used in search mode!"
            }
          },
          "required": []
        }
      },
      {
        "name": "edubase_get_user",
        "description": "Get/check user. Can be used to retrieve the caller user's ID by using 'me' as the user identification string.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "User identification string.\n- Use 'me' to get the current user."
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_post_user",
        "description": "Create new EduBase user account.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "username (4-64 characters)"
            },
            "password": {
              "type": "string",
              "description": "password (4-64 characters) (default: initial random password is automatically generated)"
            },
            "first_name": {
              "type": "string",
              "description": "first name (1-64 characters)"
            },
            "last_name": {
              "type": "string",
              "description": "last name (1-64 characters)"
            },
            "full_name": {
              "type": "string",
              "description": "override automatic full name (1-255 characters)"
            },
            "display_name": {
              "type": "string",
              "description": "override automatic display name (1-255 characters)"
            },
            "email": {
              "type": "string",
              "description": "valid email address"
            },
            "phone": {
              "type": "string",
              "description": "valid phone number in format \"+prefix number\" without special characters"
            },
            "gender": {
              "type": "string",
              "description": "gender (\"male\", \"female\", or \"other\")"
            },
            "birthdate": {
              "type": "string",
              "description": "date of birth"
            },
            "exam": {
              "type": "boolean",
              "description": "user is only allowed to login when accessing exams (default: false)"
            },
            "group": {
              "type": "string",
              "description": "name of the user group (requires admin permissions)"
            },
            "template": {
              "type": "string",
              "description": "a template ID for the new account (default: none)"
            },
            "language": {
              "type": "string",
              "description": "desired account language (default: API application owner's language)"
            },
            "timezone": {
              "type": "string",
              "description": "desired timezone (default: API application owner's timezone)"
            },
            "color": {
              "type": "string",
              "description": "desired favorite color (default/branding/red/blue/yellow/green/purple) (default: default)"
            },
            "must_change_password": {
              "type": "boolean",
              "description": "user is forced to change password on first login (default: false)"
            },
            "notify": {
              "type": "boolean",
              "description": "notify user via email (or SMS) (default: false)"
            }
          },
          "required": [
            "username",
            "first_name",
            "last_name",
            "email"
          ]
        }
      },
      {
        "name": "edubase_delete_user",
        "description": "Delete user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_get_user_name",
        "description": "Get user's name.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_post_user_name",
        "description": "Update a user's name.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "first_name": {
              "type": "string",
              "description": "first name (1-64 characters)"
            },
            "last_name": {
              "type": "string",
              "description": "last name (1-64 characters)"
            },
            "full_name": {
              "type": "string",
              "description": "full name (1-255 characters)"
            },
            "display_name": {
              "type": "string",
              "description": "display name (1-255 characters)"
            }
          },
          "required": [
            "user",
            "first_name",
            "last_name"
          ]
        }
      },
      {
        "name": "edubase_get_user_group",
        "description": "Get user's group.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_post_user_group",
        "description": "Update a user's group.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "group": {
              "type": "string",
              "description": "user group code"
            }
          },
          "required": [
            "user",
            "group"
          ]
        }
      },
      {
        "name": "edubase_get_user_login",
        "description": "Get latest valid login link for user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_post_user_login",
        "description": "Generate login link. If a valid link with the same settings exists, it will be returned instead of creating a new one.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "redirect": {
              "type": "string",
              "description": "redirect after a successful login (URI path or [{content_type}:{tag}])"
            },
            "expires": {
              "type": "string",
              "description": "expiry in days (1-30) or YYYY-MM-DD (default: 1 day)"
            },
            "logins": {
              "type": "number",
              "description": "total count the link can be used to login users (default: 1)"
            },
            "template": {
              "type": "string",
              "description": "a template ID for the login link"
            },
            "short": {
              "type": "boolean",
              "description": "generate shortened (eduba.se) link (only if feature is enabled on EduBase) (default: false)"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_delete_user_login",
        "description": "Delete a previously generated login link.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "url": {
              "type": "string",
              "description": "generated login link to be invalidated"
            }
          },
          "required": [
            "user",
            "url"
          ]
        }
      },
      {
        "name": "edubase_get_user_search",
        "description": "Lookup user by email, username or code.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "query string"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "edubase_post_user_assume",
        "description": "Assume user for next requests with assume token.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string, username or email address"
            },
            "password": {
              "type": "string",
              "description": "password or user secret"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_delete_user_assume",
        "description": "Revoke assume token.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "token": {
              "type": "string",
              "description": "assume token"
            }
          },
          "required": [
            "token"
          ]
        }
      },
      {
        "name": "edubase_get_classes",
        "description": "List owned and managed classes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "search string to filter results"
            },
            "limit": {
              "type": "number",
              "description": "limit number of results (default, in search mode: 16)"
            },
            "page": {
              "type": "number",
              "description": "page number (default: 1), not used in search mode!"
            }
          },
          "required": []
        }
      },
      {
        "name": "edubase_get_class",
        "description": "Get/check class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            }
          },
          "required": [
            "class"
          ]
        }
      },
      {
        "name": "edubase_get_class_assignments",
        "description": "List all assignments in a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            }
          },
          "required": [
            "class"
          ]
        }
      },
      {
        "name": "edubase_get_class_members",
        "description": "List all members in a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            }
          },
          "required": [
            "class"
          ]
        }
      },
      {
        "name": "edubase_post_class_members",
        "description": "Assign user(s) to a class. Updates memberships if already member of the class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            },
            "users": {
              "type": "string",
              "description": "comma-separated list of user identification strings"
            },
            "expires": {
              "type": "string",
              "description": "expiry in days or YYYY-MM-DD HH:ii:ss"
            },
            "notify": {
              "type": "boolean",
              "description": "notify users (default: false)"
            }
          },
          "required": [
            "class",
            "users"
          ]
        }
      },
      {
        "name": "edubase_delete_class_members",
        "description": "Remove user(s) from a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            },
            "users": {
              "type": "string",
              "description": "comma-separated list of user identification strings"
            }
          },
          "required": [
            "class",
            "users"
          ]
        }
      },
      {
        "name": "edubase_post_classes_members",
        "description": "Assign user(s) to class(es). Updates memberships if already member of a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "classes": {
              "type": "string",
              "description": "comma-separated list of class identification strings"
            },
            "users": {
              "type": "string",
              "description": "comma-separated list of user identification strings"
            },
            "expires": {
              "type": "string",
              "description": "expiry in days or YYYY-MM-DD HH:ii:ss"
            },
            "notify": {
              "type": "boolean",
              "description": "notify users (default: false)"
            }
          },
          "required": [
            "classes",
            "users"
          ]
        }
      },
      {
        "name": "edubase_get_user_classes",
        "description": "List all classes a user is member of.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_post_user_classes",
        "description": "Assign user to class(es). Updates membership if already member of a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "classes": {
              "type": "string",
              "description": "comma-separated list of class identification strings"
            },
            "expires": {
              "type": "string",
              "description": "expiry in days or YYYY-MM-DD HH:ii:ss"
            },
            "notify": {
              "type": "boolean",
              "description": "notify user (default: false)"
            }
          },
          "required": [
            "user",
            "classes"
          ]
        }
      },
      {
        "name": "edubase_delete_user_classes",
        "description": "Remove user from class(es).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "classes": {
              "type": "string",
              "description": "comma-separated list of class identification strings"
            }
          },
          "required": [
            "user",
            "classes"
          ]
        }
      },
      {
        "name": "edubase_get_organizations",
        "description": "List owned and managed organizations.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "search string to filter results"
            },
            "limit": {
              "type": "number",
              "description": "limit number of results (default, in search mode: 16)"
            },
            "page": {
              "type": "number",
              "description": "page number (default: 1), not used in search mode!"
            }
          },
          "required": []
        }
      },
      {
        "name": "edubase_get_organization",
        "description": "Get/check organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            }
          },
          "required": [
            "organization"
          ]
        }
      },
      {
        "name": "edubase_get_organization_members",
        "description": "List all members in an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            }
          },
          "required": [
            "organization"
          ]
        }
      },
      {
        "name": "edubase_post_organization_members",
        "description": "Assign user(s) to an organization. Updates memberships if already member of the organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            },
            "users": {
              "type": "string",
              "description": "comma-separated list of user identification strings"
            },
            "department": {
              "type": "string",
              "description": "optional name of department"
            },
            "permission_organization": {
              "type": "string",
              "description": "optional permission level to organization (member / teacher / supervisor / admin) (default: member)"
            },
            "permission_content": {
              "type": "string",
              "description": "optional permission level to contents in organization (none / view / control / modify / grant / admin) (default: none)"
            },
            "notify": {
              "type": "boolean",
              "description": "notify users (default: false)"
            }
          },
          "required": [
            "organization",
            "users"
          ]
        }
      },
      {
        "name": "edubase_delete_organization_members",
        "description": "Remove user(s) from an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            },
            "users": {
              "type": "string",
              "description": "comma-separated list of user identification strings"
            }
          },
          "required": [
            "organization",
            "users"
          ]
        }
      },
      {
        "name": "edubase_post_organizations_members",
        "description": "Assign user(s) to organization(s). Updates memberships if already member of an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizations": {
              "type": "string",
              "description": "comma-separated list of organization identification strings"
            },
            "users": {
              "type": "string",
              "description": "comma-separated list of user identification strings"
            },
            "department": {
              "type": "string",
              "description": "optional name of department"
            },
            "permission_organization": {
              "type": "string",
              "description": "optional permission level to organization (member / teacher / supervisor / admin) (default: member)"
            },
            "permission_content": {
              "type": "string",
              "description": "optional permission level to contents in organization (none / view / control / modify / grant / admin) (default: none)"
            },
            "notify": {
              "type": "boolean",
              "description": "notify users (default: false)"
            }
          },
          "required": [
            "organizations",
            "users"
          ]
        }
      },
      {
        "name": "edubase_get_user_organizations",
        "description": "List all organizations a user is member of.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "edubase_post_user_organizations",
        "description": "Assign user to organization(s). Updates membership if already member of an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "organizations": {
              "type": "string",
              "description": "comma-separated list of organization identification strings"
            },
            "department": {
              "type": "string",
              "description": "optional name of department"
            },
            "permission_organization": {
              "type": "string",
              "description": "optional permission level to organization (member / teacher / supervisor / admin) (default: member)"
            },
            "permission_content": {
              "type": "string",
              "description": "optional permission level to contents in organization (none / view / control / modify / grant / admin) (default: none)"
            },
            "notify": {
              "type": "boolean",
              "description": "notify user (default: false)"
            }
          },
          "required": [
            "user",
            "organizations"
          ]
        }
      },
      {
        "name": "edubase_delete_user_organizations",
        "description": "Remove user from organization(s).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "organizations": {
              "type": "string",
              "description": "comma-separated list of organization identification strings"
            }
          },
          "required": [
            "user",
            "organizations"
          ]
        }
      },
      {
        "name": "edubase_get_tags",
        "description": "List owned and managed tags.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "search string to filter results"
            },
            "limit": {
              "type": "number",
              "description": "limit number of results (default, in search mode: 16)"
            },
            "page": {
              "type": "number",
              "description": "page number (default: 1), not used in search mode!"
            }
          },
          "required": []
        }
      },
      {
        "name": "edubase_get_tag",
        "description": "Get/check tag.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_class_tags",
        "description": "List all attached tags of a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            }
          },
          "required": [
            "class"
          ]
        }
      },
      {
        "name": "edubase_get_class_tag",
        "description": "Check if tag is attached to a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "class",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_class_tag",
        "description": "Attach tag to a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "class",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_class_tag",
        "description": "Remove a tag attachment from a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "class",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_course_tags",
        "description": "List all attached tags of a course.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "course": {
              "type": "string",
              "description": "course identification string"
            }
          },
          "required": [
            "course"
          ]
        }
      },
      {
        "name": "edubase_get_course_tag",
        "description": "Check if tag is attached to a course.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "course": {
              "type": "string",
              "description": "course identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "course",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_course_tag",
        "description": "Attach tag to a course.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "course": {
              "type": "string",
              "description": "course identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "course",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_course_tag",
        "description": "Remove a tag attachment from a course.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "course": {
              "type": "string",
              "description": "course identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "course",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_event_tags",
        "description": "List all attached tags of an event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event": {
              "type": "string",
              "description": "event identification string"
            }
          },
          "required": [
            "event"
          ]
        }
      },
      {
        "name": "edubase_get_event_tag",
        "description": "Check if tag is attached to an event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event": {
              "type": "string",
              "description": "event identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "event",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_event_tag",
        "description": "Attach tag to an event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event": {
              "type": "string",
              "description": "event identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "event",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_event_tag",
        "description": "Remove a tag attachment from an event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event": {
              "type": "string",
              "description": "event identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "event",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_exam_tags",
        "description": "List all attached tags of an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            }
          },
          "required": [
            "exam"
          ]
        }
      },
      {
        "name": "edubase_get_exam_tag",
        "description": "Check if tag is attached to an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "exam",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_exam_tag",
        "description": "Attach tag to an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "exam",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_exam_tag",
        "description": "Remove a tag attachment from an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "exam",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_integration_tags",
        "description": "List all attached tags of an integration.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "integration": {
              "type": "string",
              "description": "integration identification string"
            }
          },
          "required": [
            "integration"
          ]
        }
      },
      {
        "name": "edubase_get_integration_tag",
        "description": "Check if tag is attached to an integration.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "integration": {
              "type": "string",
              "description": "integration identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "integration",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_integration_tag",
        "description": "Attach tag to an integration.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "integration": {
              "type": "string",
              "description": "integration identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "integration",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_integration_tag",
        "description": "Remove a tag attachment from an integration.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "integration": {
              "type": "string",
              "description": "integration identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "integration",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_organization_tags",
        "description": "List all attached tags of an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            }
          },
          "required": [
            "organization"
          ]
        }
      },
      {
        "name": "edubase_get_organization_tag",
        "description": "Check if tag is attached to an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "organization",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_organization_tag",
        "description": "Attach tag to an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "organization",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_organization_tag",
        "description": "Remove a tag attachment from an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "organization",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_quiz_tags",
        "description": "List all attached tags of a Quiz.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            }
          },
          "required": [
            "quiz"
          ]
        }
      },
      {
        "name": "edubase_get_quiz_tag",
        "description": "Check if tag is attached to a Quiz.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "quiz",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_quiz_tag",
        "description": "Attach tag to a Quiz.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "quiz",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_quiz_tag",
        "description": "Remove a tag attachment from a Quiz.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "quiz",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_scorm_tags",
        "description": "List all attached tags of a SCORM learning material.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scorm": {
              "type": "string",
              "description": "SCORM identification string"
            }
          },
          "required": [
            "scorm"
          ]
        }
      },
      {
        "name": "edubase_get_scorm_tag",
        "description": "Check if tag is attached to a SCORM learning material.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scorm": {
              "type": "string",
              "description": "SCORM identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "scorm",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_scorm_tag",
        "description": "Attach tag to a SCORM learning material.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scorm": {
              "type": "string",
              "description": "SCORM identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "scorm",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_scorm_tag",
        "description": "Remove a tag attachment from a SCORM learning material.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scorm": {
              "type": "string",
              "description": "SCORM identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "scorm",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_video_tags",
        "description": "List all attached tags of a video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "video": {
              "type": "string",
              "description": "video identification string"
            }
          },
          "required": [
            "video"
          ]
        }
      },
      {
        "name": "edubase_get_video_tag",
        "description": "Check if tag is attached to a video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "video": {
              "type": "string",
              "description": "video identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "video",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_post_video_tag",
        "description": "Attach tag to a video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "video": {
              "type": "string",
              "description": "video identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "video",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_delete_video_tag",
        "description": "Remove a tag attachment from a video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "video": {
              "type": "string",
              "description": "video identification string"
            },
            "tag": {
              "type": "string",
              "description": "tag identification string"
            }
          },
          "required": [
            "video",
            "tag"
          ]
        }
      },
      {
        "name": "edubase_get_class_permission",
        "description": "Check if a user has permission on a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "class",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_class_permission",
        "description": "Create new permission for a user on a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "class",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_class_permission",
        "description": "Remove a user permission from a class.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "class": {
              "type": "string",
              "description": "class identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "class",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_course_permission",
        "description": "Check if a user has permission on a course.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "course": {
              "type": "string",
              "description": "course identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "course",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_course_permission",
        "description": "Create new permission for a user on a course.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "course": {
              "type": "string",
              "description": "course identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "course",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_course_permission",
        "description": "Remove a user permission from a course.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "course": {
              "type": "string",
              "description": "course identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "course",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_event_permission",
        "description": "Check if a user has permission on an event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event": {
              "type": "string",
              "description": "event identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / finances / grant / admin)"
            }
          },
          "required": [
            "event",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_event_permission",
        "description": "Create new permission for a user on an event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event": {
              "type": "string",
              "description": "event identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / finances / grant / admin)"
            }
          },
          "required": [
            "event",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_event_permission",
        "description": "Remove a user permission from an event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event": {
              "type": "string",
              "description": "event identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / finances / grant / admin)"
            }
          },
          "required": [
            "event",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_exam_permission",
        "description": "Check if a user has permission on an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "exam",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_exam_permission",
        "description": "Create new permission for a user on an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "exam",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_exam_permission",
        "description": "Remove a user permission from an exam.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exam": {
              "type": "string",
              "description": "exam identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "exam",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_integration_permission",
        "description": "Check if a user has permission on an integration.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "integration": {
              "type": "string",
              "description": "integration identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "integration",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_integration_permission",
        "description": "Create new permission for a user on an integration.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "integration": {
              "type": "string",
              "description": "integration identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "integration",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_integration_permission",
        "description": "Remove a user permission from an integration.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "integration": {
              "type": "string",
              "description": "integration identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "integration",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_organization_permission",
        "description": "Check if a user has permission on an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "organization",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_organization_permission",
        "description": "Create new permission for a user on an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "organization",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_organization_permission",
        "description": "Remove a user permission from an organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organization": {
              "type": "string",
              "description": "organization identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "organization",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_quiz_permission",
        "description": "Check if a user has permission on a quiz.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "quiz",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_quiz_permission",
        "description": "Create new permission for a user on a quiz.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "quiz",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_quiz_permission",
        "description": "Remove a user permission from a quiz.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "quiz": {
              "type": "string",
              "description": "quiz identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "quiz",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_scorm_permission",
        "description": "Check if a user has permission on a SCORM learning material.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scorm": {
              "type": "string",
              "description": "SCORM identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "scorm",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_scorm_permission",
        "description": "Create new permission for a user on a SCORM learning material.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scorm": {
              "type": "string",
              "description": "SCORM identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "scorm",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_scorm_permission",
        "description": "Remove a user permission from a SCORM learning material.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scorm": {
              "type": "string",
              "description": "SCORM identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "scorm",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_tag_permission",
        "description": "Check if a user has permission on a tag.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "tag identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "tag",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_tag_permission",
        "description": "Create new permission for a user on a tag.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "tag identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "tag",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_tag_permission",
        "description": "Remove a user permission from a tag.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "tag identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "tag",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_get_video_permission",
        "description": "Check if a user has permission on a video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "video": {
              "type": "string",
              "description": "video identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "video",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_video_permission",
        "description": "Create new permission for a user on a video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "video": {
              "type": "string",
              "description": "video identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "video",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_delete_video_permission",
        "description": "Remove a user permission from a video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "video": {
              "type": "string",
              "description": "video identification string"
            },
            "user": {
              "type": "string",
              "description": "user identification string"
            },
            "permission": {
              "type": "string",
              "description": "permission level (view / control / modify / grant / admin)"
            }
          },
          "required": [
            "video",
            "user",
            "permission"
          ]
        }
      },
      {
        "name": "edubase_post_custom_metric",
        "description": "Update a custom metric.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "metric": {
              "type": "string",
              "description": "metric name"
            },
            "value": {
              "type": "number",
              "description": "target value (also accepts increments with a + prefix)"
            }
          },
          "required": [
            "metric",
            "value"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "ramp-mcp": {
    "display_name": "Ramp MCP",
    "repository": {
      "type": "git",
      "url": "https://github.com/ramp-public/ramp-mcp"
    },
    "homepage": "https://ramp.com",
    "author": {
      "name": "ramp-public"
    },
    "license": "MIT",
    "tags": [
      "ramp",
      "finance",
      "api",
      "database",
      "etl"
    ],
    "arguments": {
      "RAMP_CLIENT_ID": {
        "description": "Ramp API client ID",
        "required": true,
        "example": "<CLIENT_ID>"
      },
      "RAMP_CLIENT_SECRET": {
        "description": "Ramp API client secret",
        "required": true,
        "example": "<CLIENT_SECRET>"
      },
      "RAMP_ENV": {
        "description": "Ramp environment (demo, qa, or prd)",
        "required": true,
        "example": "demo"
      },
      "-s": {
        "description": "Comma-separated list of API scopes to enable",
        "required": true,
        "example": "transactions:read,reimbursements:read"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ramp-public/ramp-mcp.git",
          "ramp-mcp",
          "-s",
          "${-s}"
        ],
        "env": {
          "RAMP_CLIENT_ID": "${RAMP_CLIENT_ID}",
          "RAMP_CLIENT_SECRET": "${RAMP_CLIENT_SECRET}",
          "RAMP_ENV": "${RAMP_ENV}"
        },
        "description": "Run using uv package manager",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Query transactions",
        "description": "Load and analyze transaction data from Ramp",
        "prompt": "Load my recent transactions and show me the top 5 vendors by spend amount."
      }
    ],
    "name": "ramp-mcp",
    "description": "A Model Context Protocol server for retrieving and analyzing data or running tasks for [Ramp](https://ramp.com) using [Developer API](https://docs.ramp.com/developer-api/v1/overview/introduction). In order to get around token and input size limitations, this server implements a simple ETL pipeline + ephemeral sqlite database in memory for analysis by an LLM. All requests are made to demo by default, but can be changed by setting `RAMP_ENV=prd`. Large datasets may not be processable due to API and/or your MCP client limitations.",
    "categories": [
      "Finance"
    ],
    "is_official": true
  },
  "opendota": {
    "name": "opendota",
    "display_name": "OpenDota",
    "description": "Interact with OpenDota API to retrieve Dota 2 match data, player statistics, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/asusevski/opendota-mcp-server"
    },
    "homepage": "https://github.com/asusevski/opendota-mcp-server",
    "author": {
      "name": "asusevski"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Dota 2",
      "API",
      "Gaming",
      "Statistics"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/asusevski/opendota-mcp-server.git",
          "src/opendota_server/server"
        ]
      }
    }
  },
  "apimatic-validator-mcp": {
    "display_name": "APIMatic Validator MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/apimatic/apimatic-validator-mcp"
    },
    "license": "[NOT GIVEN]",
    "homepage": "https://www.apimatic.io/",
    "author": {
      "name": "apimatic"
    },
    "tags": [
      "OpenAPI",
      "validation",
      "APIMatic"
    ],
    "arguments": {
      "APIMATIC_API_KEY": {
        "description": "API key for APIMatic service",
        "required": true,
        "example": "<Add your APIMatic token here>"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "node",
        "args": [
          "build/index.js"
        ],
        "package": "[NOT GIVEN]",
        "env": {
          "APIMATIC_API_KEY": "<Add your APIMatic token here>"
        },
        "description": "Run the APIMatic Validator MCP Server using Node.js",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Validate OpenAPI Specification",
        "description": "Validate an OpenAPI file using APIMatic",
        "prompt": "Please validate this OpenAPI specification"
      }
    ],
    "name": "apimatic-validator-mcp",
    "description": "This repository provides a Model Context Protocol (MCP) Server for validating OpenAPI specifications using [APIMatic](https://www.apimatic.io/). The server processes OpenAPI files and returns validation summaries by leveraging APIMatic\u2019s API.",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "stripe": {
    "name": "stripe",
    "display_name": "Stripe Model Context Protocol",
    "description": "The Stripe Model Context Protocol server allows you to integrate with Stripe APIs through function calling. This protocol supports various tools to interact with different Stripe services.",
    "repository": {
      "type": "git",
      "url": "https://github.com/stripe/agent-toolkit"
    },
    "homepage": "https://github.com/stripe/agent-toolkit/tree/main/modelcontextprotocol",
    "author": {
      "name": "stripe"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "stripe",
      "payments",
      "customers",
      "refunds"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@stripe/mcp",
          "--tools=all",
          "--api-key=${STRIPE_SECRET_KEY}"
        ]
      }
    },
    "examples": [
      {
        "title": "Create a customer",
        "description": "Creates a new customer in Stripe.",
        "prompt": "{\"tool\": \"customer_create\", \"arguments\": {\"email\": \"customer@example.com\", \"name\": \"John Doe\"}}"
      },
      {
        "title": "Retrieve a customer",
        "description": "Retrieves details of an existing customer.",
        "prompt": "{\"tool\": \"customer_retrieve\", \"arguments\": {\"customer_id\": \"cus_123456\"}}"
      },
      {
        "title": "Create a payment intent",
        "description": "Creates a payment intent for processing payments.",
        "prompt": "{\"tool\": \"payment_intent_create\", \"arguments\": {\"amount\": 5000, \"currency\": \"usd\", \"customer\": \"cus_123456\"}}"
      },
      {
        "title": "Create a refund",
        "description": "Creates a refund for a charge.",
        "prompt": "{\"tool\": \"refund_create\", \"arguments\": {\"charge_id\": \"ch_abc123\"}}"
      }
    ],
    "arguments": {
      "STRIPE_SECRET_KEY": {
        "description": "Your Stripe secret API key required for authenticating requests to the Stripe API.",
        "required": true,
        "example": "sk_test_xxxxxxxxxxxxxxxxxxxx"
      }
    },
    "tools": [
      {
        "name": "create_customer",
        "description": "\nThis tool will create a customer in Stripe.\n\nIt takes two arguments:\n- name (str): The name of the customer.\n- email (str, optional): The email of the customer.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the customer"
            },
            "email": {
              "type": "string",
              "format": "email",
              "description": "The email of the customer"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_customers",
        "description": "\nThis tool will fetch a list of Customers from Stripe.\n\nIt takes no input.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "description": "A limit on the number of objects to be returned. Limit can range between 1 and 100."
            },
            "email": {
              "type": "string",
              "description": "A case-sensitive filter on the list based on the customer's email field. The value must be a string."
            }
          }
        }
      },
      {
        "name": "create_product",
        "description": "\nThis tool will create a product in Stripe.\n\nIt takes two arguments:\n- name (str): The name of the product.\n- description (str, optional): The description of the product.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the product."
            },
            "description": {
              "type": "string",
              "description": "The description of the product."
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_products",
        "description": "\nThis tool will fetch a list of Products from Stripe.\n\nIt takes one optional argument:\n- limit (int, optional): The number of products to return.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "description": "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10."
            }
          }
        }
      },
      {
        "name": "create_price",
        "description": "\nThis tool will create a price in Stripe. If a product has not already been specified, a product should be created first.\n\nIt takes three arguments:\n- product (str): The ID of the product to create the price for.\n- unit_amount (int): The unit amount of the price in cents.\n- currency (str): The currency of the price.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "product": {
              "type": "string",
              "description": "The ID of the product to create the price for."
            },
            "unit_amount": {
              "type": "integer",
              "description": "The unit amount of the price in cents."
            },
            "currency": {
              "type": "string",
              "description": "The currency of the price."
            }
          },
          "required": [
            "product",
            "unit_amount",
            "currency"
          ]
        }
      },
      {
        "name": "list_prices",
        "description": "\nThis tool will fetch a list of Prices from Stripe.\n\nIt takes two arguments.\n- product (str, optional): The ID of the product to list prices for.\n- limit (int, optional): The number of prices to return.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "product": {
              "type": "string",
              "description": "The ID of the product to list prices for."
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "description": "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10."
            }
          }
        }
      },
      {
        "name": "create_payment_link",
        "description": "\nThis tool will create a payment link in Stripe.\n\nIt takes two arguments:\n- price (str): The ID of the price to create the payment link for.\n- quantity (int): The quantity of the product to include in the payment link.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "price": {
              "type": "string",
              "description": "The ID of the price to create the payment link for."
            },
            "quantity": {
              "type": "integer",
              "description": "The quantity of the product to include."
            }
          },
          "required": [
            "price",
            "quantity"
          ]
        }
      },
      {
        "name": "create_invoice",
        "description": "\nThis tool will create an invoice in Stripe.\n\nIt takes two arguments:\n- customer (str): The ID of the customer to create the invoice for.\n\n- days_until_due (int, optional): The number of days until the invoice is due.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "customer": {
              "type": "string",
              "description": "The ID of the customer to create the invoice for."
            },
            "days_until_due": {
              "type": "integer",
              "description": "The number of days until the invoice is due."
            }
          },
          "required": [
            "customer"
          ]
        }
      },
      {
        "name": "create_invoice_item",
        "description": "\nThis tool will create an invoice item in Stripe.\n\nIt takes two arguments:\n- customer (str): The ID of the customer to create the invoice item for.\n\n- price (str): The ID of the price to create the invoice item for.\n- invoice (str): The ID of the invoice to create the invoice item for.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "customer": {
              "type": "string",
              "description": "The ID of the customer to create the invoice item for."
            },
            "price": {
              "type": "string",
              "description": "The ID of the price for the item."
            },
            "invoice": {
              "type": "string",
              "description": "The ID of the invoice to create the item for."
            }
          },
          "required": [
            "customer",
            "price",
            "invoice"
          ]
        }
      },
      {
        "name": "finalize_invoice",
        "description": "\nThis tool will finalize an invoice in Stripe.\n\nIt takes one argument:\n- invoice (str): The ID of the invoice to finalize.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "invoice": {
              "type": "string",
              "description": "The ID of the invoice to finalize."
            }
          },
          "required": [
            "invoice"
          ]
        }
      },
      {
        "name": "retrieve_balance",
        "description": "\nThis tool will retrieve the balance from Stripe. It takes no input.\n",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_refund",
        "description": "\nThis tool will refund a payment intent in Stripe.\n\nIt takes three arguments:\n- payment_intent (str): The ID of the payment intent to refund.\n- amount (int, optional): The amount to refund in cents.\n- reason (str, optional): The reason for the refund.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "payment_intent": {
              "type": "string",
              "description": "The ID of the PaymentIntent to refund."
            },
            "amount": {
              "type": "integer",
              "description": "The amount to refund in cents."
            }
          },
          "required": [
            "payment_intent"
          ]
        }
      },
      {
        "name": "list_payment_intents",
        "description": "\nThis tool will list payment intents in Stripe.\n\nIt takes two arguments:\n- customer (str, optional): The ID of the customer to list payment intents for.\n\n- limit (int, optional): The number of payment intents to return.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "customer": {
              "type": "string",
              "description": "The ID of the customer to list payment intents for."
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "description": "A limit on the number of objects to be returned. Limit can range between 1 and 100."
            }
          }
        }
      },
      {
        "name": "search_documentation",
        "description": "\nThis tool will take in a user question about integrating with Stripe in their application, then search and retrieve relevant Stripe documentation to answer the question.\n\nIt takes two arguments:\n- question (str): The user question to search an answer for in the Stripe documentation.\n- language (str, optional): The programming language to search for in the the documentation.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "question": {
              "type": "string",
              "description": "The user question about integrating with Stripe will be used to search the documentation."
            },
            "language": {
              "type": "string",
              "enum": [
                "dotnet",
                "go",
                "java",
                "node",
                "php",
                "ruby",
                "python",
                "curl"
              ],
              "description": "The programming language to search for in the the documentation."
            }
          },
          "required": [
            "question"
          ]
        }
      }
    ],
    "is_official": true
  },
  "unity3d-game-engine": {
    "name": "unity3d-game-engine",
    "display_name": "Unity3D Game Engine",
    "description": "An MCP server that enables LLMs to interact with Unity3d Game Engine, supporting access to a variety of the Unit's Editor engine tools (e.g. Console Logs, Test Runner logs, Editor functions, hierarchy state, etc) and executing them as MCP tools or gather them as resources.",
    "repository": {
      "type": "git",
      "url": "https://github.com/CoderGamester/mcp-unity"
    },
    "homepage": "https://github.com/CoderGamester/mcp-unity",
    "author": {
      "name": "CoderGamester"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Unity",
      "Node.js",
      "TypeScript",
      "WebSocket",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/CoderGamester/mcp-unity"
        ],
        "env": {
          "UNITY_PORT": "8090"
        }
      }
    },
    "examples": [
      {
        "title": "Execute Menu Item",
        "description": "Execute Unity menu items programmatically using MCP Unity.",
        "prompt": "mcp-unity execute_menu_item"
      }
    ],
    "arguments": {
      "UNITY_PORT": {
        "description": "Environment variable to set the port number for the Unity MCP Server. This should be set to the desired port for the server to run and connect with the Unity Editor.",
        "required": false,
        "example": "8090"
      }
    },
    "tools": [
      {
        "name": "execute_menu_item",
        "description": "Executes a Unity menu item by path",
        "inputSchema": {
          "type": "object",
          "properties": {
            "menuPath": {
              "type": "string",
              "description": "The path to the menu item to execute (e.g. \"GameObject/Create Empty\")"
            }
          },
          "required": [
            "menuPath"
          ]
        }
      },
      {
        "name": "select_object",
        "description": "Sets the selected object in the Unity editor by path or ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectPath": {
              "type": "string",
              "description": "The path or ID of the object to select (e.g. \"Main Camera\" or a Unity object ID)"
            }
          },
          "required": [
            "objectPath"
          ]
        }
      },
      {
        "name": "package_manager",
        "description": "Manages packages in the Unity Package Manager",
        "inputSchema": {
          "type": "object",
          "properties": {
            "methodSource": {
              "type": "string",
              "description": "The method source to use (registry, github, or disk) to add the package"
            },
            "packageName": {
              "type": "string",
              "description": "The package name to add from Unity registry (e.g. com.unity.textmeshpro)"
            },
            "version": {
              "type": "string",
              "description": "The version to use for registry packages (optional)"
            },
            "repositoryUrl": {
              "type": "string",
              "description": "The GitHub repository URL (e.g. https://github.com/username/repo.git)"
            },
            "branch": {
              "type": "string",
              "description": "The branch to use for GitHub packages (optional)"
            },
            "path": {
              "type": "string",
              "description": "The path to use (folder path for disk method or subfolder for GitHub)"
            }
          },
          "required": [
            "methodSource"
          ]
        }
      },
      {
        "name": "run_tests",
        "description": "Runs Unity's Test Runner tests",
        "inputSchema": {
          "type": "object",
          "properties": {
            "testMode": {
              "type": "string",
              "description": "The test mode to run (EditMode, PlayMode, or All)"
            },
            "testFilter": {
              "type": "string",
              "description": "Optional test filter (e.g. specific test name or namespace)"
            }
          }
        }
      },
      {
        "name": "notify_message",
        "description": "Sends a message to the Unity console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "The message to display in the Unity console"
            },
            "type": {
              "type": "string",
              "description": "The type of message (info, warning, error)"
            }
          },
          "required": [
            "message"
          ]
        }
      }
    ]
  },
  "needle-mcp": {
    "display_name": "Needle MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/needle-ai/needle-mcp"
    },
    "homepage": "https://needle-ai.com",
    "author": {
      "name": "needle-ai"
    },
    "license": "MIT",
    "tags": [
      "document management",
      "search",
      "Needle"
    ],
    "arguments": {
      "NEEDLE_API_KEY": {
        "description": "API key for Needle service",
        "required": true,
        "example": "your_needle_api_key"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/needle-ai/needle-mcp",
          "needle-mcp"
        ],
        "env": {
          "NEEDLE_API_KEY": "your_needle_api_key"
        },
        "description": "Run using UV package manager",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Create Collection",
        "description": "Create a new document collection",
        "prompt": "Create a new collection called 'Technical Docs'"
      },
      {
        "title": "Add Document",
        "description": "Add a document to an existing collection",
        "prompt": "Add this document to the collection, which is https://needle-ai.com"
      },
      {
        "title": "Search Collection",
        "description": "Search for information in a collection",
        "prompt": "Search the collection for information about AI"
      },
      {
        "title": "List Collections",
        "description": "List all available collections",
        "prompt": "List all my collections"
      }
    ],
    "name": "needle-mcp",
    "description": "MCP (Model Context Protocol) server to manage documents and perform searches using [Needle](https://needle-ai.com) through Claude\u2019s Desktop Application.",
    "categories": [
      "Knowledge Base"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "needle_list_collections",
        "description": "Retrieve a complete list of all Needle document collections accessible to your account. \n            Returns detailed information including collection IDs, names, and creation dates. Use this tool when you need to:\n            - Get an overview of available document collections\n            - Find collection IDs for subsequent operations\n            - Verify collection existence before performing operations\n            The response includes metadata that's required for other Needle operations.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "needle_create_collection",
        "description": "Create a new document collection in Needle for organizing and searching documents. \n            A collection acts as a container for related documents and enables semantic search across its contents.\n            Use this tool when you need to:\n            - Start a new document organization\n            - Group related documents together\n            - Set up a searchable document repository\n            Returns a collection ID that's required for subsequent operations. Choose a descriptive name that \n            reflects the collection's purpose for better organization.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "A clear, descriptive name for the collection that reflects its purpose and contents"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "needle_get_collection_details",
        "description": "Fetch comprehensive metadata about a specific Needle collection. \n            Provides detailed information about the collection's configuration, creation date, and current status.\n            Use this tool when you need to:\n            - Verify a collection's existence and configuration\n            - Check collection metadata before operations\n            - Get creation date and other attributes\n            Requires a valid collection ID and returns detailed collection metadata. Will error if collection doesn't exist.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection_id": {
              "type": "string",
              "description": "The unique collection identifier returned from needle_create_collection or needle_list_collections"
            }
          },
          "required": [
            "collection_id"
          ]
        }
      },
      {
        "name": "needle_get_collection_stats",
        "description": "Retrieve detailed statistical information about a Needle collection's contents and status.\n            Provides metrics including:\n            - Total number of documents\n            - Processing status of documents\n            - Storage usage and limits\n            - Index status and health\n            Use this tool to:\n            - Monitor collection size and growth\n            - Verify processing completion\n            - Check collection health before operations\n            Essential for ensuring collection readiness before performing searches.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection_id": {
              "type": "string",
              "description": "The unique collection identifier to get statistics for"
            }
          },
          "required": [
            "collection_id"
          ]
        }
      },
      {
        "name": "needle_list_files",
        "description": "List all documents stored within a specific Needle collection with their current status.\n            Returns detailed information about each file including:\n            - File ID and name\n            - Processing status (pending, processing, complete, error)\n            - Upload date and metadata\n            Use this tool when you need to:\n            - Inventory available documents\n            - Check processing status of uploads\n            - Get file IDs for reference\n            - Verify document availability before searching\n            Essential for monitoring document processing completion before performing searches.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection_id": {
              "type": "string",
              "description": "The unique collection identifier to list files from"
            }
          },
          "required": [
            "collection_id"
          ]
        }
      },
      {
        "name": "needle_add_file",
        "description": "Add a new document to a Needle collection by providing a URL for download.\n            Supports multiple file formats including:\n            - PDF documents\n            - Microsoft Word files (DOC, DOCX)\n            - Plain text files (TXT)\n            - Web pages (HTML)\n            \n            The document will be:\n            1. Downloaded from the provided URL\n            2. Processed for text extraction\n            3. Indexed for semantic search\n            \n            Use this tool when you need to:\n            - Add new documents to a collection\n            - Make documents searchable\n            - Expand your knowledge base\n            \n            Important: Documents require processing time before they're searchable.\n            Check processing status using needle_list_files before searching new content.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection_id": {
              "type": "string",
              "description": "The unique collection identifier where the file will be added"
            },
            "name": {
              "type": "string",
              "description": "A descriptive filename that will help identify this document in results"
            },
            "url": {
              "type": "string",
              "description": "Public URL where the document can be downloaded from"
            }
          },
          "required": [
            "collection_id",
            "name",
            "url"
          ]
        }
      },
      {
        "name": "needle_search",
        "description": "Perform intelligent semantic search across documents in a Needle collection.\n            This tool uses advanced embedding technology to find relevant content based on meaning,\n            not just keywords. The search:\n            - Understands natural language queries\n            - Finds conceptually related content\n            - Returns relevant text passages with source information\n            - Ranks results by semantic relevance\n            \n            Use this tool when you need to:\n            - Find specific information within documents\n            - Answer questions from document content\n            - Research topics across multiple documents\n            - Locate relevant passages and their sources\n            \n            More effective than traditional keyword search for:\n            - Natural language questions\n            - Conceptual queries\n            - Finding related content\n            \n            Returns matching text passages with their source file IDs.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection_id": {
              "type": "string",
              "description": "The unique collection identifier to search within"
            },
            "query": {
              "type": "string",
              "description": "Natural language query describing the information you're looking for"
            }
          },
          "required": [
            "collection_id",
            "query"
          ]
        }
      }
    ]
  },
  "cloudinary": {
    "name": "cloudinary",
    "display_name": "Cloudinary",
    "description": "Cloudinary Model Context Protocol Server to upload media to Cloudinary and get back the media link and details.",
    "repository": {
      "type": "git",
      "url": "https://github.com/felores/cloudinary-mcp-server"
    },
    "homepage": "https://github.com/felores/cloudinary-mcp-server",
    "author": {
      "name": "felores"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "cloudinary",
      "images",
      "videos"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@felores/cloudinary-mcp-server@latest"
        ],
        "env": {
          "CLOUDINARY_CLOUD_NAME": "${CLOUDINARY_CLOUD_NAME}",
          "CLOUDINARY_API_KEY": "${CLOUDINARY_API_KEY}",
          "CLOUDINARY_API_SECRET": "${CLOUDINARY_API_SECRET}"
        }
      }
    },
    "examples": [
      {
        "title": "Upload an Image",
        "description": "This example demonstrates how to upload an image to Cloudinary.",
        "prompt": "use_mcp_tool({ server_name: 'cloudinary', tool_name: 'upload', arguments: { file: 'path/to/image.jpg', resource_type: 'image', public_id: 'my-custom-id' }});"
      }
    ],
    "arguments": {
      "CLOUDINARY_CLOUD_NAME": {
        "description": "Your Cloudinary cloud name, used to identify your account and resources.",
        "required": true,
        "example": "my_cloud_name"
      },
      "CLOUDINARY_API_KEY": {
        "description": "Your Cloudinary API key, used to authenticate requests to the Cloudinary API.",
        "required": true,
        "example": "my_api_key"
      },
      "CLOUDINARY_API_SECRET": {
        "description": "Your Cloudinary API secret, used to authenticate requests and secure your Cloudinary account.",
        "required": true,
        "example": "my_api_secret"
      }
    },
    "tools": [
      {
        "name": "upload",
        "description": "Upload media (images/videos) to Cloudinary. For large files, the upload is processed in chunks and returns a streaming response. The uploaded asset will be available at:\n- HTTP: http://res.cloudinary.com/{cloud_name}/{resource_type}/upload/v1/{public_id}.{format}\n- HTTPS: https://res.cloudinary.com/{cloud_name}/{resource_type}/upload/v1/{public_id}.{format}\nwhere {cloud_name} is your Cloudinary cloud name, resource_type is 'image' or 'video', and format is determined by the file extension.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "Path to file, URL, or base64 data URI to upload"
            },
            "resource_type": {
              "type": "string",
              "enum": [
                "image",
                "video",
                "raw"
              ],
              "description": "Type of resource to upload. For videos, the upload will return a streaming response as it processes in chunks."
            },
            "public_id": {
              "type": "string",
              "description": "Public ID to assign to the uploaded asset. This will be used in the final URL. If not provided, Cloudinary will generate one."
            },
            "overwrite": {
              "type": "boolean",
              "description": "Whether to overwrite existing assets with the same public ID"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags to assign to the uploaded asset"
            }
          },
          "required": [
            "file"
          ]
        }
      }
    ]
  },
  "notion": {
    "name": "notion",
    "display_name": "Notion",
    "description": "Notion MCP integration. Search, Read, Update, and Create pages through Claude chat.",
    "repository": {
      "type": "git",
      "url": "https://github.com/v-3/notion-server"
    },
    "homepage": "https://github.com/v-3/notion-server",
    "author": {
      "name": "v-3"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Notion"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/v-3/notion-server"
        ],
        "env": {
          "NOTION_API_KEY": "${NOTION_API_KEY}"
        }
      }
    },
    "arguments": {
      "NOTION_API_KEY": {
        "description": "Your Notion API key for authentication to access data within your Notion workspace.",
        "required": true,
        "example": "your_notion_api_key_here"
      }
    }
  },
  "dicom": {
    "name": "dicom",
    "display_name": "DICOM Model Context Protocol",
    "description": "An MCP server to query and retrieve medical images and for parsing and reading dicom-encapsulated documents (pdf etc.).",
    "repository": {
      "type": "git",
      "url": "https://github.com/ChristianHinge/dicom-mcp"
    },
    "homepage": "https://github.com/ChristianHinge/dicom-mcp",
    "author": {
      "name": "ChristianHinge",
      "url": "https://github.com/ChristianHinge"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "DICOM",
      "Medical Imaging",
      "AI",
      "PDF Extraction"
    ],
    "examples": [
      {
        "title": "List available DICOM nodes",
        "description": "Retrieve and display all configured DICOM nodes and calling AE titles.",
        "prompt": "list_dicom_nodes()"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ChristianHinge/dicom-mcp",
          "dicom-mcp",
          "${CONFIG_PATH}"
        ]
      }
    },
    "arguments": {
      "CONFIG_PATH": {
        "description": "Path to the configuration file",
        "required": true,
        "example": "/path/to/config.yaml"
      }
    },
    "tools": [
      {
        "name": "list_dicom_nodes",
        "description": "Lists all configured DICOM nodes and calling AE titles.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "switch_dicom_node",
        "description": "Switches to a different configured DICOM node.",
        "inputSchema": {
          "node_name": {
            "type": "string",
            "description": "Name of the node to switch to"
          }
        },
        "required": [
          "node_name"
        ]
      },
      {
        "name": "switch_calling_aet",
        "description": "Switches to a different configured calling AE title.",
        "inputSchema": {
          "aet_name": {
            "type": "string",
            "description": "Name of the calling AE title to switch to"
          }
        },
        "required": [
          "aet_name"
        ]
      },
      {
        "name": "verify_connection",
        "description": "Tests connectivity to the configured DICOM node using C-ECHO.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "query_patients",
        "description": "Search for patients matching specified criteria.",
        "inputSchema": {
          "name_pattern": {
            "type": "string",
            "description": "Patient name pattern (can include wildcards)",
            "optional": true
          },
          "patient_id": {
            "type": "string",
            "description": "Patient ID",
            "optional": true
          },
          "birth_date": {
            "type": "string",
            "description": "Patient birth date (YYYYMMDD)",
            "optional": true
          },
          "attribute_preset": {
            "type": "string",
            "description": "Preset level of detail",
            "optional": true
          },
          "additional_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional DICOM attributes to include",
            "optional": true
          },
          "exclude_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DICOM attributes to exclude",
            "optional": true
          }
        },
        "required": []
      },
      {
        "name": "query_studies",
        "description": "Search for studies matching specified criteria.",
        "inputSchema": {
          "patient_id": {
            "type": "string",
            "description": "Patient ID",
            "optional": true
          },
          "study_date": {
            "type": "string",
            "description": "Study date or range (YYYYMMDD or YYYYMMDD-YYYYMMDD)",
            "optional": true
          },
          "modality_in_study": {
            "type": "string",
            "description": "Modalities in study",
            "optional": true
          },
          "study_description": {
            "type": "string",
            "description": "Study description (can include wildcards)",
            "optional": true
          },
          "accession_number": {
            "type": "string",
            "description": "Accession number",
            "optional": true
          },
          "study_instance_uid": {
            "type": "string",
            "description": "Study Instance UID",
            "optional": true
          },
          "attribute_preset": {
            "type": "string",
            "description": "Preset level of detail",
            "optional": true
          },
          "additional_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional DICOM attributes to include",
            "optional": true
          },
          "exclude_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DICOM attributes to exclude",
            "optional": true
          }
        },
        "required": []
      },
      {
        "name": "query_series",
        "description": "Search for series within a study.",
        "inputSchema": {
          "study_instance_uid": {
            "type": "string",
            "description": "Study Instance UID"
          },
          "modality": {
            "type": "string",
            "description": "Modality (e.g., 'CT', 'MR')",
            "optional": true
          },
          "series_number": {
            "type": "string",
            "description": "Series number",
            "optional": true
          },
          "series_description": {
            "type": "string",
            "description": "Series description",
            "optional": true
          },
          "series_instance_uid": {
            "type": "string",
            "description": "Series Instance UID",
            "optional": true
          },
          "attribute_preset": {
            "type": "string",
            "description": "Preset level of detail",
            "optional": true
          },
          "additional_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional DICOM attributes to include",
            "optional": true
          },
          "exclude_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DICOM attributes to exclude",
            "optional": true
          }
        },
        "required": [
          "study_instance_uid"
        ]
      },
      {
        "name": "query_instances",
        "description": "Search for instances within a series.",
        "inputSchema": {
          "series_instance_uid": {
            "type": "string",
            "description": "Series Instance UID"
          },
          "instance_number": {
            "type": "string",
            "description": "Instance number",
            "optional": true
          },
          "sop_instance_uid": {
            "type": "string",
            "description": "SOP Instance UID",
            "optional": true
          },
          "attribute_preset": {
            "type": "string",
            "description": "Preset level of detail",
            "optional": true
          },
          "additional_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional DICOM attributes to include",
            "optional": true
          },
          "exclude_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DICOM attributes to exclude",
            "optional": true
          }
        },
        "required": [
          "series_instance_uid"
        ]
      },
      {
        "name": "get_attribute_presets",
        "description": "Lists available attribute presets for queries.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "retrieve_instance",
        "description": "Retrieves a specific DICOM instance and saves it to the local filesystem.",
        "inputSchema": {
          "study_instance_uid": {
            "type": "string",
            "description": "Study Instance UID"
          },
          "series_instance_uid": {
            "type": "string",
            "description": "Series Instance UID"
          },
          "sop_instance_uid": {
            "type": "string",
            "description": "SOP Instance UID"
          },
          "output_directory": {
            "type": "string",
            "description": "Directory to save the retrieved instance to (default: './retrieved_files')",
            "optional": true
          }
        },
        "required": [
          "study_instance_uid",
          "series_instance_uid",
          "sop_instance_uid"
        ]
      },
      {
        "name": "extract_pdf_text_from_dicom",
        "description": "Retrieves a DICOM instance containing an encapsulated PDF and extracts its text content.",
        "inputSchema": {
          "study_instance_uid": {
            "type": "string",
            "description": "Study Instance UID"
          },
          "series_instance_uid": {
            "type": "string",
            "description": "Series Instance UID"
          },
          "sop_instance_uid": {
            "type": "string",
            "description": "SOP Instance UID"
          }
        },
        "required": [
          "study_instance_uid",
          "series_instance_uid",
          "sop_instance_uid"
        ]
      }
    ]
  },
  "huggingface-spaces": {
    "name": "huggingface-spaces",
    "display_name": "HuggingFace Spaces \ud83e\udd17",
    "description": "Server for using HuggingFace Spaces, supporting Open Source Image, Audio, Text Models and more. Claude Desktop mode for easy integration.",
    "repository": {
      "type": "git",
      "url": "https://github.com/evalstate/mcp-hfspace"
    },
    "author": {
      "name": "evalstate"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Hugging Face",
      "Claude Desktop"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@llmindset/mcp-hfspace"
        ]
      }
    },
    "examples": [
      {
        "title": "Image Generation Example",
        "description": "Using mcp-hfspace to generate images.",
        "prompt": "Use shuttleai/shuttle-3.1-aesthetic to create an image."
      },
      {
        "title": "Text-to-Speech Example",
        "description": "Using mcp-hfspace to convert text to speech.",
        "prompt": "Create an audio file from the text 'Hello, world!'."
      },
      {
        "title": "Speech-to-Text Example",
        "description": "Using mcp-hfspace to transcribe audio to text.",
        "prompt": "Transcribe the audio file 'sample_audio.wav'."
      },
      {
        "title": "Vision Model Example",
        "description": "Using mcp-hfspace to analyze images.",
        "prompt": "Analyze the image file 'test_image.jpg'."
      }
    ],
    "homepage": "https://github.com/evalstate/mcp-hfspace",
    "arguments": {
      "CLAUDE_DESKTOP_MODE": {
        "description": "Enables or disables the Claude Desktop Mode for the server.",
        "required": false,
        "example": "false"
      }
    },
    "tools": [
      {
        "name": "available-files",
        "description": "A list of available file and resources. If the User requests things like 'most recent image' or 'the audio' use this tool to identify the intended resource.This tool returns 'resource uri', 'name', 'size', 'last modified'  and 'mime type' in a markdown table",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "FLUX_1-schnell-infer",
        "description": "Call the FLUX.1-schnell endpoint /infer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Prompt",
              "examples": [
                "Hello!!"
              ]
            },
            "seed": {
              "type": "number",
              "description": "Seed",
              "default": 0
            },
            "randomize_seed": {
              "type": "boolean",
              "description": "Randomize seed",
              "default": true,
              "examples": [
                true
              ]
            },
            "width": {
              "type": "number",
              "description": "Width",
              "default": 1024,
              "examples": [
                256
              ]
            },
            "height": {
              "type": "number",
              "description": "Height",
              "default": 1024,
              "examples": [
                256
              ]
            },
            "num_inference_steps": {
              "type": "number",
              "description": "Number of inference steps",
              "default": 4,
              "examples": [
                1
              ]
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "mcp-audiense-insights": {
    "display_name": "Audiense Insights",
    "repository": {
      "type": "git",
      "url": "https://github.com/AudienseCo/mcp-audiense-insights"
    },
    "homepage": "https://github.com/AudienseCo/mcp-audiense-insights",
    "author": {
      "name": "AudienseCo"
    },
    "license": "Apache 2.0",
    "tags": [
      "marketing",
      "audience analysis",
      "insights",
      "demographics",
      "influencers"
    ],
    "arguments": {
      "AUDIENSE_CLIENT_ID": {
        "description": "Audiense API client ID",
        "required": true,
        "example": "your_client_id_here"
      },
      "AUDIENSE_CLIENT_SECRET": {
        "description": "Audiense API client secret",
        "required": true,
        "example": "your_client_secret_here"
      },
      "TWITTER_BEARER_TOKEN": {
        "description": "X/Twitter API Bearer Token for enriched influencer data",
        "required": false,
        "example": "your_token_here"
      }
    },
    "installations": {
      "custom": {
        "type": "npm",
        "command": "node",
        "args": [
          "/ABSOLUTE/PATH/TO/YOUR/build/index.js"
        ],
        "env": {
          "AUDIENSE_CLIENT_ID": "your_client_id_here",
          "AUDIENSE_CLIENT_SECRET": "your_client_secret_here",
          "TWITTER_BEARER_TOKEN": "your_token_here"
        },
        "description": "Manual installation by configuring Claude Desktop"
      }
    },
    "examples": [
      {
        "title": "Audiense Demo",
        "description": "Helps analyze Audiense reports interactively",
        "prompt": "audiense-demo"
      },
      {
        "title": "Segment Matching",
        "description": "Match and compare audience segments across Audiense reports, identifying similarities, unique traits, and key insights",
        "prompt": "segment-matching"
      }
    ],
    "name": "mcp-audiense-insights",
    "description": "This server, based on the [Model Context Protocol (MCP)](https://github.com/modelcontextprotocol), allows **Claude** or any other MCP-compatible client to interact with your [Audiense Insights](https://www.audiense.com/) account. It extracts **marketing insights and audience analysis** from Audiense reports, covering **demographic, cultural, influencer, and content engagement analysis**.",
    "categories": [
      "Analytics"
    ],
    "is_official": true
  },
  "hubspot": {
    "name": "hubspot",
    "display_name": "HubSpot CRM Integration",
    "description": "HubSpot CRM integration for managing contacts and companies. Create and retrieve CRM data directly through Claude chat.",
    "repository": {
      "type": "git",
      "url": "https://github.com/buryhuang/mcp-hubspot"
    },
    "homepage": "https://github.com/buryhuang/mcp-hubspot",
    "author": {
      "name": "buryhuang"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "HubSpot",
      "API",
      "AI",
      "CRM",
      "Integration"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "HUBSPOT_ACCESS_TOKEN=${HUBSPOT_ACCESS_TOKEN}",
          "buryhuang/mcp-hubspot:latest"
        ],
        "env": {
          "HUBSPOT_ACCESS_TOKEN": "${HUBSPOT_ACCESS_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Create HubSpot contacts from LinkedIn",
        "description": "This prompt allows you to create contacts in HubSpot by parsing information from a LinkedIn profile.",
        "prompt": "Create HubSpot contacts and companies from following:\n\nJohn Doe\nSoftware Engineer at Tech Corp\nSan Francisco Bay Area \u2022 500+ connections\n\nExperience\nTech Corp\nSoftware Engineer\nJan 2020 - Present \u00b7 4 yrs\nSan Francisco, California\n\nPrevious Company Inc.\nSenior Developer\n2018 - 2020 \u00b7 2 yrs\n\nEducation\nUniversity of California, Berkeley\nComputer Science, BS\n2014 - 2018"
      },
      {
        "title": "Get latest company activities",
        "description": "Use this prompt to get the latest activities related to your company in HubSpot.",
        "prompt": "What's happening latestly with my pipeline?"
      }
    ],
    "arguments": {
      "HUBSPOT_ACCESS_TOKEN": {
        "description": "The HubSpot access token required for authenticating API requests to HubSpot.",
        "required": true,
        "example": "your_access_token_here"
      }
    },
    "tools": [
      {
        "name": "hubspot_create_contact",
        "description": "Create a new contact in HubSpot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "firstname": {
              "type": "string",
              "description": "Contact's first name"
            },
            "lastname": {
              "type": "string",
              "description": "Contact's last name"
            },
            "email": {
              "type": "string",
              "description": "Contact's email address"
            },
            "properties": {
              "type": "object",
              "description": "Additional contact properties"
            }
          },
          "required": [
            "firstname",
            "lastname"
          ]
        }
      },
      {
        "name": "hubspot_create_company",
        "description": "Create a new company in HubSpot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Company name"
            },
            "properties": {
              "type": "object",
              "description": "Additional company properties"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "hubspot_get_company_activity",
        "description": "Get activity history for a specific company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "company_id": {
              "type": "string",
              "description": "HubSpot company ID"
            }
          },
          "required": [
            "company_id"
          ]
        }
      },
      {
        "name": "hubspot_get_recent_engagements",
        "description": "Get recent engagement activities across all contacts and companies",
        "inputSchema": {
          "type": "object",
          "properties": {
            "days": {
              "type": "integer",
              "description": "Number of days to look back (default: 7)"
            },
            "limit": {
              "type": "integer",
              "description": "Maximum number of engagements to return (default: 50)"
            }
          }
        }
      },
      {
        "name": "hubspot_get_active_companies",
        "description": "Get most recently active companies from HubSpot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of companies to return (default: 10)"
            }
          }
        }
      },
      {
        "name": "hubspot_get_active_contacts",
        "description": "Get most recently active contacts from HubSpot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of contacts to return (default: 10)"
            }
          }
        }
      }
    ]
  },
  "ticketmaster": {
    "name": "ticketmaster",
    "display_name": "Ticketmaster",
    "description": "Search for events, venues, and attractions through the Ticketmaster Discovery API",
    "repository": {
      "type": "git",
      "url": "https://github.com/delorenj/mcp-server-ticketmaster"
    },
    "homepage": "https://github.com/delorenj/mcp-server-ticketmaster",
    "author": {
      "name": "delorenj"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "ticketmaster",
      "events",
      "venues",
      "attractions"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@delorenj/mcp-server-ticketmaster"
        ],
        "env": {
          "TICKETMASTER_API_KEY": "${TICKETMASTER_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Structured JSON Output",
        "description": "Example of structured JSON output for searching events.",
        "prompt": "<use_mcp_tool>\n<server_name>ticketmaster</server_name>\n<tool_name>search_ticketmaster</tool_name>\n<arguments>\n{\n  \"type\": \"event\",\n  \"keyword\": \"concert\",\n  \"startDate\": \"2025-02-01\",\n  \"endDate\": \"2025-02-28\",\n  \"city\": \"New York\",\n  \"stateCode\": \"NY\"\n}\n</arguments>\n</use_mcp_tool>"
      },
      {
        "title": "Human-Readable Text Output",
        "description": "Example of human-readable text output for searching events.",
        "prompt": "<use_mcp_tool>\n<server_name>ticketmaster</server_name>\n<tool_name>search_ticketmaster</tool_name>\n<arguments>\n{\n  \"type\": \"event\",\n  \"keyword\": \"concert\",\n  \"startDate\": \"2025-02-01\",\n  \"endDate\": \"2025-02-28\",\n  \"city\": \"New York\",\n  \"stateCode\": \"NY\",\n  \"format\": \"text\"\n}\n</arguments>\n</use_mcp_tool>"
      }
    ],
    "arguments": {
      "TICKETMASTER_API_KEY": {
        "description": "API key required to access the Ticketmaster Discovery API.",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "tools": [
      {
        "name": "search_ticketmaster",
        "description": "Search for events, venues, or attractions on Ticketmaster",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "event",
                "venue",
                "attraction"
              ],
              "description": "Type of search to perform"
            },
            "keyword": {
              "type": "string",
              "description": "Search keyword or term"
            },
            "startDate": {
              "type": "string",
              "description": "Start date in YYYY-MM-DD format"
            },
            "endDate": {
              "type": "string",
              "description": "End date in YYYY-MM-DD format"
            },
            "city": {
              "type": "string",
              "description": "City name"
            },
            "stateCode": {
              "type": "string",
              "description": "State code (e.g., NY, CA)"
            },
            "countryCode": {
              "type": "string",
              "description": "Country code (e.g., US, CA)"
            },
            "venueId": {
              "type": "string",
              "description": "Specific venue ID to search"
            },
            "attractionId": {
              "type": "string",
              "description": "Specific attraction ID to search"
            },
            "classificationName": {
              "type": "string",
              "description": "Event classification/category (e.g., \"Sports\", \"Music\")"
            },
            "format": {
              "type": "string",
              "enum": [
                "json",
                "text"
              ],
              "description": "Output format (defaults to json)",
              "default": "json"
            }
          },
          "required": [
            "type"
          ]
        }
      }
    ]
  },
  "figma": {
    "name": "figma",
    "display_name": "Figma",
    "description": "Give your coding agent direct access to Figma file data, helping it one-shot design implementation.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GLips/Figma-Context-MCP"
    },
    "homepage": "https://github.com/GLips/Figma-Context-MCP",
    "author": {
      "name": "GLips"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "Figma",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "figma-developer-mcp",
          "--figma-api-key=${FIGMA_API_KEY}",
          "--stdio"
        ]
      }
    },
    "arguments": {
      "FIGMA_API_KEY": {
        "description": "Your Figma API access token (required)",
        "required": true,
        "example": "<your-figma-api-key>"
      }
    },
    "tools": [
      {
        "name": "get_figma_data",
        "description": "When the nodeId cannot be obtained, obtain the layout information about the entire Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The key of the Figma file to fetch, often found in a provided URL like figma.com/(file|design)/<fileKey>/..."
            },
            "nodeId": {
              "type": "string",
              "description": "The ID of the node to fetch, often found as URL parameter node-id=<nodeId>, always use if provided"
            },
            "depth": {
              "type": "number",
              "description": "How many levels deep to traverse the node tree, only use if explicitly requested by the user"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "download_figma_images",
        "description": "Download SVG and PNG images used in a Figma file based on the IDs of image or icon nodes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The key of the Figma file containing the node"
            },
            "nodes": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "nodeId": {
                    "type": "string",
                    "description": "The ID of the Figma image node to fetch, formatted as 1234:5678"
                  },
                  "imageRef": {
                    "type": "string",
                    "description": "If a node has an imageRef fill, you must include this variable. Leave blank when downloading Vector SVG images."
                  },
                  "fileName": {
                    "type": "string",
                    "description": "The local name for saving the fetched file"
                  }
                },
                "required": [
                  "nodeId",
                  "fileName"
                ],
                "additionalProperties": false
              },
              "description": "The nodes to fetch as images"
            },
            "localPath": {
              "type": "string",
              "description": "The absolute path to the directory where images are stored in the project. Automatically creates directories if needed."
            }
          },
          "required": [
            "fileKey",
            "nodes",
            "localPath"
          ]
        }
      }
    ]
  },
  "riza-mcp": {
    "display_name": "Riza MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/riza-io/riza-mcp"
    },
    "homepage": "https://riza.io",
    "author": {
      "name": "riza-io"
    },
    "license": "MIT",
    "tags": [
      "code interpreter",
      "LLM",
      "tools"
    ],
    "arguments": {
      "RIZA_API_KEY": {
        "description": "API key for Riza service",
        "required": true,
        "example": "your-api-key"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@riza-io/riza-mcp"
        ],
        "env": {
          "RIZA_API_KEY": "your-api-key"
        },
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Configure with Claude Desktop",
        "description": "Configuration for Claude Desktop",
        "prompt": "{\n  \"mcpServers\": {\n    \"riza-server\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"@riza-io/riza-mcp\"\n      ],\n      \"env\": {\n        \"RIZA_API_KEY\": \"your-api-key\"\n      }\n    }\n  }\n}"
      }
    ],
    "name": "riza-mcp",
    "description": "[Riza](https://riza.io) offers an isolated code interpreter for your LLM-generated code.",
    "categories": [
      "Dev Tools"
    ],
    "tools": [
      {
        "name": "create_tool",
        "description": "Create a new tool. This tool will be used to create new tools. You can use the tools you have created to perform tasks.",
        "inputSchema": {
          "type": "object",
          "required": [
            "name",
            "description",
            "code",
            "input_schema",
            "language"
          ],
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the tool you are writing. This is what you will use to call the tool."
            },
            "description": {
              "type": "string",
              "description": "A description of the tool you are writing. This will help you or other agents or people pick the appropriate tool in the future."
            },
            "code": {
              "type": "string",
              "description": "The Typescript code for the tool you are writing. The code should be a valid Typescript function named `execute` that takes one argument called `input`. When called, the `input` provided will match the schema of the `input_schema` of the tool."
            },
            "input_schema": {
              "type": "object",
              "description": "The input schema for the tool. This must be provided as a valid JSON Schema object."
            },
            "language": {
              "type": "string",
              "description": "The language of the tool you are writing. This must be either 'TYPESCRIPT' or 'PYTHON'."
            }
          }
        }
      },
      {
        "name": "fetch_tool",
        "description": "Fetch a tool, including its source code.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tool_id": {
              "type": "string",
              "description": "The ID of the tool to fetch."
            }
          }
        }
      },
      {
        "name": "edit_tool",
        "description": "Edit a tool, including its source code. Omit properties that you do not want to change.",
        "inputSchema": {
          "type": "object",
          "required": [
            "tool_id",
            "code",
            "language",
            "input_schema"
          ],
          "properties": {
            "tool_id": {
              "type": "string",
              "description": "The ID of the tool you are editing."
            },
            "name": {
              "type": "string",
              "description": "The name of the tool you are editing. This is what you will use to call the tool."
            },
            "description": {
              "type": "string",
              "description": "A description of the tool you are editing. This will help you or other agents or people pick the appropriate tool in the future."
            },
            "code": {
              "type": "string",
              "description": "The Typescript code for the tool you are editing. The code should be a valid Typescript function named `execute` that takes one argument called `input`. When called, the `input` provided will match the schema of the `input_schema` of the tool."
            },
            "input_schema": {
              "type": "object",
              "description": "The input schema for the tool. This must be provided as a valid JSON Schema object."
            },
            "language": {
              "type": "string",
              "description": "The language of the tool you are editing. This must be either 'TYPESCRIPT' or 'PYTHON'."
            }
          }
        }
      },
      {
        "name": "execute_code",
        "description": "Execute arbitrary Typescript or Python code.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "The code you are writing. This will be executed as a script. Write any output to stdout or stderr."
            },
            "language": {
              "type": "string",
              "description": "The language of the code you are writing. This must be either 'TYPESCRIPT' or 'PYTHON'."
            }
          }
        }
      },
      {
        "name": "list_tools",
        "description": "Lists the tool definitions of all self-written tools available for use. These tools can be used by calling `use_tool` with the name and input.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "execute_tool",
        "description": "Executes a tool. This tool will be used to execute a self-written tool.",
        "inputSchema": {
          "type": "object",
          "required": [
            "tool_id",
            "input"
          ],
          "properties": {
            "tool_id": {
              "type": "string",
              "description": "The ID of the tool you are executing."
            },
            "input": {
              "type": "object",
              "description": "The input to the tool. This must match the input schema of the tool."
            }
          }
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "uns-mcp": {
    "display_name": "Unstructured API MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/Unstructured-IO/UNS-MCP"
    },
    "homepage": "https://docs.unstructured.io/",
    "author": {
      "name": "Unstructured-IO"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "unstructured",
      "api",
      "document processing",
      "workflow",
      "connectors"
    ],
    "arguments": {
      "UNSTRUCTURED_API_KEY": {
        "description": "API key for the Unstructured platform",
        "required": true,
        "example": "YOUR_KEY"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "uns_mcp"
        ],
        "env": {
          "UNSTRUCTURED_API_KEY": "YOUR_KEY"
        },
        "description": "Run using Python with uv",
        "recommended": true
      }
    },
    "name": "uns-mcp",
    "description": "An MCP server implementation for interacting with the Unstructured API. This server provides tools to list sources and workflows.",
    "categories": [
      "Knowledge Base"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "create_s3_source",
        "description": "Create an S3 source connector.\n\n    Args:\n        name: A unique name for this connector\n        remote_url: The S3 URI to the bucket or folder (e.g., s3://my-bucket/)\n        recursive: Whether to access subfolders within the bucket\n\n    Returns:\n        String containing the created source connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "remote_url": {
              "title": "Remote Url",
              "type": "string"
            },
            "recursive": {
              "default": false,
              "title": "Recursive",
              "type": "boolean"
            }
          },
          "required": [
            "name",
            "remote_url"
          ],
          "title": "create_s3_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "update_s3_source",
        "description": "Update an S3 source connector.\n\n    Args:\n        source_id: ID of the source connector to update\n        remote_url: The S3 URI to the bucket or folder\n        recursive: Whether to access subfolders within the bucket\n\n    Returns:\n        String containing the updated source connector information\n    ",
        "inputSchema": {
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            },
            "remote_url": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Remote Url"
            },
            "recursive": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Recursive"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "update_s3_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_s3_source",
        "description": "Delete an S3 source connector.\n\n    Args:\n        source_id: ID of the source connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "delete_s3_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "create_azure_source",
        "description": "Create an Azure source connector.\n\n    Args:\n        name: A unique name for this connector\n        remote_url: The Azure Storage remote URL,\n        with the format az://<container-name>/<path/to/file/or/folder/in/container/as/needed>\n        recursive: Whether to access subfolders within the bucket\n\n    Returns:\n        String containing the created source connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "remote_url": {
              "title": "Remote Url",
              "type": "string"
            },
            "recursive": {
              "default": false,
              "title": "Recursive",
              "type": "boolean"
            }
          },
          "required": [
            "name",
            "remote_url"
          ],
          "title": "create_azure_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "update_azure_source",
        "description": "Update an azure source connector.\n\n    Args:\n        source_id: ID of the source connector to update\n        remote_url: The Azure Storage remote URL, with the format\n        az://<container-name>/<path/to/file/or/folder/in/container/as/needed>\n        recursive: Whether to access subfolders within the bucket\n\n    Returns:\n        String containing the updated source connector information\n    ",
        "inputSchema": {
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            },
            "remote_url": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Remote Url"
            },
            "recursive": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Recursive"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "update_azure_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_azure_source",
        "description": "Delete an azure source connector.\n\n    Args:\n        source_id: ID of the source connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "delete_azure_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "create_gdrive_source",
        "description": "Create a gdrive source connector.\n\n    Args:\n        name: A unique name for this connector\n        remote_url: The gdrive URI to the bucket or folder (e.g., gdrive://my-bucket/)\n        recursive: Whether to access subfolders within the bucket\n\n    Returns:\n        String containing the created source connector information\n    ",
        "inputSchema": {
          "$defs": {
            "Nullable_List_str__": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ]
            },
            "OptionalNullable_List_str__": {
              "anyOf": [
                {
                  "$ref": "#/$defs/Nullable_List_str__"
                },
                {
                  "$ref": "#/$defs/Unset"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Unset": {
              "properties": {},
              "title": "Unset",
              "type": "object"
            }
          },
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "drive_id": {
              "title": "Drive Id",
              "type": "string"
            },
            "recursive": {
              "default": false,
              "title": "Recursive",
              "type": "boolean"
            },
            "extensions": {
              "$ref": "#/$defs/OptionalNullable_List_str__",
              "default": "~?~unset~?~sentinel~?~"
            }
          },
          "required": [
            "name",
            "drive_id"
          ],
          "title": "create_gdrive_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "update_gdrive_source",
        "description": "Update an gdrive source connector.\n\n    Args:\n        source_id: ID of the source connector to update\n        remote_url: The gdrive URI to the bucket or folder\n        recursive: Whether to access subfolders within the bucket\n\n    Returns:\n        String containing the updated source connector information\n    ",
        "inputSchema": {
          "$defs": {
            "Nullable_List_str__": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ]
            },
            "OptionalNullable_List_str__": {
              "anyOf": [
                {
                  "$ref": "#/$defs/Nullable_List_str__"
                },
                {
                  "$ref": "#/$defs/Unset"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Unset": {
              "properties": {},
              "title": "Unset",
              "type": "object"
            }
          },
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            },
            "drive_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Drive Id"
            },
            "recursive": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Recursive"
            },
            "extensions": {
              "$ref": "#/$defs/OptionalNullable_List_str__",
              "default": "~?~unset~?~sentinel~?~"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "update_gdrive_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_gdrive_source",
        "description": "Delete an gdrive source connector.\n\n    Args:\n        source_id: ID of the source connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "delete_gdrive_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "create_onedrive_source",
        "description": "Create a OneDrive source connector.\n\n    Args:\n        name: A unique name for this connector\n        path: The path to the target folder in the OneDrive account,\n            starting with the account\u2019s root folder\n        user_pname: The User Principal Name (UPN) for the OneDrive user account in Entra ID.\n            This is typically the user\u2019s email address.\n        recursive: Whether to access subfolders\n        authority_url: The authentication token provider URL for the Entra ID app registration.\n            The default is https://login.microsoftonline.com.\n\n    Returns:\n        String containing the created source connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "path": {
              "title": "Path",
              "type": "string"
            },
            "user_pname": {
              "title": "User Pname",
              "type": "string"
            },
            "recursive": {
              "default": false,
              "title": "Recursive",
              "type": "boolean"
            },
            "authority_url": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "https://login.microsoftonline.com",
              "title": "Authority Url"
            }
          },
          "required": [
            "name",
            "path",
            "user_pname"
          ],
          "title": "create_onedrive_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "update_onedrive_source",
        "description": "Update a OneDrive source connector.\n\n    Args:\n        source_id: ID of the source connector to update\n        path: The path to the target folder in the OneDrive account,\n            starting with the account\u2019s root folder\n        user_pname: The User Principal Name (UPN) for the OneDrive user account in Entra ID.\n            This is typically the user\u2019s email address.\n        recursive: Whether to access subfolders\n        authority_url: The authentication token provider URL for the Entra ID app registration.\n            The default is https://login.microsoftonline.com.\n        tenant: The directory (tenant) ID of the Entra ID app registration.\n        client_id: The application (client) ID of the Microsoft Entra ID app registration\n            that has access to the OneDrive account.\n\n    Returns:\n        String containing the updated source connector information\n    ",
        "inputSchema": {
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            },
            "path": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Path"
            },
            "user_pname": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "User Pname"
            },
            "recursive": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Recursive"
            },
            "authority_url": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Authority Url"
            },
            "tenant": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Tenant"
            },
            "client_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Client Id"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "update_onedrive_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_onedrive_source",
        "description": "Delete a OneDrive source connector.\n\n    Args:\n        source_id: ID of the source connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "delete_onedrive_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "create_s3_destination",
        "description": "Create an S3 destination connector.\n\n    Args:\n        name: A unique name for this connector\n        remote_url: The S3 URI to the bucket or folder\n        key: The AWS access key ID\n        secret: The AWS secret access key\n        token: The AWS STS session token for temporary access (optional)\n        endpoint_url: Custom URL if connecting to a non-AWS S3 bucket\n\n    Returns:\n        String containing the created destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "remote_url": {
              "title": "Remote Url",
              "type": "string"
            }
          },
          "required": [
            "name",
            "remote_url"
          ],
          "title": "create_s3_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "update_s3_destination",
        "description": "Update an S3 destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to update\n        remote_url: The S3 URI to the bucket or folder\n\n    Returns:\n        String containing the updated destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            },
            "remote_url": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Remote Url"
            },
            "recursive": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Recursive"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "update_s3_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_s3_destination",
        "description": "Delete an S3 destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "delete_s3_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "create_weaviate_destination",
        "description": "Create an weaviate vector database destination connector.\n\n    Args:\n        cluster_url: URL of the weaviate cluster\n        collection : Name of the collection to use in the weaviate cluster\n        Note: The collection is a table in the weaviate cluster.\n              In platform, there are dedicated code to generate collection for users\n              here, due to the simplicity of the server, we are not generating it for users.\n\n    Returns:\n        String containing the created destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "cluster_url": {
              "title": "Cluster Url",
              "type": "string"
            },
            "collection": {
              "title": "Collection",
              "type": "string"
            }
          },
          "required": [
            "name",
            "cluster_url",
            "collection"
          ],
          "title": "create_weaviate_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "update_weaviate_destination",
        "description": "Update an weaviate destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to update\n        cluster_url (optional): URL of the weaviate cluster\n        collection (optional): Name of the collection(like a file) to use in the weaviate cluster\n\n    Returns:\n        String containing the updated destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            },
            "cluster_url": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Cluster Url"
            },
            "collection": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Collection"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "update_weaviate_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_weaviate_destination",
        "description": "Delete an weaviate destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "delete_weaviate_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "create_astradb_destination",
        "description": "Create an AstraDB destination connector.\n\n    Args:\n        name: A unique name for this connector\n        collection_name: The name of the collection to use\n        keyspace: The AstraDB keyspace\n        batch_size: The batch size for inserting documents, must be positive (default: 20)\n\n        Note: A collection in AstraDB is a schemaless document store optimized for NoSQL workloads,\n              equivalent to a table in traditional databases.\n              A keyspace is the top-level namespace in AstraDB that groups multiple collections.\n              We require the users to create their own collection and keyspace before\n              creating the connector.\n\n    Returns:\n        String containing the created destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "collection_name": {
              "title": "Collection Name",
              "type": "string"
            },
            "keyspace": {
              "title": "Keyspace",
              "type": "string"
            },
            "batch_size": {
              "default": 20,
              "title": "Batch Size",
              "type": "integer"
            }
          },
          "required": [
            "name",
            "collection_name",
            "keyspace"
          ],
          "title": "create_astradb_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "update_astradb_destination",
        "description": "Update an AstraDB destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to update\n        collection_name: The name of the collection to use (optional)\n        keyspace: The AstraDB keyspace (optional)\n        batch_size: The batch size for inserting documents (optional)\n\n        Note: We require the users to create their own collection and\n                keyspace before creating the connector.\n\n    Returns:\n        String containing the updated destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            },
            "collection_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Collection Name"
            },
            "keyspace": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Keyspace"
            },
            "batch_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Batch Size"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "update_astradb_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_astradb_destination",
        "description": "Delete an AstraDB destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "delete_astradb_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "create_neo4j_destination",
        "description": "Create an neo4j destination connector.\n\n    Args:\n        name: A unique name for this connector\n        database: The neo4j database, e.g. \"neo4j\"\n        uri: The neo4j URI, e.g. neo4j+s://<neo4j_instance_id>.databases.neo4j.io\n        username: The neo4j username\n\n\n    Returns:\n        String containing the created destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "database": {
              "title": "Database",
              "type": "string"
            },
            "uri": {
              "title": "Uri",
              "type": "string"
            },
            "username": {
              "title": "Username",
              "type": "string"
            },
            "batch_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 100,
              "title": "Batch Size"
            }
          },
          "required": [
            "name",
            "database",
            "uri",
            "username"
          ],
          "title": "create_neo4j_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "update_neo4j_destination",
        "description": "Update an neo4j destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to update\n        database: The neo4j database, e.g. \"neo4j\"\n        uri: The neo4j URI, e.g. neo4j+s://<neo4j_instance_id>.databases.neo4j.io\n        username: The neo4j username\n\n\n    Returns:\n        String containing the updated destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            },
            "database": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Database"
            },
            "uri": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Uri"
            },
            "username": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Username"
            },
            "batch_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Batch Size"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "update_neo4j_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_neo4j_destination",
        "description": "Delete an neo4j destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "delete_neo4j_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "create_mongodb_destination",
        "description": "Create an MongoDB destination connector.\n\n    Args:\n        name: A unique name for this connector\n        database: The name of the database to connect to.\n        collection: The name of the target MongoDB collection\n    Returns:\n        String containing the created destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "database": {
              "title": "Database",
              "type": "string"
            },
            "collection": {
              "title": "Collection",
              "type": "string"
            }
          },
          "required": [
            "name",
            "database",
            "collection"
          ],
          "title": "create_mongodb_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "update_mongodb_destination",
        "description": "Update an MongoDB destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to update\n        database: The name of the database to connect to.\n        collection: The name of the target MongoDB collection\n\n    Returns:\n        String containing the updated destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            },
            "database": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Database"
            },
            "collection": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Collection"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "update_mongodb_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_mongodb_destination",
        "description": "Delete an MongoDB destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "delete_mongodb_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "create_databricks_volumes_destination",
        "description": "Create an databricks volume destination connector.\n\n    Args:\n        name: A unique name for this connector\n        catalog: Name of the catalog in the Databricks Unity Catalog service for the workspace.\n        host: The Databricks host URL for the Databricks workspace.\n        volume: Name of the volume associated with the schema.\n        schema: Name of the schema associated with the volume. The default value is \"default\".\n        volume_path: Any target folder path within the volume, starting from the root of the volume.\n    Returns:\n        String containing the created destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "catalog": {
              "title": "Catalog",
              "type": "string"
            },
            "volume": {
              "title": "Volume",
              "type": "string"
            },
            "host": {
              "title": "Host",
              "type": "string"
            },
            "schema": {
              "default": "default",
              "title": "Schema",
              "type": "string"
            },
            "volume_path": {
              "default": "/",
              "title": "Volume Path",
              "type": "string"
            }
          },
          "required": [
            "name",
            "catalog",
            "volume",
            "host"
          ],
          "title": "create_databricks_volumes_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "update_databricks_volumes_destination",
        "description": "Update an databricks volumes destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to update\n        catalog: Name of the catalog to update in the Databricks Unity Catalog\n        service for the workspace.\n        host: The Databricks host URL for the Databricks workspace to update.\n        volume: Name of the volume associated with the schema to update.\n        schema: Name of the schema associated with the volume to update.\n        The default value is \"default\".\n        volume_path: Any target folder path within the volume to update,\n        starting from the root of the volume.\n\n\n\n    Returns:\n        String containing the updated destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            },
            "catalog": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Catalog"
            },
            "volume": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Volume"
            },
            "host": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Host"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema"
            },
            "volume_path": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Volume Path"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "update_databricks_volumes_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_databricks_volumes_destination",
        "description": "Delete an databricks volumes destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "delete_databricks_volumes_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "create_databricks_delta_table_destination",
        "description": "Create an databricks volume destination connector.\n\n    Args:\n        name: A unique name for this connector\n        catalog: Name of the catalog in the Databricks Unity Catalog service for the workspace.\n        database: The name of the schema (formerly known as a database)\n        in Unity Catalog for the target table\n        http_path: The cluster\u2019s or SQL warehouse\u2019s HTTP Path value\n        server_hostname: The Databricks cluster\u2019s or SQL warehouse\u2019s Server Hostname value\n        table_name: The name of the table in the schema\n        volume: Name of the volume associated with the schema.\n        schema: Name of the schema associated with the volume. The default value is \"default\".\n        volume_path: Any target folder path within the volume, starting from the root of the volume.\n    Returns:\n        String containing the created destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "catalog": {
              "title": "Catalog",
              "type": "string"
            },
            "database": {
              "title": "Database",
              "type": "string"
            },
            "http_path": {
              "title": "Http Path",
              "type": "string"
            },
            "server_hostname": {
              "title": "Server Hostname",
              "type": "string"
            },
            "table_name": {
              "title": "Table Name",
              "type": "string"
            },
            "volume": {
              "title": "Volume",
              "type": "string"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "default",
              "title": "Schema"
            },
            "volume_path": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "/",
              "title": "Volume Path"
            }
          },
          "required": [
            "name",
            "catalog",
            "database",
            "http_path",
            "server_hostname",
            "table_name",
            "volume"
          ],
          "title": "create_databricks_delta_table_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "update_databricks_delta_table_destination",
        "description": "Update an databricks volumes destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to update\n        database: The name of the schema (formerly known as a database)\n        in Unity Catalog for the target table\n        http_path: The cluster\u2019s or SQL warehouse\u2019s HTTP Path value\n        server_hostname: The Databricks cluster\u2019s or SQL warehouse\u2019s Server Hostname value\n        volume_path: Any target folder path within the volume to update,\n        starting from the root of the volume.\n\n\n\n    Returns:\n        String containing the updated destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            },
            "catalog": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Catalog"
            },
            "database": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Database"
            },
            "http_path": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Http Path"
            },
            "server_hostname": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Server Hostname"
            },
            "table_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Table Name"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema"
            },
            "volume": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Volume"
            },
            "volume_path": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Volume Path"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "update_databricks_delta_table_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_databricks_delta_table_destination",
        "description": "Delete an databricks volumes destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to delete\n\n    Returns:\n        String containing the result of the deletion\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "delete_databricks_delta_table_destinationArguments",
          "type": "object"
        }
      },
      {
        "name": "invoke_firecrawl_crawlhtml",
        "description": "Start an asynchronous web crawl job using Firecrawl to retrieve HTML content.\n\n    Args:\n        url: URL to crawl\n        s3_uri: S3 URI where results will be uploaded\n        limit: Maximum number of pages to crawl (default: 100)\n\n    Returns:\n        Dictionary with crawl job information including the job ID\n    ",
        "inputSchema": {
          "properties": {
            "url": {
              "title": "Url",
              "type": "string"
            },
            "s3_uri": {
              "title": "S3 Uri",
              "type": "string"
            },
            "limit": {
              "default": 100,
              "title": "Limit",
              "type": "integer"
            }
          },
          "required": [
            "url",
            "s3_uri"
          ],
          "title": "invoke_firecrawl_crawlhtmlArguments",
          "type": "object"
        }
      },
      {
        "name": "check_crawlhtml_status",
        "description": "Check the status of an existing Firecrawl HTML crawl job.\n\n    Args:\n        crawl_id: ID of the crawl job to check\n\n    Returns:\n        Dictionary containing the current status of the crawl job\n    ",
        "inputSchema": {
          "properties": {
            "crawl_id": {
              "title": "Crawl Id",
              "type": "string"
            }
          },
          "required": [
            "crawl_id"
          ],
          "title": "check_crawlhtml_statusArguments",
          "type": "object"
        }
      },
      {
        "name": "invoke_firecrawl_llmtxt",
        "description": "Start an asynchronous llmfull.txt generation job using Firecrawl.\n    This file is a standardized markdown file containing information to help LLMs\n    use a website at inference time.\n    The llmstxt endpoint leverages Firecrawl to crawl your website and extracts data\n    using gpt-4o-mini\n    Args:\n        url: URL to crawl\n        s3_uri: S3 URI where results will be uploaded\n        max_urls: Maximum number of pages to crawl (1-100, default: 10)\n\n    Returns:\n        Dictionary with job information including the job ID\n    ",
        "inputSchema": {
          "properties": {
            "url": {
              "title": "Url",
              "type": "string"
            },
            "s3_uri": {
              "title": "S3 Uri",
              "type": "string"
            },
            "max_urls": {
              "default": 10,
              "title": "Max Urls",
              "type": "integer"
            }
          },
          "required": [
            "url",
            "s3_uri"
          ],
          "title": "invoke_firecrawl_llmtxtArguments",
          "type": "object"
        }
      },
      {
        "name": "check_llmtxt_status",
        "description": "Check the status of an existing llmfull.txt generation job.\n\n    Args:\n        job_id: ID of the llmfull.txt generation job to check\n\n    Returns:\n        Dictionary containing the current status of the job and text content if completed\n    ",
        "inputSchema": {
          "properties": {
            "job_id": {
              "title": "Job Id",
              "type": "string"
            }
          },
          "required": [
            "job_id"
          ],
          "title": "check_llmtxt_statusArguments",
          "type": "object"
        }
      },
      {
        "name": "cancel_crawlhtml_job",
        "description": "Cancel an in-progress Firecrawl HTML crawl job.\n\n    Args:\n        crawl_id: ID of the crawl job to cancel\n\n    Returns:\n        Dictionary containing the result of the cancellation\n    ",
        "inputSchema": {
          "properties": {
            "crawl_id": {
              "title": "Crawl Id",
              "type": "string"
            }
          },
          "required": [
            "crawl_id"
          ],
          "title": "cancel_crawlhtml_jobArguments",
          "type": "object"
        }
      },
      {
        "name": "list_sources",
        "description": "\n    List available sources from the Unstructured API.\n\n    Args:\n        source_type: Optional source connector type to filter by\n\n    Returns:\n        String containing the list of sources\n    ",
        "inputSchema": {
          "properties": {
            "source_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Type"
            }
          },
          "title": "list_sourcesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_source_info",
        "description": "Get detailed information about a specific source connector.\n\n    Args:\n        source_id: ID of the source connector to get information for, should be valid UUID\n\n    Returns:\n        String containing the source connector information\n    ",
        "inputSchema": {
          "properties": {
            "source_id": {
              "title": "Source Id",
              "type": "string"
            }
          },
          "required": [
            "source_id"
          ],
          "title": "get_source_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "list_destinations",
        "description": "List available destinations from the Unstructured API.\n\n    Args:\n        destination_type: Optional destination connector type to filter by\n\n    Returns:\n        String containing the list of destinations\n    ",
        "inputSchema": {
          "properties": {
            "destination_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Destination Type"
            }
          },
          "title": "list_destinationsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_destination_info",
        "description": "Get detailed information about a specific destination connector.\n\n    Args:\n        destination_id: ID of the destination connector to get information for\n\n    Returns:\n        String containing the destination connector information\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "title": "Destination Id",
              "type": "string"
            }
          },
          "required": [
            "destination_id"
          ],
          "title": "get_destination_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "list_workflows",
        "description": "\n    List workflows from the Unstructured API.\n\n    Args:\n        destination_id: Optional destination connector ID to filter by\n        source_id: Optional source connector ID to filter by\n        status: Optional workflow status to filter by\n\n    Returns:\n        String containing the list of workflows\n    ",
        "inputSchema": {
          "properties": {
            "destination_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Destination Id"
            },
            "source_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Id"
            },
            "status": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Status"
            }
          },
          "title": "list_workflowsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_workflow_info",
        "description": "Get detailed information about a specific workflow.\n\n    Args:\n        workflow_id: ID of the workflow to get information for\n\n    Returns:\n        String containing the workflow information\n    ",
        "inputSchema": {
          "properties": {
            "workflow_id": {
              "title": "Workflow Id",
              "type": "string"
            }
          },
          "required": [
            "workflow_id"
          ],
          "title": "get_workflow_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "create_workflow",
        "description": "Create a new workflow.\n\n    Args:\n        workflow_config: A Typed Dictionary containing required fields (destination_id - should be a\n        valid UUID, name, source_id - should be a valid UUID, workflow_type) and non-required fields\n        (schedule, and workflow_nodes). Note workflow_nodes is only enabled when workflow_type\n        is `custom` and is a list of WorkflowNodeTypedDict: partition, prompter,chunk, embed\n        Below is an example of a partition workflow node:\n            {\n                \"name\": \"vlm-partition\",\n                \"type\": \"partition\",\n                \"sub_type\": \"vlm\",\n                \"settings\": {\n                            \"provider\": \"your favorite provider\",\n                            \"model\": \"your favorite model\"\n                            }\n            }\n\n\n    Returns:\n        String containing the created workflow information\n    \n\nCustom workflow DAG nodes\n- If WorkflowType is set to custom, you must also specify the settings for the workflow\u2019s\ndirected acyclic graph (DAG) nodes. These nodes\u2019 settings are specified in the workflow_nodes array.\n- A Source node is automatically created when you specify the source_id value outside of the\nworkflow_nodes array.\n- A Destination node is automatically created when you specify the destination_id value outside\nof the workflow_nodes array.\n- You can specify Partitioner, Chunker, Prompter, and Embedder nodes.\n- The order of the nodes in the workflow_nodes array will be the same order that these nodes appear\nin the DAG, with the first node in the array added directly after the Source node.\nThe Destination node follows the last node in the array.\n- Be sure to specify nodes in the allowed order. The following DAG placements are all allowed:\n    - Source -> Partitioner -> Destination,\n    - Source -> Partitioner -> Chunker -> Destination,\n    - Source -> Partitioner -> Chunker -> Embedder -> Destination,\n    - Source -> Partitioner -> Prompter -> Chunker -> Destination,\n    - Source -> Partitioner -> Prompter -> Chunker -> Embedder -> Destination\n\nPartitioner node\nA Partitioner node has a type of partition and a subtype of auto, vlm, hi_res, or fast.\n\nExamples:\n- auto strategy:\n{\n    \"name\": \"Partitioner\",\n    \"type\": \"partition\",\n    \"subtype\": \"vlm\",\n    \"settings\": {\n        \"provider\": \"anthropic\", (required)\n        \"model\": \"claude-3-5-sonnet-20241022\", (required)\n        \"output_format\": \"text/html\",\n        \"user_prompt\": null,\n        \"format_html\": true,\n        \"unique_element_ids\": true,\n        \"is_dynamic\": true,\n        \"allow_fast\": true\n    }\n}\n\n- vlm strategy:\n    Allowed values are provider and model. Below are examples:\n        - \"provider\": \"anthropic\" \"model\": \"claude-3-5-sonnet-20241022\",\n        - \"provider\": \"openai\" \"model\": \"gpt-4o\"\n\n\n- hi_res strategy:\n{\n    \"name\": \"Partitioner\",\n    \"type\": \"partition\",\n    \"subtype\": \"unstructured_api\",\n    \"settings\": {\n        \"strategy\": \"hi_res\",\n        \"include_page_breaks\": <true|false>,\n        \"pdf_infer_table_structure\": <true|false>,\n        \"exclude_elements\": [\n            \"<element-name>\",\n            \"<element-name>\"\n        ],\n        \"xml_keep_tags\": <true|false>,\n        \"encoding\": \"<encoding>\",\n        \"ocr_languages\": [\n            \"<language>\",\n            \"<language>\"\n        ],\n        \"extract_image_block_types\": [\n            \"image\",\n            \"table\"\n        ],\n        \"infer_table_structure\": <true|false>\n    }\n}\n- fast strategy\n{\n    \"name\": \"Partitioner\",\n    \"type\": \"partition\",\n    \"subtype\": \"unstructured_api\",\n    \"settings\": {\n        \"strategy\": \"fast\",\n        \"include_page_breaks\": <true|false>,\n        \"pdf_infer_table_structure\": <true|false>,\n        \"exclude_elements\": [\n            \"<element-name>\",\n            \"<element-name>\"\n        ],\n        \"xml_keep_tags\": <true|false>,\n        \"encoding\": \"<encoding>\",\n        \"ocr_languages\": [\n            \"<language-code>\",\n            \"<language-code>\"\n        ],\n        \"extract_image_block_types\": [\n            \"image\",\n            \"table\"\n        ],\n        \"infer_table_structure\": <true|false>\n    }\n}\n\n\nChunker node\nA Chunker node has a type of chunk and subtype of chunk_by_character or chunk_by_title.\n\n- chunk_by_character\n{\n    \"name\": \"Chunker\",\n    \"type\": \"chunk\",\n    \"subtype\": \"chunk_by_character\",\n    \"settings\": {\n        \"include_orig_elements\": <true|false>,\n        \"new_after_n_chars\": <new-after-n-chars>, (required, if not provided\nset same as max_characters)\n        \"max_characters\": <max-characters>, (required)\n        \"overlap\": <overlap>, (required, if not provided set default to 0)\n        \"overlap_all\": <true|false>,\n        \"contextual_chunking_strategy\": \"v1\"\n    }\n}\n\n- chunk_by_title\n{\n    \"name\": \"Chunker\",\n    \"type\": \"chunk\",\n    \"subtype\": \"chunk_by_title\",\n    \"settings\": {\n        \"multipage_sections\": <true|false>,\n        \"combine_text_under_n_chars\": <combine-text-under-n-chars>,\n        \"include_orig_elements\": <true|false>,\n        \"new_after_n_chars\": <new-after-n-chars>,  (required, if not provided\nset same as max_characters)\n        \"max_characters\": <max-characters>, (required)\n        \"overlap\": <overlap>,  (required, if not provided set default to 0)\n        \"overlap_all\": <true|false>,\n        \"contextual_chunking_strategy\": \"v1\"\n    }\n}\n\n\nPrompter node\nAn Prompter node has a type of prompter and subtype of:\n- openai_image_description,\n- anthropic_image_description,\n- bedrock_image_description,\n- vertexai_image_description,\n- openai_table_description,\n- anthropic_table_description,\n- bedrock_table_description,\n- vertexai_table_description,\n- openai_table2html,\n- openai_ner\n\nExample:\n{\n    \"name\": \"Prompter\",\n    \"type\": \"prompter\",\n    \"subtype\": \"<subtype>\",\n    \"settings\": {}\n}\n\n\nEmbedder node\nAn Embedder node has a type of embed\n\nAllowed values for subtype and model_name include:\n\n- \"subtype\": \"azure_openai\"\n    - \"model_name\": \"text-embedding-3-small\"\n    - \"model_name\": \"text-embedding-3-large\"\n    - \"model_name\": \"text-embedding-ada-002\"\n- \"subtype\": \"bedrock\"\n    - \"model_name\": \"amazon.titan-embed-text-v2:0\"\n    - \"model_name\": \"amazon.titan-embed-text-v1\"\n    - \"model_name\": \"amazon.titan-embed-image-v1\"\n    - \"model_name\": \"cohere.embed-english-v3\"\n    - \"model_name\": \"cohere.embed-multilingual-v3\"\n- \"subtype\": \"togetherai\":\n    - \"model_name\": \"togethercomputer/m2-bert-80M-2k-retrieval\"\n    - \"model_name\": \"togethercomputer/m2-bert-80M-8k-retrieval\"\n    - \"model_name\": \"togethercomputer/m2-bert-80M-32k-retrieval\"\n\nExample:\n{\n    \"name\": \"Embedder\",\n    \"type\": \"embed\",\n    \"subtype\": \"<subtype>\",\n    \"settings\": {\n        \"model_name\": \"<model-name>\"\n    }\n}\n",
        "inputSchema": {
          "$defs": {
            "CreateWorkflowTypedDict": {
              "properties": {
                "name": {
                  "title": "Name",
                  "type": "string"
                },
                "workflow_type": {
                  "$ref": "#/$defs/WorkflowType"
                },
                "destination_id": {
                  "$ref": "#/$defs/Nullable_str_"
                },
                "schedule": {
                  "$ref": "#/$defs/Nullable_Schedule_"
                },
                "source_id": {
                  "$ref": "#/$defs/Nullable_str_"
                },
                "workflow_nodes": {
                  "$ref": "#/$defs/Nullable_List_WorkflowNodeTypedDict__"
                }
              },
              "required": [
                "name",
                "workflow_type"
              ],
              "title": "CreateWorkflowTypedDict",
              "type": "object"
            },
            "Nullable_Dict_str__Any__": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Nullable_List_WorkflowNodeTypedDict__": {
              "anyOf": [
                {
                  "items": {
                    "$ref": "#/$defs/WorkflowNodeTypedDict"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Nullable_Schedule_": {
              "anyOf": [
                {
                  "$ref": "#/$defs/Schedule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Nullable_str_": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Schedule": {
              "enum": [
                "every 15 minutes",
                "every hour",
                "every 2 hours",
                "every 4 hours",
                "every 6 hours",
                "every 8 hours",
                "every 10 hours",
                "every 12 hours",
                "daily",
                "weekly",
                "monthly"
              ],
              "title": "Schedule",
              "type": "string"
            },
            "WorkflowNodeType": {
              "enum": [
                "partition",
                "prompter",
                "chunk",
                "embed"
              ],
              "title": "WorkflowNodeType",
              "type": "string"
            },
            "WorkflowNodeTypedDict": {
              "properties": {
                "name": {
                  "title": "Name",
                  "type": "string"
                },
                "subtype": {
                  "title": "Subtype",
                  "type": "string"
                },
                "type": {
                  "$ref": "#/$defs/WorkflowNodeType"
                },
                "id": {
                  "$ref": "#/$defs/Nullable_str_"
                },
                "settings": {
                  "$ref": "#/$defs/Nullable_Dict_str__Any__"
                }
              },
              "required": [
                "name",
                "subtype",
                "type"
              ],
              "title": "WorkflowNodeTypedDict",
              "type": "object"
            },
            "WorkflowType": {
              "enum": [
                "basic",
                "advanced",
                "platinum",
                "custom"
              ],
              "title": "WorkflowType",
              "type": "string"
            }
          },
          "properties": {
            "workflow_config": {
              "$ref": "#/$defs/CreateWorkflowTypedDict"
            }
          },
          "required": [
            "workflow_config"
          ],
          "title": "create_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "run_workflow",
        "description": "Run a specific workflow.\n\n    Args:\n        workflow_id: ID of the workflow to run\n\n    Returns:\n        String containing the response from the workflow execution\n    ",
        "inputSchema": {
          "properties": {
            "workflow_id": {
              "title": "Workflow Id",
              "type": "string"
            }
          },
          "required": [
            "workflow_id"
          ],
          "title": "run_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "update_workflow",
        "description": "Update an existing workflow.\n\n    Args:\n        workflow_id: ID of the workflow to update\n        workflow_config: A Typed Dictionary containing required fields (destination_id,\n        name, source_id, workflow_type) and non-required fields (schedule, and workflow_nodes)\n\n    Returns:\n        String containing the updated workflow information\n    \n\nCustom workflow DAG nodes\n- If WorkflowType is set to custom, you must also specify the settings for the workflow\u2019s\ndirected acyclic graph (DAG) nodes. These nodes\u2019 settings are specified in the workflow_nodes array.\n- A Source node is automatically created when you specify the source_id value outside of the\nworkflow_nodes array.\n- A Destination node is automatically created when you specify the destination_id value outside\nof the workflow_nodes array.\n- You can specify Partitioner, Chunker, Prompter, and Embedder nodes.\n- The order of the nodes in the workflow_nodes array will be the same order that these nodes appear\nin the DAG, with the first node in the array added directly after the Source node.\nThe Destination node follows the last node in the array.\n- Be sure to specify nodes in the allowed order. The following DAG placements are all allowed:\n    - Source -> Partitioner -> Destination,\n    - Source -> Partitioner -> Chunker -> Destination,\n    - Source -> Partitioner -> Chunker -> Embedder -> Destination,\n    - Source -> Partitioner -> Prompter -> Chunker -> Destination,\n    - Source -> Partitioner -> Prompter -> Chunker -> Embedder -> Destination\n\nPartitioner node\nA Partitioner node has a type of partition and a subtype of auto, vlm, hi_res, or fast.\n\nExamples:\n- auto strategy:\n{\n    \"name\": \"Partitioner\",\n    \"type\": \"partition\",\n    \"subtype\": \"vlm\",\n    \"settings\": {\n        \"provider\": \"anthropic\", (required)\n        \"model\": \"claude-3-5-sonnet-20241022\", (required)\n        \"output_format\": \"text/html\",\n        \"user_prompt\": null,\n        \"format_html\": true,\n        \"unique_element_ids\": true,\n        \"is_dynamic\": true,\n        \"allow_fast\": true\n    }\n}\n\n- vlm strategy:\n    Allowed values are provider and model. Below are examples:\n        - \"provider\": \"anthropic\" \"model\": \"claude-3-5-sonnet-20241022\",\n        - \"provider\": \"openai\" \"model\": \"gpt-4o\"\n\n\n- hi_res strategy:\n{\n    \"name\": \"Partitioner\",\n    \"type\": \"partition\",\n    \"subtype\": \"unstructured_api\",\n    \"settings\": {\n        \"strategy\": \"hi_res\",\n        \"include_page_breaks\": <true|false>,\n        \"pdf_infer_table_structure\": <true|false>,\n        \"exclude_elements\": [\n            \"<element-name>\",\n            \"<element-name>\"\n        ],\n        \"xml_keep_tags\": <true|false>,\n        \"encoding\": \"<encoding>\",\n        \"ocr_languages\": [\n            \"<language>\",\n            \"<language>\"\n        ],\n        \"extract_image_block_types\": [\n            \"image\",\n            \"table\"\n        ],\n        \"infer_table_structure\": <true|false>\n    }\n}\n- fast strategy\n{\n    \"name\": \"Partitioner\",\n    \"type\": \"partition\",\n    \"subtype\": \"unstructured_api\",\n    \"settings\": {\n        \"strategy\": \"fast\",\n        \"include_page_breaks\": <true|false>,\n        \"pdf_infer_table_structure\": <true|false>,\n        \"exclude_elements\": [\n            \"<element-name>\",\n            \"<element-name>\"\n        ],\n        \"xml_keep_tags\": <true|false>,\n        \"encoding\": \"<encoding>\",\n        \"ocr_languages\": [\n            \"<language-code>\",\n            \"<language-code>\"\n        ],\n        \"extract_image_block_types\": [\n            \"image\",\n            \"table\"\n        ],\n        \"infer_table_structure\": <true|false>\n    }\n}\n\n\nChunker node\nA Chunker node has a type of chunk and subtype of chunk_by_character or chunk_by_title.\n\n- chunk_by_character\n{\n    \"name\": \"Chunker\",\n    \"type\": \"chunk\",\n    \"subtype\": \"chunk_by_character\",\n    \"settings\": {\n        \"include_orig_elements\": <true|false>,\n        \"new_after_n_chars\": <new-after-n-chars>, (required, if not provided\nset same as max_characters)\n        \"max_characters\": <max-characters>, (required)\n        \"overlap\": <overlap>, (required, if not provided set default to 0)\n        \"overlap_all\": <true|false>,\n        \"contextual_chunking_strategy\": \"v1\"\n    }\n}\n\n- chunk_by_title\n{\n    \"name\": \"Chunker\",\n    \"type\": \"chunk\",\n    \"subtype\": \"chunk_by_title\",\n    \"settings\": {\n        \"multipage_sections\": <true|false>,\n        \"combine_text_under_n_chars\": <combine-text-under-n-chars>,\n        \"include_orig_elements\": <true|false>,\n        \"new_after_n_chars\": <new-after-n-chars>,  (required, if not provided\nset same as max_characters)\n        \"max_characters\": <max-characters>, (required)\n        \"overlap\": <overlap>,  (required, if not provided set default to 0)\n        \"overlap_all\": <true|false>,\n        \"contextual_chunking_strategy\": \"v1\"\n    }\n}\n\n\nPrompter node\nAn Prompter node has a type of prompter and subtype of:\n- openai_image_description,\n- anthropic_image_description,\n- bedrock_image_description,\n- vertexai_image_description,\n- openai_table_description,\n- anthropic_table_description,\n- bedrock_table_description,\n- vertexai_table_description,\n- openai_table2html,\n- openai_ner\n\nExample:\n{\n    \"name\": \"Prompter\",\n    \"type\": \"prompter\",\n    \"subtype\": \"<subtype>\",\n    \"settings\": {}\n}\n\n\nEmbedder node\nAn Embedder node has a type of embed\n\nAllowed values for subtype and model_name include:\n\n- \"subtype\": \"azure_openai\"\n    - \"model_name\": \"text-embedding-3-small\"\n    - \"model_name\": \"text-embedding-3-large\"\n    - \"model_name\": \"text-embedding-ada-002\"\n- \"subtype\": \"bedrock\"\n    - \"model_name\": \"amazon.titan-embed-text-v2:0\"\n    - \"model_name\": \"amazon.titan-embed-text-v1\"\n    - \"model_name\": \"amazon.titan-embed-image-v1\"\n    - \"model_name\": \"cohere.embed-english-v3\"\n    - \"model_name\": \"cohere.embed-multilingual-v3\"\n- \"subtype\": \"togetherai\":\n    - \"model_name\": \"togethercomputer/m2-bert-80M-2k-retrieval\"\n    - \"model_name\": \"togethercomputer/m2-bert-80M-8k-retrieval\"\n    - \"model_name\": \"togethercomputer/m2-bert-80M-32k-retrieval\"\n\nExample:\n{\n    \"name\": \"Embedder\",\n    \"type\": \"embed\",\n    \"subtype\": \"<subtype>\",\n    \"settings\": {\n        \"model_name\": \"<model-name>\"\n    }\n}\n",
        "inputSchema": {
          "$defs": {
            "CreateWorkflowTypedDict": {
              "properties": {
                "name": {
                  "title": "Name",
                  "type": "string"
                },
                "workflow_type": {
                  "$ref": "#/$defs/WorkflowType"
                },
                "destination_id": {
                  "$ref": "#/$defs/Nullable_str_"
                },
                "schedule": {
                  "$ref": "#/$defs/Nullable_Schedule_"
                },
                "source_id": {
                  "$ref": "#/$defs/Nullable_str_"
                },
                "workflow_nodes": {
                  "$ref": "#/$defs/Nullable_List_WorkflowNodeTypedDict__"
                }
              },
              "required": [
                "name",
                "workflow_type"
              ],
              "title": "CreateWorkflowTypedDict",
              "type": "object"
            },
            "Nullable_Dict_str__Any__": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Nullable_List_WorkflowNodeTypedDict__": {
              "anyOf": [
                {
                  "items": {
                    "$ref": "#/$defs/WorkflowNodeTypedDict"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Nullable_Schedule_": {
              "anyOf": [
                {
                  "$ref": "#/$defs/Schedule"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Nullable_str_": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ]
            },
            "Schedule": {
              "enum": [
                "every 15 minutes",
                "every hour",
                "every 2 hours",
                "every 4 hours",
                "every 6 hours",
                "every 8 hours",
                "every 10 hours",
                "every 12 hours",
                "daily",
                "weekly",
                "monthly"
              ],
              "title": "Schedule",
              "type": "string"
            },
            "WorkflowNodeType": {
              "enum": [
                "partition",
                "prompter",
                "chunk",
                "embed"
              ],
              "title": "WorkflowNodeType",
              "type": "string"
            },
            "WorkflowNodeTypedDict": {
              "properties": {
                "name": {
                  "title": "Name",
                  "type": "string"
                },
                "subtype": {
                  "title": "Subtype",
                  "type": "string"
                },
                "type": {
                  "$ref": "#/$defs/WorkflowNodeType"
                },
                "id": {
                  "$ref": "#/$defs/Nullable_str_"
                },
                "settings": {
                  "$ref": "#/$defs/Nullable_Dict_str__Any__"
                }
              },
              "required": [
                "name",
                "subtype",
                "type"
              ],
              "title": "WorkflowNodeTypedDict",
              "type": "object"
            },
            "WorkflowType": {
              "enum": [
                "basic",
                "advanced",
                "platinum",
                "custom"
              ],
              "title": "WorkflowType",
              "type": "string"
            }
          },
          "properties": {
            "workflow_id": {
              "title": "Workflow Id",
              "type": "string"
            },
            "workflow_config": {
              "$ref": "#/$defs/CreateWorkflowTypedDict"
            }
          },
          "required": [
            "workflow_id",
            "workflow_config"
          ],
          "title": "update_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_workflow",
        "description": "Delete a specific workflow.\n\n    Args:\n        workflow_id: ID of the workflow to delete\n\n    Returns:\n        String containing the response from the workflow deletion\n    ",
        "inputSchema": {
          "properties": {
            "workflow_id": {
              "title": "Workflow Id",
              "type": "string"
            }
          },
          "required": [
            "workflow_id"
          ],
          "title": "delete_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "list_jobs",
        "description": "\n    List jobs via the Unstructured API.\n\n    Args:\n        workflow_id: Optional workflow ID to filter by\n        status: Optional job status to filter by\n\n    Returns:\n        String containing the list of jobs\n    ",
        "inputSchema": {
          "properties": {
            "workflow_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Workflow Id"
            },
            "status": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Status"
            }
          },
          "title": "list_jobsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_job_info",
        "description": "Get detailed information about a specific job.\n\n    Args:\n        job_id: ID of the job to get information for\n\n    Returns:\n        String containing the job information\n    ",
        "inputSchema": {
          "properties": {
            "job_id": {
              "title": "Job Id",
              "type": "string"
            }
          },
          "required": [
            "job_id"
          ],
          "title": "get_job_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "cancel_job",
        "description": "Delete a specific job.\n\n    Args:\n        job_id: ID of the job to cancel\n\n    Returns:\n        String containing the response from the job cancellation\n    ",
        "inputSchema": {
          "properties": {
            "job_id": {
              "title": "Job Id",
              "type": "string"
            }
          },
          "required": [
            "job_id"
          ],
          "title": "cancel_jobArguments",
          "type": "object"
        }
      }
    ]
  },
  "starwind-ui": {
    "name": "starwind-ui",
    "display_name": "Starwind UI",
    "description": "This MCP provides relevant commands, documentation, and other information to allow LLMs to take full advantage of Starwind UI's open source Astro components.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Boston343/starwind-ui-mcp"
    },
    "homepage": "https://github.com/Boston343/starwind-ui-mcp/",
    "author": {
      "name": "Boston343"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Starwind",
      "Developer Tools",
      "AI",
      "Components"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/Boston343/starwind-ui-mcp/"
        ]
      }
    }
  },
  "mcp-server-adfin": {
    "display_name": "Adfin MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/Adfin-Engineering/mcp-server-adfin"
    },
    "license": "[NOT GIVEN]",
    "installations": {
      "python": {
        "type": "python",
        "command": "uv",
        "args": [
          "--directory",
          "<absolute_path_to_adfin_mcp_folder>",
          "run",
          "main_adfin_mcp.py"
        ],
        "env": {
          "ADFIN_EMAIL": "<email>",
          "ADFIN_PASSWORD": "<password>"
        },
        "description": "Run Adfin MCP server using uv"
      },
      "filesystem": {
        "type": "python",
        "command": "uv",
        "args": [
          "--directory",
          "<absolute_path_to_adfin_mcp_folder>",
          "run",
          "filesystem.py"
        ],
        "description": "Run filesystem MCP server using uv"
      }
    },
    "arguments": {
      "ADFIN_EMAIL": {
        "description": "Email for Adfin authentication",
        "required": true
      },
      "ADFIN_PASSWORD": {
        "description": "Password for Adfin authentication",
        "required": true
      }
    },
    "examples": [
      {
        "title": "Request a credit control status",
        "description": "Get credit control status check",
        "prompt": "Give me a credit control status check."
      },
      {
        "title": "Create a new invoice",
        "description": "Create an invoice with specific details",
        "prompt": "Create a new invoice for 60 GBP for Abc Def that is due in a week. His email is abc.def@example.com."
      },
      {
        "title": "Upload multiple invoices",
        "description": "Upload PDF invoices from a folder",
        "prompt": "Upload all pdf invoices from the invoices folder from my Desktop."
      }
    ],
    "tags": [
      "adfin",
      "finance",
      "invoicing"
    ],
    "homepage": "[NOT GIVEN]",
    "author": {
      "name": "Adfin-Engineering"
    },
    "name": "mcp-server-adfin",
    "description": "1. Python 3.10 or higher",
    "categories": [
      "Finance"
    ],
    "is_official": true
  },
  "time": {
    "name": "time",
    "display_name": "Time",
    "description": "A Model Context Protocol server that provides time and timezone conversion capabilities. It automatically detects the system's timezone and offers tools for getting current time and converting between timezones.",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/time#readme",
    "author": {
      "name": "MCP Team"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "time",
      "timezone",
      "date",
      "converter"
    ],
    "arguments": {
      "TZ": {
        "description": "Environment variable to override the system's default timezone",
        "required": false,
        "example": "America/New_York"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-time",
          "--local-timezone=${TZ}"
        ],
        "description": "Install and run using uvx (recommended)",
        "recommended": true
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp_server_time",
          "--local-timezone=${TZ}"
        ],
        "description": "Run with Python module (requires pip install)"
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "mcp/time",
          "--local-timezone=${TZ}"
        ],
        "description": "Run with Docker"
      }
    },
    "tools": [
      {
        "name": "get_current_time",
        "description": "Get current time in a specific timezones",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timezone": {
              "type": "string",
              "description": "IANA timezone name (e.g., 'America/New_York', 'Europe/London'). Use local timezone if no timezone provided by the user."
            }
          },
          "required": [
            "timezone"
          ]
        }
      },
      {
        "name": "convert_time",
        "description": "Convert time between timezones",
        "inputSchema": {
          "type": "object",
          "properties": {
            "source_timezone": {
              "type": "string",
              "description": "Source IANA timezone name (e.g., 'America/New_York', 'Europe/London'). Use local timezone if no source timezone provided by the user."
            },
            "time": {
              "type": "string",
              "description": "Time to convert in 24-hour format (HH:MM)"
            },
            "target_timezone": {
              "type": "string",
              "description": "Target IANA timezone name (e.g., 'Asia/Tokyo', 'America/San_Francisco'). Use local timezone if no target timezone provided by the user."
            }
          },
          "required": [
            "source_timezone",
            "time",
            "target_timezone"
          ]
        }
      }
    ],
    "examples": [
      {
        "title": "Current time",
        "description": "Get the current time in a specific timezone",
        "prompt": "What time is it in Tokyo right now?"
      },
      {
        "title": "Time conversion",
        "description": "Convert time between timezones",
        "prompt": "Convert 3:30 PM EST to Paris time."
      }
    ],
    "is_official": true
  },
  "ableton-live": {
    "name": "ableton-live",
    "display_name": "Ableton Live",
    "description": "an MCP server to control Ableton Live.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Simon-Kansara/ableton-live-mcp-server"
    },
    "homepage": "https://github.com/Simon-Kansara/ableton-live-mcp-server",
    "author": {
      "name": "Simon Kansara"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Ableton Live",
      "OSC",
      "Music"
    ],
    "installations": {
      "custom": {
        "type": "python",
        "command": "python",
        "args": [
          "mcp_ableton_server.py"
        ],
        "description": "Run with Python module (requires git clone)"
      }
    },
    "examples": [
      {
        "title": "Prepare a rock band set for recording",
        "description": "In Claude desktop, ask Claude to prepare a set to record a rock band.",
        "prompt": "_Prepare a set to record a rock band_"
      },
      {
        "title": "Set input routing for tracks",
        "description": "Set the input routing channel of all tracks that have 'voice' in their name to Ext. In 2.",
        "prompt": "_Set the input routing channel of all tracks that have 'voice' in their name to Ext. In 2_"
      }
    ]
  },
  "pandoc": {
    "name": "pandoc",
    "display_name": "Pandoc Document Conversion",
    "description": "MCP server for seamless document format conversion using Pandoc, supporting Markdown, HTML, PDF, DOCX (.docx), csv and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/vivekVells/mcp-pandoc"
    },
    "homepage": "https://github.com/vivekVells/mcp-pandoc",
    "author": {
      "name": "vivekVells"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "pandoc",
      "document",
      "conversion"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-pandoc"
        ]
      }
    },
    "examples": [
      {
        "title": "Convert Markdown to PDF",
        "description": "Converts Markdown content to PDF format and saves it to the specified path.",
        "prompt": "Convert /path/to/input.md to PDF and save as /path/to/output.pdf"
      },
      {
        "title": "Convert Content Directly",
        "description": "Converts a string of content directly to a specific output format.",
        "prompt": "Convert this text to PDF and save as /path/to/document.pdf"
      }
    ],
    "tools": [
      {
        "name": "convert-contents",
        "description": "Converts content between different formats. Transforms input content from any supported format into the specified output format.\n\n\ud83d\udea8 CRITICAL REQUIREMENTS - PLEASE READ:\n1. PDF Conversion:\n   * You MUST install TeX Live BEFORE attempting PDF conversion:\n   * Ubuntu/Debian: `sudo apt-get install texlive-xetex`\n   * macOS: `brew install texlive`\n   * Windows: Install MiKTeX or TeX Live from https://miktex.org/ or https://tug.org/texlive/\n   * PDF conversion will FAIL without this installation\n\n2. File Paths - EXPLICIT REQUIREMENTS:\n   * When asked to save or convert to a file, you MUST provide:\n     - Complete directory path\n     - Filename\n     - File extension\n   * Example request: 'Write a story and save as PDF'\n   * You MUST specify: '/path/to/story.pdf' or 'C:\\Documents\\story.pdf'\n   * The tool will NOT automatically generate filenames or extensions\n\n3. File Location After Conversion:\n   * After successful conversion, the tool will display the exact path where the file is saved\n   * Look for message: 'Content successfully converted and saved to: [file_path]'\n   * You can find your converted file at the specified location\n   * If no path is specified, files may be saved in system temp directory (/tmp/ on Unix systems)\n   * For better control, always provide explicit output file paths\n\nSupported formats:\n- Basic formats: txt, html, markdown\n- Advanced formats (REQUIRE complete file paths): pdf, docx, rst, latex, epub\n\n\u2705 CORRECT Usage Examples:\n1. 'Convert this text to HTML' (basic conversion)\n   - Tool will show converted content\n\n2. 'Save this text as PDF at /documents/story.pdf'\n   - Correct: specifies path + filename + extension\n   - Tool will show: 'Content successfully converted and saved to: /documents/story.pdf'\n\n\u274c INCORRECT Usage Examples:\n1. 'Save this as PDF in /documents/'\n   - Missing filename and extension\n2. 'Convert to PDF'\n   - Missing complete file path\n\nWhen requesting conversion, ALWAYS specify:\n1. The content or input file\n2. The desired output format\n3. For advanced formats: complete output path + filename + extension\nExample: 'Convert this markdown to PDF and save as /path/to/output.pdf'\n\nNote: After conversion, always check the success message for the exact file location.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contents": {
              "type": "string",
              "description": "The content to be converted (required if input_file not provided)"
            },
            "input_file": {
              "type": "string",
              "description": "Complete path to input file including filename and extension (e.g., '/path/to/input.md')"
            },
            "input_format": {
              "type": "string",
              "description": "Source format of the content (defaults to markdown)",
              "default": "markdown",
              "enum": [
                "markdown",
                "html",
                "pdf",
                "docx",
                "rst",
                "latex",
                "epub",
                "txt"
              ]
            },
            "output_format": {
              "type": "string",
              "description": "Desired output format (defaults to markdown)",
              "default": "markdown",
              "enum": [
                "markdown",
                "html",
                "pdf",
                "docx",
                "rst",
                "latex",
                "epub",
                "txt"
              ]
            },
            "output_file": {
              "type": "string",
              "description": "Complete path where to save the output including filename and extension (required for pdf, docx, rst, latex, epub formats)"
            }
          },
          "oneOf": [
            {
              "required": [
                "contents"
              ]
            },
            {
              "required": [
                "input_file"
              ]
            }
          ],
          "allOf": [
            {
              "if": {
                "properties": {
                  "output_format": {
                    "enum": [
                      "pdf",
                      "docx",
                      "rst",
                      "latex",
                      "epub"
                    ]
                  }
                }
              },
              "then": {
                "required": [
                  "output_file"
                ]
              }
            }
          ]
        }
      }
    ]
  },
  "mcp-server-cloudflare": {
    "display_name": "Cloudflare MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/cloudflare/mcp-server-cloudflare"
    },
    "homepage": "https://github.com/cloudflare/mcp-server-cloudflare",
    "author": {
      "name": "cloudflare"
    },
    "license": "Apache 2.0",
    "tags": [
      "cloudflare",
      "mcp",
      "model-context-protocol",
      "llm",
      "api"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@cloudflare/mcp-server-cloudflare",
          "init"
        ],
        "package": "@cloudflare/mcp-server-cloudflare",
        "env": {},
        "description": "Install and initialize the Cloudflare MCP server",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Deploy a new Worker",
        "description": "Create a new Cloudflare Worker with a Durable Object",
        "prompt": "Please deploy me a new Worker with an example durable object."
      },
      {
        "title": "Query D1 Database",
        "description": "Get information about data in a D1 database",
        "prompt": "Can you tell me about the data in my D1 database named '...'?"
      },
      {
        "title": "Copy KV to R2",
        "description": "Copy entries from a KV namespace to an R2 bucket",
        "prompt": "Can you copy all the entries from my KV namespace '...' into my R2 bucket '...'?"
      }
    ],
    "name": "mcp-server-cloudflare",
    "description": "Model Context Protocol (MCP) is a [new, standardized protocol](https://modelcontextprotocol.io/introduction) for managing context between large language models (LLMs) and external systems. In this repository, we provide an installer as well as an MCP Server for [Cloudflare's API](https://api.cloudflare.com).",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "aws-athena": {
    "name": "aws-athena",
    "display_name": "AWS Athena",
    "description": "A MCP server for AWS Athena to run SQL queries on Glue Catalog.",
    "repository": {
      "type": "git",
      "url": "https://github.com/lishenxydlgzs/aws-athena-mcp"
    },
    "homepage": "https://github.com/lishenxydlgzs/aws-athena-mcp",
    "author": {
      "name": "lishenxydlgzs"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "athena",
      "sql",
      "aws"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@lishenxydlgzs/aws-athena-mcp"
        ],
        "env": {
          "OUTPUT_S3_PATH": "${OUTPUT_S3_PATH}",
          "AWS_REGION": "${AWS_REGION}",
          "AWS_PROFILE": "${AWS_PROFILE}",
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_SESSION_TOKEN": "${AWS_SESSION_TOKEN}",
          "QUERY_TIMEOUT_MS": "${QUERY_TIMEOUT_MS}",
          "MAX_RETRIES": "${MAX_RETRIES}",
          "RETRY_DELAY_MS": "${RETRY_DELAY_MS}"
        }
      }
    },
    "examples": [
      {
        "title": "Show All Databases",
        "description": "Lists all databases in Athena",
        "prompt": "{\"database\": \"default\", \"query\": \"SHOW DATABASES\"}"
      },
      {
        "title": "List Tables in a Database",
        "description": "Shows all tables in the default database",
        "prompt": "{\"database\": \"default\", \"query\": \"SHOW TABLES\"}"
      },
      {
        "title": "Get Table Schema",
        "description": "Fetches the schema of the asin_sitebestimg table",
        "prompt": "{\"database\": \"default\", \"query\": \"DESCRIBE default.asin_sitebestimg\"}"
      },
      {
        "title": "Table Rows Preview",
        "description": "Shows some rows from my_database.mytable",
        "prompt": "{\"database\": \"my_database\", \"query\": \"SELECT * FROM my_table LIMIT 10\", \"maxRows\": 10}"
      },
      {
        "title": "Advanced Query with Filtering and Aggregation",
        "description": "Finds the average price by category for in-stock products",
        "prompt": "{\"database\": \"my_database\", \"query\": \"SELECT category, COUNT(*) as count, AVG(price) as avg_price FROM products WHERE in_stock = true GROUP BY category ORDER BY count DESC\", \"maxRows\": 100}"
      }
    ],
    "arguments": {
      "OUTPUT_S3_PATH": {
        "description": "S3 bucket path for saving Athena query results.",
        "required": true,
        "example": "s3://your-bucket/athena-results/"
      },
      "AWS_REGION": {
        "description": "The AWS region to use for Athena queries, defaults to AWS CLI default region.",
        "required": false,
        "example": "us-east-1"
      },
      "AWS_PROFILE": {
        "description": "AWS CLI profile to use, defaults to 'default' profile.",
        "required": false,
        "example": "default"
      },
      "AWS_ACCESS_KEY_ID": {
        "description": "AWS access key for authentication, if not using IAM role or environment variables.",
        "required": false,
        "example": ""
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "AWS secret key for authentication, if not using IAM role or environment variables.",
        "required": false,
        "example": ""
      },
      "AWS_SESSION_TOKEN": {
        "description": "Session token for temporary AWS credentials, if using temporary access.",
        "required": false,
        "example": ""
      },
      "QUERY_TIMEOUT_MS": {
        "description": "Timeout setting for queries in milliseconds (default: 300000 ms).",
        "required": false,
        "example": "300000"
      },
      "MAX_RETRIES": {
        "description": "Number of retry attempts for failed queries (default: 100).",
        "required": false,
        "example": "100"
      },
      "RETRY_DELAY_MS": {
        "description": "Delay between retry attempts in milliseconds (default: 500 ms).",
        "required": false,
        "example": "500"
      }
    },
    "tools": [
      {
        "name": "run_query",
        "description": "Execute a SQL query using AWS Athena. Returns full results if query completes before timeout, otherwise returns queryExecutionId.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "description": "The Athena database to query"
            },
            "query": {
              "type": "string",
              "description": "SQL query to execute"
            },
            "maxRows": {
              "type": "number",
              "description": "Maximum number of rows to return (default: 1000)",
              "minimum": 1,
              "maximum": 10000
            },
            "timeoutMs": {
              "type": "number",
              "description": "Timeout in milliseconds (default: 60000)",
              "minimum": 1000
            }
          },
          "required": [
            "database",
            "query"
          ]
        }
      },
      {
        "name": "get_result",
        "description": "Get results for a completed query. Returns error if query is still running.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "queryExecutionId": {
              "type": "string",
              "description": "The query execution ID"
            },
            "maxRows": {
              "type": "number",
              "description": "Maximum number of rows to return (default: 1000)",
              "minimum": 1,
              "maximum": 10000
            }
          },
          "required": [
            "queryExecutionId"
          ]
        }
      },
      {
        "name": "get_status",
        "description": "Get the current status of a query execution",
        "inputSchema": {
          "type": "object",
          "properties": {
            "queryExecutionId": {
              "type": "string",
              "description": "The query execution ID"
            }
          },
          "required": [
            "queryExecutionId"
          ]
        }
      }
    ]
  },
  "basic-memory": {
    "name": "basic-memory",
    "display_name": "Basic Memory",
    "description": "Local-first knowledge management system that builds a semantic graph from Markdown files, enabling persistent memory across conversations with LLMs.",
    "repository": {
      "type": "git",
      "url": "https://github.com/basicmachines-co/basic-memory"
    },
    "homepage": "https://github.com/basicmachines-co/basic-memory",
    "author": {
      "name": "basicmachines-co"
    },
    "license": "AGPL-3.0",
    "categories": [
      "Knowledge Base"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "basic-memory",
          "mcp"
        ]
      }
    },
    "tags": [
      "LLM",
      "Markdown",
      "Knowledge Base"
    ],
    "tools": [
      {
        "name": "delete_note",
        "description": "Delete a note by title or permalink",
        "inputSchema": {
          "properties": {
            "identifier": {
              "title": "Identifier",
              "type": "string"
            }
          },
          "required": [
            "identifier"
          ],
          "title": "delete_noteArguments",
          "type": "object"
        }
      },
      {
        "name": "read_content",
        "description": "Read a file's raw content by path or permalink",
        "inputSchema": {
          "properties": {
            "path": {
              "title": "Path",
              "type": "string"
            }
          },
          "required": [
            "path"
          ],
          "title": "read_contentArguments",
          "type": "object"
        }
      },
      {
        "name": "build_context",
        "description": "Build context from a memory:// URI to continue conversations naturally.\n    \n    Use this to follow up on previous discussions or explore related topics.\n    Timeframes support natural language like:\n    - \"2 days ago\"\n    - \"last week\" \n    - \"today\"\n    - \"3 months ago\"\n    Or standard formats like \"7d\", \"24h\"\n    ",
        "inputSchema": {
          "properties": {
            "url": {
              "maxLength": 2028,
              "minLength": 1,
              "title": "Url",
              "type": "string"
            },
            "depth": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 1,
              "title": "Depth"
            },
            "timeframe": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "7d",
              "title": "Timeframe"
            },
            "page": {
              "default": 1,
              "title": "Page",
              "type": "integer"
            },
            "page_size": {
              "default": 10,
              "title": "Page Size",
              "type": "integer"
            },
            "max_related": {
              "default": 10,
              "title": "Max Related",
              "type": "integer"
            }
          },
          "required": [
            "url"
          ],
          "title": "build_contextArguments",
          "type": "object"
        }
      },
      {
        "name": "recent_activity",
        "description": "Get recent activity from across the knowledge base.\n    \n    Timeframe supports natural language formats like:\n    - \"2 days ago\"  \n    - \"last week\"\n    - \"yesterday\" \n    - \"today\"\n    - \"3 weeks ago\"\n    Or standard formats like \"7d\"\n    ",
        "inputSchema": {
          "$defs": {
            "SearchItemType": {
              "description": "Types of searchable items.",
              "enum": [
                "entity",
                "observation",
                "relation"
              ],
              "title": "SearchItemType",
              "type": "string"
            }
          },
          "properties": {
            "type": {
              "anyOf": [
                {
                  "items": {
                    "$ref": "#/$defs/SearchItemType"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Type"
            },
            "depth": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 1,
              "title": "Depth"
            },
            "timeframe": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "7d",
              "title": "Timeframe"
            },
            "page": {
              "default": 1,
              "title": "Page",
              "type": "integer"
            },
            "page_size": {
              "default": 10,
              "title": "Page Size",
              "type": "integer"
            },
            "max_related": {
              "default": 10,
              "title": "Max Related",
              "type": "integer"
            }
          },
          "title": "recent_activityArguments",
          "type": "object"
        }
      },
      {
        "name": "search_notes",
        "description": "Search across all content in the knowledge base.",
        "inputSchema": {
          "$defs": {
            "SearchItemType": {
              "description": "Types of searchable items.",
              "enum": [
                "entity",
                "observation",
                "relation"
              ],
              "title": "SearchItemType",
              "type": "string"
            },
            "SearchQuery": {
              "description": "Search query parameters.\n\nUse ONE of these primary search modes:\n- permalink: Exact permalink match\n- permalink_match: Path pattern with *\n- text: Full-text search of title/content (supports boolean operators: AND, OR, NOT)\n\nOptionally filter results by:\n- types: Limit to specific item types\n- entity_types: Limit to specific entity types\n- after_date: Only items after date\n\nBoolean search examples:\n- \"python AND flask\" - Find items with both terms\n- \"python OR django\" - Find items with either term\n- \"python NOT django\" - Find items with python but not django\n- \"(python OR flask) AND web\" - Use parentheses for grouping",
              "properties": {
                "permalink": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Permalink"
                },
                "permalink_match": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Permalink Match"
                },
                "text": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Text"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Title"
                },
                "types": {
                  "anyOf": [
                    {
                      "items": {
                        "$ref": "#/$defs/SearchItemType"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Types"
                },
                "entity_types": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Entity Types"
                },
                "after_date": {
                  "anyOf": [
                    {
                      "format": "date-time",
                      "type": "string"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "After Date"
                }
              },
              "title": "SearchQuery",
              "type": "object"
            }
          },
          "properties": {
            "query": {
              "$ref": "#/$defs/SearchQuery"
            },
            "page": {
              "default": 1,
              "title": "Page",
              "type": "integer"
            },
            "page_size": {
              "default": 10,
              "title": "Page Size",
              "type": "integer"
            }
          },
          "required": [
            "query"
          ],
          "title": "search_notesArguments",
          "type": "object"
        }
      },
      {
        "name": "read_note",
        "description": "Read a markdown note by title or permalink.",
        "inputSchema": {
          "properties": {
            "identifier": {
              "title": "Identifier",
              "type": "string"
            },
            "page": {
              "default": 1,
              "title": "Page",
              "type": "integer"
            },
            "page_size": {
              "default": 10,
              "title": "Page Size",
              "type": "integer"
            }
          },
          "required": [
            "identifier"
          ],
          "title": "read_noteArguments",
          "type": "object"
        }
      },
      {
        "name": "write_note",
        "description": "Create or update a markdown note. Returns a markdown formatted summary of the semantic content.",
        "inputSchema": {
          "properties": {
            "title": {
              "title": "Title",
              "type": "string"
            },
            "content": {
              "title": "Content",
              "type": "string"
            },
            "folder": {
              "title": "Folder",
              "type": "string"
            },
            "tags": {
              "default": null,
              "title": "tags",
              "type": "string"
            }
          },
          "required": [
            "title",
            "content",
            "folder"
          ],
          "title": "write_noteArguments",
          "type": "object"
        }
      },
      {
        "name": "canvas",
        "description": "Create an Obsidian canvas file to visualize concepts and connections.",
        "inputSchema": {
          "properties": {
            "nodes": {
              "items": {
                "additionalProperties": true,
                "type": "object"
              },
              "title": "Nodes",
              "type": "array"
            },
            "edges": {
              "items": {
                "additionalProperties": true,
                "type": "object"
              },
              "title": "Edges",
              "type": "array"
            },
            "title": {
              "title": "Title",
              "type": "string"
            },
            "folder": {
              "title": "Folder",
              "type": "string"
            }
          },
          "required": [
            "nodes",
            "edges",
            "title",
            "folder"
          ],
          "title": "canvasArguments",
          "type": "object"
        }
      },
      {
        "name": "project_info",
        "description": "Get information and statistics about the current Basic Memory project.",
        "inputSchema": {
          "properties": {},
          "title": "project_infoArguments",
          "type": "object"
        }
      }
    ]
  },
  "deepseek-r1": {
    "name": "deepseek-r1",
    "display_name": "Deepseek R1",
    "description": "A Model Context Protocol (MCP) server implementation connecting Claude Desktop with DeepSeek's language models (R1/V3)",
    "repository": {
      "type": "git",
      "url": "https://github.com/66julienmartin/MCP-server-Deepseek_R1"
    },
    "homepage": "https://github.com/66julienmartin/MCP-server-Deepseek_R1",
    "author": {
      "name": "66julienmartin",
      "url": "https://github.com/66julienmartin"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Deepseek",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/66julienmartin/MCP-server-Deepseek_R1"
        ],
        "env": {
          "DEEPSEEK_API_KEY": "${DEEPSEEK_API_KEY}"
        }
      }
    },
    "arguments": {
      "DEEPSEEK_API_KEY": {
        "description": "API key for authenticating with the Deepseek service.",
        "required": true,
        "example": "your-api-key"
      }
    },
    "tools": [
      {
        "name": "deepseek_r1",
        "description": "Generate text using DeepSeek R1 model",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Input text for DeepSeek"
            },
            "max_tokens": {
              "type": "number",
              "description": "Maximum tokens to generate (default: 8192)",
              "minimum": 1,
              "maximum": 8192
            },
            "temperature": {
              "type": "number",
              "description": "Sampling temperature (default: 0.2)",
              "minimum": 0,
              "maximum": 2
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "dart-mcp-server": {
    "display_name": "Dart MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/its-dart/dart-mcp-server"
    },
    "license": "MIT",
    "homepage": "https://www.itsdart.com/?nr=1",
    "author": {
      "name": "its-dart"
    },
    "tags": [
      "AI",
      "MCP",
      "Model Context Protocol",
      "Project Management"
    ],
    "arguments": {
      "DART_TOKEN": {
        "description": "Authentication token from Dart profile",
        "required": true,
        "example": "dsa_..."
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "dart-mcp-server"
        ],
        "package": "dart-mcp-server",
        "env": {
          "DART_TOKEN": "dsa_..."
        },
        "description": "Run using npx",
        "recommended": true
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "DART_TOKEN",
          "mcp/dart"
        ],
        "env": {
          "DART_TOKEN": "dsa_..."
        },
        "description": "Run using Docker"
      }
    },
    "examples": [
      {
        "title": "Create Task",
        "description": "Create a new task in Dart with title, description, status, priority, and assignee",
        "prompt": "create-task"
      },
      {
        "title": "Create Document",
        "description": "Create a new document in Dart with title, text content, and folder",
        "prompt": "create-doc"
      },
      {
        "title": "Summarize Tasks",
        "description": "Get a summary of tasks with optional filtering by status and assignee",
        "prompt": "summarize-tasks"
      }
    ],
    "name": "dart-mcp-server",
    "description": "<h1>Dart MCP Server</h1>",
    "categories": [
      "Dev Tools"
    ],
    "tools": [
      {
        "name": "get_config",
        "description": "Get information about the user's space, including all of the possible values that can be provided to other endpoints. This includes available assignees, dartboards, folders, statuses, tags, priorities, and sizes.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_tasks",
        "description": "List tasks from Dart with optional filtering parameters. You can filter by assignee, status, dartboard, priority, due date, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assignee": {
              "type": "string",
              "description": "Filter by assignee name or email"
            },
            "assignee_duid": {
              "type": "string",
              "description": "Filter by assignee DUID"
            },
            "dartboard": {
              "type": "string",
              "description": "Filter by dartboard title"
            },
            "dartboard_duid": {
              "type": "string",
              "description": "Filter by dartboard DUID"
            },
            "description": {
              "type": "string",
              "description": "Filter by description content"
            },
            "due_at_before": {
              "type": "string",
              "description": "Filter by due date before (ISO format)"
            },
            "due_at_after": {
              "type": "string",
              "description": "Filter by due date after (ISO format)"
            },
            "duids": {
              "type": "string",
              "description": "Filter by DUIDs"
            },
            "in_trash": {
              "type": "boolean",
              "description": "Filter by trash status"
            },
            "is_draft": {
              "type": "boolean",
              "description": "Filter by draft status"
            },
            "kind": {
              "type": "string",
              "description": "Filter by task kind"
            },
            "limit": {
              "type": "number",
              "description": "Number of results per page"
            },
            "offset": {
              "type": "number",
              "description": "Initial index for pagination"
            },
            "priority": {
              "type": "string",
              "description": "Filter by priority"
            },
            "size": {
              "type": "number",
              "description": "Filter by task size"
            },
            "start_at_before": {
              "type": "string",
              "description": "Filter by start date before (ISO format)"
            },
            "start_at_after": {
              "type": "string",
              "description": "Filter by start date after (ISO format)"
            },
            "status": {
              "type": "string",
              "description": "Filter by status"
            },
            "status_duid": {
              "type": "string",
              "description": "Filter by status DUID"
            },
            "subscriber_duid": {
              "type": "string",
              "description": "Filter by subscriber DUID"
            },
            "tag": {
              "type": "string",
              "description": "Filter by tag"
            },
            "title": {
              "type": "string",
              "description": "Filter by title"
            }
          },
          "required": []
        }
      },
      {
        "name": "create_task",
        "description": "Create a new task in Dart. You can specify title, description, status, priority, size, dates, dartboard, assignees, tags, and parent task.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "The title of the task (required)"
            },
            "description": {
              "type": "string",
              "description": "A longer description of the task, which can include markdown formatting"
            },
            "status": {
              "type": "string",
              "description": "The status from the list of available statuses"
            },
            "priority": {
              "type": "string",
              "description": "The priority (Critical, High, Medium, or Low)"
            },
            "size": {
              "type": "number",
              "description": "A number that represents the amount of work needed"
            },
            "startAt": {
              "type": "string",
              "description": "The start date in ISO format (should be at 9:00am in user's timezone)"
            },
            "dueAt": {
              "type": "string",
              "description": "The due date in ISO format (should be at 9:00am in user's timezone)"
            },
            "dartboard": {
              "type": "string",
              "description": "The title of the dartboard (project or list of tasks)"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of assignee names or emails (if workspace allows multiple assignees)"
            },
            "assignee": {
              "type": "string",
              "description": "Single assignee name or email (if workspace doesn't allow multiple assignees)"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of tags to apply to the task"
            },
            "parentId": {
              "type": "string",
              "description": "The ID of the parent task"
            }
          },
          "required": [
            "title"
          ]
        }
      },
      {
        "name": "get_task",
        "description": "Retrieve an existing task by its ID. Returns the task's information including title, description, status, priority, dates, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The 12-character alphanumeric ID of the task",
              "pattern": "^[a-zA-Z0-9]{12}$"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_task",
        "description": "Update an existing task. You can modify any of its properties including title, description, status, priority, dates, assignees, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The 12-character alphanumeric ID of the task",
              "pattern": "^[a-zA-Z0-9]{12}$"
            },
            "title": {
              "type": "string",
              "description": "The title of the task"
            },
            "description": {
              "type": "string",
              "description": "A longer description of the task, which can include markdown formatting"
            },
            "status": {
              "type": "string",
              "description": "The status from the list of available statuses"
            },
            "priority": {
              "type": "string",
              "description": "The priority (Critical, High, Medium, or Low)"
            },
            "size": {
              "type": "number",
              "description": "A number that represents the amount of work needed"
            },
            "startAt": {
              "type": "string",
              "description": "The start date in ISO format (should be at 9:00am in user's timezone)"
            },
            "dueAt": {
              "type": "string",
              "description": "The due date in ISO format (should be at 9:00am in user's timezone)"
            },
            "dartboard": {
              "type": "string",
              "description": "The title of the dartboard (project or list of tasks)"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of assignee names or emails (if workspace allows multiple assignees)"
            },
            "assignee": {
              "type": "string",
              "description": "Single assignee name or email (if workspace doesn't allow multiple assignees)"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of tags to apply to the task"
            },
            "parentId": {
              "type": "string",
              "description": "The ID of the parent task"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_task",
        "description": "Move an existing task to the trash, where it can be recovered if needed. Nothing else about the task will be changed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The 12-character alphanumeric ID of the task",
              "pattern": "^[a-zA-Z0-9]{12}$"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_docs",
        "description": "List docs from Dart with optional filtering parameters. You can filter by folder, title, text content, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folder": {
              "type": "string",
              "description": "Filter by folder title"
            },
            "folder_duid": {
              "type": "string",
              "description": "Filter by folder DUID"
            },
            "duids": {
              "type": "string",
              "description": "Filter by DUIDs"
            },
            "in_trash": {
              "type": "boolean",
              "description": "Filter by trash status"
            },
            "is_draft": {
              "type": "boolean",
              "description": "Filter by draft status"
            },
            "limit": {
              "type": "number",
              "description": "Number of results per page"
            },
            "offset": {
              "type": "number",
              "description": "Initial index for pagination"
            },
            "s": {
              "type": "string",
              "description": "Search by title, text, or folder title"
            },
            "text": {
              "type": "string",
              "description": "Filter by text content"
            },
            "title": {
              "type": "string",
              "description": "Filter by title"
            }
          },
          "required": []
        }
      },
      {
        "name": "create_doc",
        "description": "Create a new doc in Dart. You can specify title, text content, and folder.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "The title of the doc (required)"
            },
            "text": {
              "type": "string",
              "description": "The text content of the doc, which can include markdown formatting"
            },
            "folder": {
              "type": "string",
              "description": "The title of the folder to place the doc in"
            }
          },
          "required": [
            "title"
          ]
        }
      },
      {
        "name": "get_doc",
        "description": "Retrieve an existing doc by its ID. Returns the doc's information including title, text content, folder, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The 12-character alphanumeric ID of the doc",
              "pattern": "^[a-zA-Z0-9]{12}$"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_doc",
        "description": "Update an existing doc. You can modify its title, text content, and folder.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The 12-character alphanumeric ID of the doc",
              "pattern": "^[a-zA-Z0-9]{12}$"
            },
            "title": {
              "type": "string",
              "description": "The title of the doc"
            },
            "text": {
              "type": "string",
              "description": "The text content of the doc, which can include markdown formatting"
            },
            "folder": {
              "type": "string",
              "description": "The title of the folder to place the doc in"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_doc",
        "description": "Move an existing doc to the trash, where it can be recovered if needed. Nothing else about the doc will be changed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The 12-character alphanumeric ID of the doc",
              "pattern": "^[a-zA-Z0-9]{12}$"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ],
    "prompts": [
      {
        "name": "create-task",
        "description": "Create a new task in Dart",
        "arguments": [
          {
            "name": "title",
            "description": "Title of the task",
            "required": true
          },
          {
            "name": "description",
            "description": "Description of the task",
            "required": false
          },
          {
            "name": "status",
            "description": "Status of the task",
            "required": false
          },
          {
            "name": "priority",
            "description": "Priority of the task",
            "required": false
          },
          {
            "name": "assignee",
            "description": "Email of the assignee",
            "required": false
          }
        ]
      },
      {
        "name": "create-doc",
        "description": "Create a new document in Dart",
        "arguments": [
          {
            "name": "title",
            "description": "Title of the document",
            "required": true
          },
          {
            "name": "text",
            "description": "Content of the document",
            "required": false
          },
          {
            "name": "folder",
            "description": "Folder to place the document in",
            "required": false
          }
        ]
      },
      {
        "name": "summarize-tasks",
        "description": "Get a summary of tasks with optional filtering",
        "arguments": [
          {
            "name": "status",
            "description": "Filter by status (e.g., 'In Progress', 'Done')",
            "required": false
          },
          {
            "name": "assignee",
            "description": "Filter by assignee email",
            "required": false
          }
        ]
      }
    ],
    "resources": [],
    "is_official": true
  },
  "oceanbase": {
    "name": "oceanbase",
    "display_name": "OceanBase",
    "description": "(by yuanoOo) A Model Context Protocol (MCP) server that enables secure interaction with OceanBase databases.",
    "repository": {
      "type": "git",
      "url": "https://github.com/yuanoOo/oceanbase_mcp_server"
    },
    "homepage": "https://github.com/yuanoOo/oceanbase_mcp_server",
    "author": {
      "name": "yuanoOo"
    },
    "license": "Apache-2.0",
    "categories": [
      "Databases"
    ],
    "tags": [
      "OceanBase",
      "SQL",
      "Security"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/yuanoOo/oceanbase_mcp_server.git",
          "oceanbase_mcp_server"
        ],
        "env": {
          "OB_HOST": "${OB_HOST}",
          "OB_PORT": "${OB_PORT}",
          "OB_USER": "${OB_USER}",
          "OB_PASSWORD": "${OB_PASSWORD}",
          "OB_DATABASE": "${OB_DATABASE}"
        }
      }
    },
    "arguments": {
      "OB_HOST": {
        "description": "Database host for connecting to the OceanBase server.",
        "required": true,
        "example": "localhost"
      },
      "OB_PORT": {
        "description": "Optional: Database port to connect to OceanBase, defaults to 2881 if not specified.",
        "required": false,
        "example": "2881"
      },
      "OB_USER": {
        "description": "Username for authenticating with the OceanBase database.",
        "required": true,
        "example": "your_username"
      },
      "OB_PASSWORD": {
        "description": "Password for the specified database user.",
        "required": true,
        "example": "your_password"
      },
      "OB_DATABASE": {
        "description": "Name of the OceanBase database to connect to.",
        "required": true,
        "example": "your_database"
      }
    },
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute an SQL query on the OceanBase server",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "mcp-installer": {
    "name": "mcp-installer",
    "display_name": "Installer",
    "description": "This server is a server that installs other MCP servers for you.",
    "repository": {
      "type": "git",
      "url": "https://github.com/anaisbetts/mcp-installer"
    },
    "homepage": "https://github.com/anaisbetts/mcp-installer",
    "author": {
      "name": "anaisbetts"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "installer",
      "server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@anaisbetts/mcp-installer"
        ]
      }
    },
    "examples": [
      {
        "title": "Install MCP server",
        "description": "Install the MCP server named mcp-server-fetch",
        "prompt": "Hey Claude, install the MCP server named mcp-server-fetch"
      },
      {
        "title": "Install server with arguments",
        "description": "Install the @modelcontextprotocol/server-filesystem package as an MCP server with specific arguments",
        "prompt": "Hey Claude, install the @modelcontextprotocol/server-filesystem package as an MCP server. Use ['/Users/anibetts/Desktop'] for the arguments"
      },
      {
        "title": "Install from directory",
        "description": "Install the MCP server from a specific directory",
        "prompt": "Hi Claude, please install the MCP server at /Users/anibetts/code/mcp-youtube, I'm too lazy to do it myself."
      },
      {
        "title": "Set environment variable",
        "description": "Install the server @modelcontextprotocol/server-github with an environment variable",
        "prompt": "Install the server @modelcontextprotocol/server-github. Set the environment variable GITHUB_PERSONAL_ACCESS_TOKEN to '1234567890'"
      }
    ],
    "tools": [
      {
        "name": "install_repo_mcp_server",
        "description": "Install an MCP server via npx or uvx",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The package name of the MCP server"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The arguments to pass along"
            },
            "env": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The environment variables to set, delimited by ="
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "install_local_mcp_server",
        "description": "Install an MCP server whose code is cloned locally on your computer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "The path to the MCP server code cloned on your computer"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The arguments to pass along"
            },
            "env": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The environment variables to set, delimited by ="
            }
          },
          "required": [
            "path"
          ]
        }
      }
    ]
  },
  "agentrpc": {
    "display_name": "AgentRPC",
    "repository": {
      "type": "git",
      "url": "https://github.com/agentrpc/agentrpc"
    },
    "homepage": "https://docs.agentrpc.com",
    "author": {
      "name": "agentrpc"
    },
    "license": "Apache License 2.0",
    "tags": [
      "RPC",
      "AI agents",
      "MCP",
      "OpenAI",
      "multi-language"
    ],
    "arguments": {
      "AGENTRPC_API_SECRET": {
        "description": "API secret for authentication",
        "required": true,
        "example": "<YOUR_API_SECRET>"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "agentrpc",
          "mcp"
        ],
        "package": "agentrpc",
        "env": {
          "AGENTRPC_API_SECRET": "<YOUR_API_SECRET>"
        },
        "description": "Run the MCP server using npm",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Claude Desktop Integration",
        "description": "Add to your claude_desktop_config.json",
        "prompt": "{\n  \"mcpServers\": {\n    \"agentrpc\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"agentrpc\",\n        \"mcp\"\n      ],\n      \"env\": {\n        \"AGENTRPC_API_SECRET\": \"<YOUR_API_SECRET>\"\n      }\n    }\n  }\n}"
      },
      {
        "title": "Cursor Integration",
        "description": "Add to your ~/.cursor/mcp.json",
        "prompt": "{\n  \"mcpServers\": {\n    \"agentrpc\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"agentrpc\", \"mcp\"],\n      \"env\": {\n        \"AGENTRPC_API_SECRET\": \"<YOUR_API_SECRET>\"\n      }\n    }\n  }\n}"
      }
    ],
    "name": "agentrpc",
    "description": "> Universal RPC layer for AI agents across network boundaries and languages",
    "categories": [
      "Dev Tools"
    ],
    "is_official": true
  },
  "tavily-mcp": {
    "display_name": "Tavily MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/tavily-ai/tavily-mcp"
    },
    "homepage": "https://github.com/tavily-ai/tavily-mcp",
    "author": {
      "name": "tavily-ai"
    },
    "license": "MIT",
    "tags": [
      "search",
      "web",
      "extract",
      "mcp",
      "claude"
    ],
    "arguments": {
      "TAVILY_API_KEY": {
        "description": "API key for Tavily services",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "tavily-mcp"
        ],
        "description": "Run with npx (requires npm install)",
        "env": {
          "TAVILY_API_KEY": "your-api-key-here"
        }
      }
    },
    "name": "tavily-mcp",
    "description": "Search engine for AI agents (search + extract) powered by Tavily",
    "categories": [
      "Web Services"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "tavily-search",
        "description": "A powerful web search tool that provides comprehensive, real-time results using Tavily's AI search engine. Returns relevant web content with customizable parameters for result count, content type, and domain filtering. Ideal for gathering current information, news, and detailed web content analysis.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "search_depth": {
              "type": "string",
              "enum": [
                "basic",
                "advanced"
              ],
              "description": "The depth of the search. It can be 'basic' or 'advanced'",
              "default": "basic"
            },
            "topic": {
              "type": "string",
              "enum": [
                "general",
                "news"
              ],
              "description": "The category of the search. This will determine which of our agents will be used for the search",
              "default": "general"
            },
            "days": {
              "type": "number",
              "description": "The number of days back from the current date to include in the search results. This specifies the time frame of data to be retrieved. Please note that this feature is only available when using the 'news' search topic",
              "default": 3
            },
            "time_range": {
              "type": "string",
              "description": "The time range back from the current date to include in the search results. This feature is available for both 'general' and 'news' search topics",
              "enum": [
                "day",
                "week",
                "month",
                "year",
                "d",
                "w",
                "m",
                "y"
              ]
            },
            "max_results": {
              "type": "number",
              "description": "The maximum number of search results to return",
              "default": 10,
              "minimum": 5,
              "maximum": 20
            },
            "include_images": {
              "type": "boolean",
              "description": "Include a list of query-related images in the response",
              "default": false
            },
            "include_image_descriptions": {
              "type": "boolean",
              "description": "Include a list of query-related images and their descriptions in the response",
              "default": false
            },
            "include_raw_content": {
              "type": "boolean",
              "description": "Include the cleaned and parsed HTML content of each search result",
              "default": false
            },
            "include_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of domains to specifically include in the search results, if the user asks to search on specific sites set this to the domain of the site",
              "default": []
            },
            "exclude_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of domains to specifically exclude, if the user asks to exclude a domain set this to the domain of the site",
              "default": []
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "tavily-extract",
        "description": "A powerful web content extraction tool that retrieves and processes raw content from specified URLs, ideal for data collection, content analysis, and research tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of URLs to extract content from"
            },
            "extract_depth": {
              "type": "string",
              "enum": [
                "basic",
                "advanced"
              ],
              "description": "Depth of extraction - 'basic' or 'advanced', if usrls are linkedin use 'advanced' or if explicitly told to use advanced",
              "default": "basic"
            },
            "include_images": {
              "type": "boolean",
              "description": "Include a list of images extracted from the urls in the response",
              "default": false
            }
          },
          "required": [
            "urls"
          ]
        }
      }
    ]
  },
  "gotohuman-mcp-server": {
    "display_name": "gotoHuman MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/gotohuman/gotohuman-mcp-server"
    },
    "homepage": "https://app.gotohuman.com",
    "author": {
      "name": "gotohuman"
    },
    "license": "MIT",
    "tags": [
      "human review",
      "AI agents",
      "webhook",
      "automation"
    ],
    "arguments": {
      "GOTOHUMAN_API_KEY": {
        "description": "Your gotoHuman API key",
        "required": true,
        "example": "your-api-key"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "build/index.js"
        ],
        "env": {
          "GOTOHUMAN_API_KEY": "${GOTOHUMAN_API_KEY}"
        },
        "description": "Run the gotoHuman MCP server using Node.js",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "List forms",
        "description": "List all available review forms in your account",
        "prompt": "list-forms"
      },
      {
        "title": "Get form schema",
        "description": "Get the schema for a specific form",
        "prompt": "get-form-schema formId=<your-form-id>"
      },
      {
        "title": "Request human review",
        "description": "Request a human review using a specific form",
        "prompt": "request-human-review-with-form formId=<your-form-id> fieldData=<content-and-configuration> metadata=<optional-additional-data> assignToUsers=<optional-user-emails>"
      }
    ],
    "name": "gotohuman-mcp-server",
    "description": "Let your **AI agents ask for human reviews** in gotoHuman via MCP.",
    "categories": [
      "AI Systems"
    ],
    "is_official": true
  },
  "google-calendar": {
    "name": "google-calendar",
    "display_name": "Google Calendar",
    "description": "Google Calendar MCP Server for managing Google calendar events. Also supports searching for events by attributes like title and location.",
    "repository": {
      "type": "git",
      "url": "https://github.com/nspady/google-calendar-mcp"
    },
    "homepage": "https://github.com/nspady/google-calendar-mcp",
    "author": {
      "name": "nspady"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Google Calendar",
      "event management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/nspady/google-calendar-mcp"
        ]
      }
    },
    "examples": [
      {
        "title": "Add Event from Screenshot",
        "description": "Add events from screenshots and images",
        "prompt": "Add this event to my calendar based on the attached screenshot."
      },
      {
        "title": "Check Upcoming Events",
        "description": "Discover upcoming events outside usual routines",
        "prompt": "What events do I have coming up this week that aren't part of my usual routine?"
      },
      {
        "title": "Check Attendance",
        "description": "Identify events with unaccepted invitations",
        "prompt": "Which events tomorrow have attendees who have not accepted the invitation?"
      },
      {
        "title": "Auto Coordinate Events",
        "description": "Create events based on the available times provided",
        "prompt": "Here's some available that was provided to me by someone. Take a look at the available times and create an event that is free on my work calendar."
      },
      {
        "title": "Check Availability",
        "description": "Provide your availability checking both calendars",
        "prompt": "Please provide availability looking at both my personal and work calendar for this upcoming week."
      }
    ]
  },
  "cryptopanic-mcp-server": {
    "name": "cryptopanic-mcp-server",
    "display_name": "CryptoPanic News",
    "description": "Providing latest cryptocurrency news to AI agents, powered by CryptoPanic.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kukapay/cryptopanic-mcp-server"
    },
    "homepage": "https://github.com/kukapay/cryptopanic-mcp-server",
    "author": {
      "name": "kukapay",
      "url": "https://github.com/kukapay"
    },
    "license": "MIT",
    "examples": [
      {
        "title": "Fetch Cryptocurrency News",
        "description": "Get the latest news articles on cryptocurrencies.",
        "prompt": "get_crypto_news(kind='news', num_pages=1)"
      }
    ],
    "categories": [
      "Finance"
    ],
    "tags": [
      "cryptocurrency",
      "news",
      "CryptoPanic"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kukapay/cryptopanic-mcp-server",
          "main.py"
        ],
        "env": {
          "CRYPTOPANIC_API_KEY": "${CRYPTOPANIC_API_KEY}"
        }
      }
    },
    "arguments": {
      "CRYPTOPANIC_API_KEY": {
        "description": "API key to access CryptoPanic services. This key is necessary to authenticate requests made to the CryptoPanic API.",
        "required": true,
        "example": "your_api_key_here"
      }
    }
  },
  "ghost": {
    "name": "ghost",
    "display_name": "Ghost",
    "description": "A Model Context Protocol (MCP) server for interacting with Ghost CMS through LLM interfaces like Claude.",
    "repository": {
      "type": "git",
      "url": "https://github.com/MFYDev/ghost-mcp"
    },
    "homepage": "https://github.com/MFYDev/ghost-mcp",
    "author": {
      "name": "MFYDev"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "Ghost",
      "CMS",
      "Admin API"
    ],
    "examples": [
      {
        "title": "List Posts",
        "description": "List blog posts with pagination.",
        "prompt": "ghost(action=\"list_posts\", params={\"format\": \"text\", \"page\": 1, \"limit\": 15})"
      },
      {
        "title": "Search Posts by Title",
        "description": "Search for posts by title.",
        "prompt": "ghost(action=\"search_posts_by_title\", params={\"query\": \"Welcome\", \"exact\": False})"
      },
      {
        "title": "Create a Post",
        "description": "Create a new post.",
        "prompt": "ghost(action=\"create_post\", params={\"post_data\": {\"title\": \"New Post via MCP\",\"status\": \"draft\",\"lexical\": \"{\\\"root\\\":{\\\"children\\\":[{\\\"children\\\":[{\\\"detail\\\":0,\\\"format\\\":0,\\\"mode\\\":\\\"normal\\\",\\\"style\\\":\\\"\\\",\\\"text\\\":\\\"Hello World\\\",\\\"type\\\":\\\"text\\\",\\\"version\\\":1}],\\\"direction\\\":\\\"ltr\\\",\\\"format\\\":\\\"\\\",\\\"indent\\\":0,\\\"type\\\":\\\"paragraph\\\",\\\"version\\\":1}],\\\"direction\\\":\\\"ltr\\\",\\\"format\\\":\\\"\\\",\\\"indent\\\":0,\\\"type\\\":\\\"root\\\",\\\"version\\\":1}}\"}}"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/MFYDev/ghost-mcp",
          "src/main.py"
        ],
        "env": {
          "GHOST_API_URL": "${GHOST_API_URL}",
          "GHOST_STAFF_API_KEY": "${GHOST_STAFF_API_KEY}"
        }
      }
    },
    "arguments": {
      "GHOST_API_URL": {
        "description": "Your Ghost Admin API URL",
        "required": true,
        "example": "https://yourblog.com"
      },
      "GHOST_STAFF_API_KEY": {
        "description": "Your Ghost Staff API key",
        "required": true,
        "example": "your_staff_api_key"
      }
    }
  },
  "mcp-server-box": {
    "display_name": "MCP Server Box",
    "repository": {
      "type": "git",
      "url": "https://github.com/box-community/mcp-server-box"
    },
    "homepage": "https://github.com/box-community/mcp-server-box",
    "author": {
      "name": "box-community"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "box",
      "ai",
      "file-management",
      "search",
      "text-extraction"
    ],
    "arguments": {
      "BOX_CLIENT_ID": {
        "description": "Box API Client ID",
        "required": true,
        "example": "your_client_id"
      },
      "BOX_CLIENT_SECRET": {
        "description": "Box API Client Secret",
        "required": true,
        "example": "your_client_secret"
      }
    },
    "installations": {
      "python": {
        "type": "python",
        "command": "uv",
        "args": [
          "--directory",
          "/path/to/mcp-server-box",
          "run",
          "src/mcp_server_box.py"
        ],
        "package": "[NOT GIVEN]",
        "env": {
          "BOX_CLIENT_ID": "your_client_id",
          "BOX_CLIENT_SECRET": "your_client_secret"
        },
        "description": "Run using uv package manager",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Search for files in Box",
        "description": "Search for files with specific extensions in Box",
        "prompt": "Search for PDF files containing 'quarterly report'"
      },
      {
        "title": "Extract data using Box AI",
        "description": "Extract structured data from a document using Box AI",
        "prompt": "Extract the following fields from file 123456: title, date, amount"
      },
      {
        "title": "Ask questions about a document",
        "description": "Ask Box AI questions about a specific document",
        "prompt": "What are the key findings in the document with ID 123456?"
      }
    ],
    "name": "mcp-server-box",
    "description": "MCP Server Box is a Python project that integrates with the Box API to perform various operations such as file search, text extraction, AI-based querying, and data extraction. It leverages the `box-sdk-gen` library and provides a set of tools to interact with Box files and folders.",
    "categories": [
      "Knowledge Base"
    ],
    "is_official": true
  },
  "fewsats-mcp": {
    "display_name": "Fewsats MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/Fewsats/fewsats-mcp"
    },
    "license": "[NOT GIVEN]",
    "homepage": "https://fewsats.com",
    "author": {
      "name": "Fewsats"
    },
    "tags": [
      "payments",
      "wallet",
      "offers"
    ],
    "arguments": {
      "FEWSATS_API_KEY": {
        "description": "API key obtained from Fewsats.com",
        "required": true,
        "example": "YOUR_FEWSATS_API_KEY"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "fewsats-mcp"
        ],
        "description": "Run using uv (recommended)",
        "recommended": true,
        "env": {
          "FEWSATS_API_KEY": "YOUR_FEWSATS_API_KEY"
        }
      },
      "pip": {
        "type": "python",
        "command": "fewsats-mcp",
        "args": [],
        "package": "fewsats-mcp",
        "description": "Install via pip and run as a script",
        "recommended": false
      }
    },
    "examples": [
      {
        "title": "Check Balance",
        "description": "Retrieve the balance of the user's wallet",
        "prompt": "What's my current wallet balance?"
      },
      {
        "title": "View Payment Methods",
        "description": "Retrieve the user's payment methods",
        "prompt": "Show me my available payment methods."
      },
      {
        "title": "Pay an Offer",
        "description": "Pay for an offer using the pay_offer tool",
        "prompt": "Pay for the offer with ID 12345."
      },
      {
        "title": "Get Payment Information",
        "description": "Retrieve details about a specific payment",
        "prompt": "Show me the details of payment with ID abc123."
      }
    ],
    "name": "fewsats-mcp",
    "description": "This MCP server integrates with [Fewsats](https://fewsats.com) and allows AI Agents to purchase anything in a secure way.",
    "categories": [
      "Finance"
    ],
    "tools": [
      {
        "name": "balance",
        "description": "Retrieve the balance of the user's wallet.\n    You will rarely need to call this unless instructed by the user, or to troubleshoot payment issues.\n    Fewsats will automatically add balance when needed.",
        "inputSchema": {
          "properties": {},
          "title": "balanceArguments",
          "type": "object"
        }
      },
      {
        "name": "payment_methods",
        "description": "Retrieve the user's payment methods.\n    You will rarely need to call this unless instructed by the user, or to troubleshoot payment issues.\n    Fewsats will automatically select the best payment method.",
        "inputSchema": {
          "properties": {},
          "title": "payment_methodsArguments",
          "type": "object"
        }
      },
      {
        "name": "pay_offer",
        "description": "Pays an offer_id from the l402_offers.\n\n    The l402_offer parameter must be a dict with this structure:\n    {\n        'offers': [\n            {\n                'offer_id': 'test_offer_2',  # String identifier for the offer\n                'amount': 1,                 # Numeric cost value\n                'currency': 'usd',           # Currency code\n                'description': 'Test offer', # Text description\n                'title': 'Test Package'      # Title of the package\n            }\n        ],\n        'payment_context_token': '60a8e027-8b8b-4ccf-b2b9-380ed0930283',  # Payment context token\n        'payment_request_url': 'https://api.fewsats.com/v0/l402/payment-request',  # Payment URL\n        'version': '0.2.2'  # API version\n    }\n\n    Returns payment status response. \n    If payment status is `needs_review` inform the user he will have to approve it at app.fewsats.com",
        "inputSchema": {
          "properties": {
            "offer_id": {
              "title": "Offer Id",
              "type": "string"
            },
            "l402_offer": {
              "additionalProperties": true,
              "title": "L402 Offer",
              "type": "object"
            }
          },
          "required": [
            "offer_id",
            "l402_offer"
          ],
          "title": "pay_offerArguments",
          "type": "object"
        }
      },
      {
        "name": "payment_info",
        "description": "Retrieve the details of a payment.\n    If payment status is `needs_review` inform the user he will have to approve it at app.fewsats.com",
        "inputSchema": {
          "properties": {
            "pid": {
              "title": "Pid",
              "type": "string"
            }
          },
          "required": [
            "pid"
          ],
          "title": "payment_infoArguments",
          "type": "object"
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "snowflake": {
    "name": "snowflake",
    "display_name": "Snowflake",
    "description": "This MCP server enables LLMs to interact with Snowflake databases, allowing for secure and controlled data operations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/isaacwasserman/mcp-snowflake-server"
    },
    "homepage": "https://github.com/isaacwasserman/mcp-snowflake-server",
    "author": {
      "name": "isaacwasserman"
    },
    "license": "NOT GIVEN",
    "categories": [
      "Databases"
    ],
    "tags": [
      "snowflake",
      "sql",
      "database"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp_snowflake_server",
          "--account",
          "${ACCOUNT}",
          "--warehouse",
          "${WAREHOUSE}",
          "--user",
          "${USER}",
          "--password",
          "${PASSWORD}",
          "--role",
          "${ROLE}",
          "--database",
          "${DATABASE}",
          "--schema",
          "${SCHEMA}"
        ]
      }
    },
    "arguments": {
      "ACCOUNT": {
        "description": "The Snowflake account name to connect to.",
        "required": true,
        "example": "your_account_name"
      },
      "WAREHOUSE": {
        "description": "The name of the virtual warehouse to be used for the session.",
        "required": true,
        "example": "your_warehouse_name"
      },
      "USER": {
        "description": "The username to authenticate with Snowflake.",
        "required": true,
        "example": "your_username"
      },
      "PASSWORD": {
        "description": "The password for the specified user.",
        "required": true,
        "example": "your_password"
      },
      "ROLE": {
        "description": "The role to be assumed during the session.",
        "required": true,
        "example": "your_role_name"
      },
      "DATABASE": {
        "description": "The name of the Snowflake database to connect to.",
        "required": true,
        "example": "your_database_name"
      },
      "SCHEMA": {
        "description": "The schema within the database where queries will be executed.",
        "required": true,
        "example": "your_schema_name"
      }
    },
    "tools": [
      {
        "name": "read_query",
        "description": "Execute a SELECT query.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SELECT SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "append_insight",
        "description": "Add a data insight to the memo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "insight": {
              "type": "string",
              "description": "Data insight discovered from analysis"
            }
          },
          "required": [
            "insight"
          ]
        }
      }
    ]
  },
  "rquest": {
    "name": "rquest",
    "display_name": "Rquest",
    "description": "An MCP server providing realistic browser-like HTTP request capabilities with accurate TLS/JA3/JA4 fingerprints for bypassing anti-bot measures.",
    "repository": {
      "type": "git",
      "url": "https://github.com/xxxbrian/mcp-rquest"
    },
    "homepage": "https://github.com/xxxbrian/mcp-rquest",
    "author": {
      "name": "xxxbrian"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "http",
      "request",
      "llm",
      "browser",
      "emulation",
      "pdf",
      "markdown"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-rquest"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp-rquest"
        ]
      }
    },
    "examples": [
      {
        "title": "Convert HTML or PDF to Markdown",
        "description": "Use the get_stored_response_with_markdown tool to convert HTML or PDF responses to Markdown for better processing by LLMs.",
        "prompt": "get_stored_response_with_markdown('document.pdf')"
      }
    ],
    "tools": [
      {
        "name": "http_get",
        "description": "Make an HTTP GET request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_post",
        "description": "Make an HTTP POST request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "form": {
              "type": "array",
              "description": "Form data as [[key, value], ...]"
            },
            "json_payload": {
              "type": "object",
              "description": "JSON payload"
            },
            "body": {
              "type": "object",
              "description": "Request body"
            },
            "multipart": {
              "type": "array",
              "description": "Multipart data as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_put",
        "description": "Make an HTTP PUT request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "form": {
              "type": "array",
              "description": "Form data as [[key, value], ...]"
            },
            "json_payload": {
              "type": "object",
              "description": "JSON payload"
            },
            "body": {
              "type": "object",
              "description": "Request body"
            },
            "multipart": {
              "type": "array",
              "description": "Multipart data as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_delete",
        "description": "Make an HTTP DELETE request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_patch",
        "description": "Make an HTTP PATCH request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "form": {
              "type": "array",
              "description": "Form data as [[key, value], ...]"
            },
            "json_payload": {
              "type": "object",
              "description": "JSON payload"
            },
            "body": {
              "type": "object",
              "description": "Request body"
            },
            "multipart": {
              "type": "array",
              "description": "Multipart data as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_head",
        "description": "Make an HTTP HEAD request to retrieve only headers from the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_options",
        "description": "Make an HTTP OPTIONS request to retrieve options for the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_trace",
        "description": "Make an HTTP TRACE request for diagnostic tracing of the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "get_stored_response",
        "description": "Retrieve a stored HTTP response by its ID",
        "inputSchema": {
          "type": "object",
          "required": [
            "response_id"
          ],
          "properties": {
            "response_id": {
              "type": "string",
              "description": "ID of the stored response"
            },
            "start_line": {
              "type": "integer",
              "description": "Starting line number (1-indexed)"
            },
            "end_line": {
              "type": "integer",
              "description": "Ending line number (inclusive)"
            }
          }
        }
      },
      {
        "name": "get_stored_response_with_markdown",
        "description": "Retrieve a stored HTTP response by its ID and convert it to Markdown format. Supports HTML and PDF content types. (Converting large PDF to Markdown may cause timeout, just wait and try again.)",
        "inputSchema": {
          "type": "object",
          "required": [
            "response_id"
          ],
          "properties": {
            "response_id": {
              "type": "string",
              "description": "ID of the stored response"
            }
          }
        }
      },
      {
        "name": "get_model_state",
        "description": "Get the current state of the PDF models(used by `get_stored_response_with_markdown`) loading process",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "restart_model_loading",
        "description": "Restart the PDF models(used by `get_stored_response_with_markdown`) loading process if it failed or got stuck",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "neo4j": {
    "name": "neo4j",
    "display_name": "Neo4j Server",
    "description": "A community built server that interacts with Neo4j Graph Database.",
    "repository": {
      "type": "git",
      "url": "https://github.com/da-okazaki/mcp-neo4j-server"
    },
    "homepage": "https://github.com/da-okazaki/mcp-neo4j-server",
    "author": {
      "name": "da-okazaki"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "neo4j",
      "database"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@alanse/mcp-neo4j-server"
        ],
        "env": {
          "NEO4J_URI": "${NEO4J_URI}",
          "NEO4J_USERNAME": "${NEO4J_USERNAME}",
          "NEO4J_PASSWORD": "${NEO4J_PASSWORD}"
        }
      }
    },
    "examples": [
      {
        "title": "Querying Data",
        "description": "Ask questions about the data, e.g., 'Show me all employees in the Sales department'.",
        "prompt": "User: \"Show me all employees in the Sales department\""
      },
      {
        "title": "Creating Data",
        "description": "Instruct the bot to create new entities, e.g., 'Add a new person named John Doe who is 30 years old'.",
        "prompt": "User: \"Add a new person named John Doe who is 30 years old\""
      },
      {
        "title": "Creating Relationships",
        "description": "Request to establish relationships between entities, e.g., 'Make John Doe friends with Jane Smith'.",
        "prompt": "User: \"Make John Doe friends with Jane Smith\""
      },
      {
        "title": "Complex Operations",
        "description": "Perform comprehensive queries like 'Find all products purchased by customers who live in New York'.",
        "prompt": "User: \"Find all products purchased by customers who live in New York\""
      }
    ],
    "arguments": {
      "NEO4J_URI": {
        "description": "Neo4j database URI (default: bolt://localhost:7687)",
        "required": false,
        "example": "bolt://localhost:7687"
      },
      "NEO4J_USERNAME": {
        "description": "Neo4j username (default: neo4j)",
        "required": false,
        "example": "neo4j"
      },
      "NEO4J_PASSWORD": {
        "description": "Neo4j password",
        "required": true
      }
    },
    "tools": [
      {
        "name": "execute_query",
        "description": "Execute a Cypher query on Neo4j database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Cypher query to execute"
            },
            "params": {
              "type": "object",
              "description": "Query parameters",
              "additionalProperties": true
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "create_node",
        "description": "Create a new node in Neo4j",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label": {
              "type": "string",
              "description": "Node label"
            },
            "properties": {
              "type": "object",
              "description": "Node properties",
              "additionalProperties": true
            }
          },
          "required": [
            "label",
            "properties"
          ]
        }
      },
      {
        "name": "create_relationship",
        "description": "Create a relationship between two nodes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fromNodeId": {
              "type": "number",
              "description": "ID of the source node"
            },
            "toNodeId": {
              "type": "number",
              "description": "ID of the target node"
            },
            "type": {
              "type": "string",
              "description": "Relationship type"
            },
            "properties": {
              "type": "object",
              "description": "Relationship properties",
              "additionalProperties": true
            }
          },
          "required": [
            "fromNodeId",
            "toNodeId",
            "type"
          ]
        }
      }
    ]
  },
  "discord": {
    "name": "discord",
    "display_name": "Discord",
    "description": "A MCP server to connect to Discord guilds through a bot and read and write messages in channels",
    "repository": {
      "type": "git",
      "url": "https://github.com/v-3/discordmcp"
    },
    "homepage": "https://github.com/v-3/discordmcp",
    "author": {
      "name": "v-3",
      "url": "https://github.com/v-3"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Discord",
      "LLM",
      "Bot"
    ],
    "examples": [
      {
        "title": "Read Messages",
        "description": "Fetch the last 5 messages from a channel.",
        "prompt": "{\"channel\": \"general\", \"limit\": 5}"
      },
      {
        "title": "Send Message",
        "description": "Send a message to the specified channel.",
        "prompt": "{\"channel\": \"announcements\", \"message\": \"Meeting starts in 10 minutes\"}"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/v-3/discordmcp"
        ],
        "env": {
          "DISCORD_TOKEN": "${DISCORD_TOKEN}"
        }
      }
    },
    "arguments": {
      "DISCORD_TOKEN": {
        "description": "The Discord bot token required for authentication and to interact with Discord's API.",
        "required": true,
        "example": "your_discord_bot_token_here"
      }
    }
  },
  "airflow": {
    "name": "airflow",
    "display_name": "Apache Airflow",
    "description": "A MCP Server that connects to [Apache Airflow](https://airflow.apache.org/) using official python client.",
    "repository": {
      "type": "git",
      "url": "https://github.com/yangkyeongmo/mcp-server-apache-airflow"
    },
    "homepage": "https://github.com/yangkyeongmo/mcp-server-apache-airflow",
    "author": {
      "name": "yangkyeongmo"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Apache Airflow",
      "DAG",
      "Workflow",
      "Data Pipeline"
    ],
    "arguments": {
      "AIRFLOW_HOST": {
        "description": "URL of your Apache Airflow instance",
        "required": true,
        "example": "https://your-airflow-host:8080"
      },
      "AIRFLOW_USERNAME": {
        "description": "Username for authenticating with Airflow",
        "required": true,
        "example": "admin"
      },
      "AIRFLOW_PASSWORD": {
        "description": "Password for authenticating with Airflow",
        "required": true,
        "example": "your_secure_password"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-apache-airflow"
        ],
        "env": {
          "AIRFLOW_HOST": "${AIRFLOW_HOST}",
          "AIRFLOW_USERNAME": "${AIRFLOW_USERNAME}",
          "AIRFLOW_PASSWORD": "${AIRFLOW_PASSWORD}"
        }
      }
    },
    "tools": [
      {
        "name": "get_config",
        "description": "Get current configuration",
        "inputSchema": {
          "properties": {
            "section": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Section"
            }
          },
          "title": "get_configArguments",
          "type": "object"
        }
      },
      {
        "name": "get_value",
        "description": "Get a specific option from configuration",
        "inputSchema": {
          "properties": {
            "section": {
              "title": "Section",
              "type": "string"
            },
            "option": {
              "title": "Option",
              "type": "string"
            }
          },
          "required": [
            "section",
            "option"
          ],
          "title": "get_valueArguments",
          "type": "object"
        }
      },
      {
        "name": "list_connections",
        "description": "List all connections",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "title": "list_connectionsArguments",
          "type": "object"
        }
      },
      {
        "name": "create_connection",
        "description": "Create a connection",
        "inputSchema": {
          "properties": {
            "conn_id": {
              "title": "Conn Id",
              "type": "string"
            },
            "conn_type": {
              "title": "Conn Type",
              "type": "string"
            },
            "host": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Host"
            },
            "port": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Port"
            },
            "login": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Login"
            },
            "password": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Password"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema"
            },
            "extra": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Extra"
            }
          },
          "required": [
            "conn_id",
            "conn_type"
          ],
          "title": "create_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "get_connection",
        "description": "Get a connection by ID",
        "inputSchema": {
          "properties": {
            "conn_id": {
              "title": "Conn Id",
              "type": "string"
            }
          },
          "required": [
            "conn_id"
          ],
          "title": "get_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "update_connection",
        "description": "Update a connection by ID",
        "inputSchema": {
          "properties": {
            "conn_id": {
              "title": "Conn Id",
              "type": "string"
            },
            "conn_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Conn Type"
            },
            "host": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Host"
            },
            "port": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Port"
            },
            "login": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Login"
            },
            "password": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Password"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema"
            },
            "extra": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Extra"
            }
          },
          "required": [
            "conn_id"
          ],
          "title": "update_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_connection",
        "description": "Delete a connection by ID",
        "inputSchema": {
          "properties": {
            "conn_id": {
              "title": "Conn Id",
              "type": "string"
            }
          },
          "required": [
            "conn_id"
          ],
          "title": "delete_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "test_connection",
        "description": "Test a connection",
        "inputSchema": {
          "properties": {
            "conn_type": {
              "title": "Conn Type",
              "type": "string"
            },
            "host": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Host"
            },
            "port": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Port"
            },
            "login": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Login"
            },
            "password": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Password"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema"
            },
            "extra": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Extra"
            }
          },
          "required": [
            "conn_type"
          ],
          "title": "test_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "fetch_dags",
        "description": "Fetch all DAGs",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "tags": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Tags"
            },
            "only_active": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Only Active"
            },
            "paused": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Paused"
            },
            "dag_id_pattern": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Id Pattern"
            }
          },
          "title": "get_dagsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag",
        "description": "Get a DAG by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_details",
        "description": "Get a simplified representation of DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "fields": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Fields"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dag_detailsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_source",
        "description": "Get a source code",
        "inputSchema": {
          "properties": {
            "file_token": {
              "title": "File Token",
              "type": "string"
            }
          },
          "required": [
            "file_token"
          ],
          "title": "get_dag_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "pause_dag",
        "description": "Pause a DAG by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "pause_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "unpause_dag",
        "description": "Unpause a DAG by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "unpause_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_tasks",
        "description": "Get tasks for DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dag_tasksArguments",
          "type": "object"
        }
      },
      {
        "name": "get_task",
        "description": "Get a task by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "task_id"
          ],
          "title": "get_taskArguments",
          "type": "object"
        }
      },
      {
        "name": "get_tasks",
        "description": "Get tasks for DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_tasksArguments",
          "type": "object"
        }
      },
      {
        "name": "patch_dag",
        "description": "Update a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "is_paused": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Is Paused"
            },
            "tags": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Tags"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "patch_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "patch_dags",
        "description": "Update multiple DAGs",
        "inputSchema": {
          "properties": {
            "dag_id_pattern": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Id Pattern"
            },
            "is_paused": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Is Paused"
            },
            "tags": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Tags"
            }
          },
          "title": "patch_dagsArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dag",
        "description": "Delete a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "delete_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "clear_task_instances",
        "description": "Clear a set of task instances",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "task_ids": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Task Ids"
            },
            "start_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date"
            },
            "end_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date"
            },
            "include_subdags": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Subdags"
            },
            "include_parentdag": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Parentdag"
            },
            "include_upstream": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Upstream"
            },
            "include_downstream": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Downstream"
            },
            "include_future": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Future"
            },
            "include_past": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Past"
            },
            "dry_run": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dry Run"
            },
            "reset_dag_runs": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Reset Dag Runs"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "clear_task_instancesArguments",
          "type": "object"
        }
      },
      {
        "name": "set_task_instances_state",
        "description": "Set a state of task instances",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "state": {
              "title": "State",
              "type": "string"
            },
            "task_ids": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Task Ids"
            },
            "execution_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date"
            },
            "include_upstream": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Upstream"
            },
            "include_downstream": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Downstream"
            },
            "include_future": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Future"
            },
            "include_past": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Past"
            },
            "dry_run": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dry Run"
            }
          },
          "required": [
            "dag_id",
            "state"
          ],
          "title": "set_task_instances_stateArguments",
          "type": "object"
        }
      },
      {
        "name": "reparse_dag_file",
        "description": "Request re-parsing of a DAG file",
        "inputSchema": {
          "properties": {
            "file_token": {
              "title": "File Token",
              "type": "string"
            }
          },
          "required": [
            "file_token"
          ],
          "title": "reparse_dag_fileArguments",
          "type": "object"
        }
      },
      {
        "name": "post_dag_run",
        "description": "Trigger a DAG by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Run Id"
            },
            "data_interval_end": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Data Interval End"
            },
            "data_interval_start": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Data Interval Start"
            },
            "end_date": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date"
            },
            "execution_date": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date"
            },
            "external_trigger": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "External Trigger"
            },
            "last_scheduling_decision": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Last Scheduling Decision"
            },
            "logical_date": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Logical Date"
            },
            "note": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Note"
            },
            "run_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Run Type"
            },
            "start_date": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "post_dag_runArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_runs",
        "description": "Get DAG runs by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "execution_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Gte"
            },
            "execution_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Lte"
            },
            "start_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Gte"
            },
            "start_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Lte"
            },
            "end_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Gte"
            },
            "end_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Lte"
            },
            "updated_at_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Updated At Gte"
            },
            "updated_at_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Updated At Lte"
            },
            "state": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dag_runsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_runs_batch",
        "description": "List DAG runs (batch)",
        "inputSchema": {
          "properties": {
            "dag_ids": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Ids"
            },
            "execution_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Gte"
            },
            "execution_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Lte"
            },
            "start_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Gte"
            },
            "start_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Lte"
            },
            "end_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Gte"
            },
            "end_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Lte"
            },
            "state": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "page_offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Page Offset"
            },
            "page_limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Page Limit"
            }
          },
          "title": "get_dag_runs_batchArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_run",
        "description": "Get a DAG run by DAG ID and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "get_dag_runArguments",
          "type": "object"
        }
      },
      {
        "name": "update_dag_run_state",
        "description": "Update a DAG run state by DAG ID and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "state": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "update_dag_run_stateArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dag_run",
        "description": "Delete a DAG run by DAG ID and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "delete_dag_runArguments",
          "type": "object"
        }
      },
      {
        "name": "clear_dag_run",
        "description": "Clear a DAG run",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "dry_run": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dry Run"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "clear_dag_runArguments",
          "type": "object"
        }
      },
      {
        "name": "set_dag_run_note",
        "description": "Update the DagRun note",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "note": {
              "title": "Note",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id",
            "note"
          ],
          "title": "set_dag_run_noteArguments",
          "type": "object"
        }
      },
      {
        "name": "get_upstream_dataset_events",
        "description": "Get dataset events for a DAG run",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "get_upstream_dataset_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_stats",
        "description": "Get DAG stats",
        "inputSchema": {
          "properties": {
            "dag_ids": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Ids"
            }
          },
          "title": "get_dag_statsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_datasets",
        "description": "List datasets",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "uri_pattern": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Uri Pattern"
            },
            "dag_ids": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Ids"
            }
          },
          "title": "get_datasetsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dataset",
        "description": "Get a dataset by URI",
        "inputSchema": {
          "properties": {
            "uri": {
              "title": "Uri",
              "type": "string"
            }
          },
          "required": [
            "uri"
          ],
          "title": "get_datasetArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dataset_events",
        "description": "Get dataset events",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "dataset_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dataset Id"
            },
            "source_dag_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Dag Id"
            },
            "source_task_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Task Id"
            },
            "source_run_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Run Id"
            },
            "source_map_index": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Map Index"
            }
          },
          "title": "get_dataset_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "create_dataset_event",
        "description": "Create dataset event",
        "inputSchema": {
          "properties": {
            "dataset_uri": {
              "title": "Dataset Uri",
              "type": "string"
            },
            "extra": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Extra"
            }
          },
          "required": [
            "dataset_uri"
          ],
          "title": "create_dataset_eventArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_dataset_queued_event",
        "description": "Get a queued Dataset event for a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "uri": {
              "title": "Uri",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "uri"
          ],
          "title": "get_dag_dataset_queued_eventArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_dataset_queued_events",
        "description": "Get queued Dataset events for a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dag_dataset_queued_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dag_dataset_queued_event",
        "description": "Delete a queued Dataset event for a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "uri": {
              "title": "Uri",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "uri"
          ],
          "title": "delete_dag_dataset_queued_eventArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dag_dataset_queued_events",
        "description": "Delete queued Dataset events for a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "before": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Before"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "delete_dag_dataset_queued_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dataset_queued_events",
        "description": "Get queued Dataset events for a Dataset",
        "inputSchema": {
          "properties": {
            "uri": {
              "title": "Uri",
              "type": "string"
            }
          },
          "required": [
            "uri"
          ],
          "title": "get_dataset_queued_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dataset_queued_events",
        "description": "Delete queued Dataset events for a Dataset",
        "inputSchema": {
          "properties": {
            "uri": {
              "title": "Uri",
              "type": "string"
            },
            "before": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Before"
            }
          },
          "required": [
            "uri"
          ],
          "title": "delete_dataset_queued_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_event_logs",
        "description": "List log entries from event log",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "dag_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Id"
            },
            "task_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Task Id"
            },
            "run_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Run Id"
            },
            "map_index": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Map Index"
            },
            "try_number": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Try Number"
            },
            "event": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Event"
            },
            "owner": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Owner"
            },
            "before": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Before"
            },
            "after": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "After"
            },
            "included_events": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Included Events"
            },
            "excluded_events": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Excluded Events"
            }
          },
          "title": "get_event_logsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_event_log",
        "description": "Get a specific log entry by ID",
        "inputSchema": {
          "properties": {
            "event_log_id": {
              "title": "Event Log Id",
              "type": "integer"
            }
          },
          "required": [
            "event_log_id"
          ],
          "title": "get_event_logArguments",
          "type": "object"
        }
      },
      {
        "name": "get_import_errors",
        "description": "List import errors",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "title": "get_import_errorsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_import_error",
        "description": "Get a specific import error by ID",
        "inputSchema": {
          "properties": {
            "import_error_id": {
              "title": "Import Error Id",
              "type": "integer"
            }
          },
          "required": [
            "import_error_id"
          ],
          "title": "get_import_errorArguments",
          "type": "object"
        }
      },
      {
        "name": "get_health",
        "description": "Get instance status",
        "inputSchema": {
          "properties": {},
          "title": "get_healthArguments",
          "type": "object"
        }
      },
      {
        "name": "get_version",
        "description": "Get version information",
        "inputSchema": {
          "properties": {},
          "title": "get_versionArguments",
          "type": "object"
        }
      },
      {
        "name": "get_plugins",
        "description": "Get a list of loaded plugins",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            }
          },
          "title": "get_pluginsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_pools",
        "description": "List pools",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "title": "get_poolsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_pool",
        "description": "Get a pool by name",
        "inputSchema": {
          "properties": {
            "pool_name": {
              "title": "Pool Name",
              "type": "string"
            }
          },
          "required": [
            "pool_name"
          ],
          "title": "get_poolArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_pool",
        "description": "Delete a pool",
        "inputSchema": {
          "properties": {
            "pool_name": {
              "title": "Pool Name",
              "type": "string"
            }
          },
          "required": [
            "pool_name"
          ],
          "title": "delete_poolArguments",
          "type": "object"
        }
      },
      {
        "name": "post_pool",
        "description": "Create a pool",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "slots": {
              "title": "Slots",
              "type": "integer"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            },
            "include_deferred": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Deferred"
            }
          },
          "required": [
            "name",
            "slots"
          ],
          "title": "post_poolArguments",
          "type": "object"
        }
      },
      {
        "name": "patch_pool",
        "description": "Update a pool",
        "inputSchema": {
          "properties": {
            "pool_name": {
              "title": "Pool Name",
              "type": "string"
            },
            "slots": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Slots"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            },
            "include_deferred": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Deferred"
            }
          },
          "required": [
            "pool_name"
          ],
          "title": "patch_poolArguments",
          "type": "object"
        }
      },
      {
        "name": "get_task_instance",
        "description": "Get a task instance by DAG ID, task ID, and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "task_id",
            "dag_run_id"
          ],
          "title": "get_task_instanceArguments",
          "type": "object"
        }
      },
      {
        "name": "list_task_instances",
        "description": "List task instances by DAG ID and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "execution_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Gte"
            },
            "execution_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Lte"
            },
            "start_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Gte"
            },
            "start_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Lte"
            },
            "end_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Gte"
            },
            "end_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Lte"
            },
            "updated_at_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Updated At Gte"
            },
            "updated_at_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Updated At Lte"
            },
            "duration_gte": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Duration Gte"
            },
            "duration_lte": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Duration Lte"
            },
            "state": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            },
            "pool": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Pool"
            },
            "queue": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Queue"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "list_task_instancesArguments",
          "type": "object"
        }
      },
      {
        "name": "update_task_instance",
        "description": "Update a task instance by DAG ID, DAG run ID, and task ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            },
            "state": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id",
            "task_id"
          ],
          "title": "update_task_instanceArguments",
          "type": "object"
        }
      },
      {
        "name": "list_variables",
        "description": "List all variables",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "title": "list_variablesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_variable",
        "description": "Create a variable",
        "inputSchema": {
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            },
            "value": {
              "title": "Value",
              "type": "string"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            }
          },
          "required": [
            "key",
            "value"
          ],
          "title": "create_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "get_variable",
        "description": "Get a variable by key",
        "inputSchema": {
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "title": "get_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "update_variable",
        "description": "Update a variable by key",
        "inputSchema": {
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            },
            "value": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Value"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            }
          },
          "required": [
            "key"
          ],
          "title": "update_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_variable",
        "description": "Delete a variable by key",
        "inputSchema": {
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "title": "delete_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "get_xcom_entries",
        "description": "Get all XCom entries",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            },
            "map_index": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Map Index"
            },
            "xcom_key": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Xcom Key"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id",
            "task_id"
          ],
          "title": "get_xcom_entriesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_xcom_entry",
        "description": "Get an XCom entry",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            },
            "xcom_key": {
              "title": "Xcom Key",
              "type": "string"
            },
            "map_index": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Map Index"
            },
            "deserialize": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Deserialize"
            },
            "stringify": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Stringify"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id",
            "task_id",
            "xcom_key"
          ],
          "title": "get_xcom_entryArguments",
          "type": "object"
        }
      }
    ]
  },
  "volcengine-tos": {
    "name": "volcengine-tos",
    "display_name": "VolcEngine TOS",
    "description": "A sample MCP server for VolcEngine TOS that flexibly get objects from TOS.",
    "repository": {
      "type": "git",
      "url": "https://github.com/dinghuazhou/sample-mcp-server-tos"
    },
    "author": {
      "name": "dinghuazhou"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "TOS",
      "Volcengine",
      "Data"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/dinghuazhou/sample-mcp-server-tos",
          "tos-mcp-server"
        ]
      }
    },
    "examples": [
      {
        "title": "List Buckets",
        "description": "Returns a list of all buckets owned by the authenticated sender of the request",
        "prompt": "ListBuckets"
      },
      {
        "title": "List Objects in a Bucket",
        "description": "Returns some or all (up to 1,000) of the objects in a bucket with each request",
        "prompt": "ListObjectsV2"
      },
      {
        "title": "Get an Object",
        "description": "Retrieves an object from volcengine TOS.",
        "prompt": "GetObject"
      }
    ],
    "homepage": "https://github.com/dinghuazhou/sample-mcp-server-tos"
  },
  "mcp-server-milvus": {
    "display_name": "MCP Server for Milvus",
    "repository": {
      "type": "git",
      "url": "https://github.com/zilliztech/mcp-server-milvus"
    },
    "homepage": "https://github.com/zilliztech/mcp-server-milvus",
    "author": {
      "name": "zilliztech"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "milvus",
      "vector database",
      "mcp",
      "model context protocol"
    ],
    "arguments": {
      "milvus-uri": {
        "description": "Milvus server URI",
        "required": true,
        "example": "http://localhost:19530"
      },
      "milvus-token": {
        "description": "Optional authentication token",
        "required": false,
        "example": "[NOT GIVEN]"
      },
      "milvus-db": {
        "description": "Database name",
        "required": false,
        "example": "default"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/zilliztech/mcp-server-milvus",
          "mcp-server-milvus"
        ],
        "description": "Run directly with uv without installation"
      }
    },
    "examples": [
      {
        "title": "Listing Collections",
        "description": "List all collections in the Milvus database",
        "prompt": "What are the collections I have in my Milvus DB?"
      },
      {
        "title": "Searching for Documents",
        "description": "Search for documents using full text search",
        "prompt": "Find documents in my text_collection that mention \"machine learning\""
      },
      {
        "title": "Creating a Collection",
        "description": "Create a new collection with specified schema",
        "prompt": "Create a new collection called 'articles' in Milvus with fields for title (string), content (string), and a vector field (128 dimensions)"
      }
    ],
    "name": "mcp-server-milvus",
    "description": "This repository contains a MCP server that provides access to Milvus vector database functionality.",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "opencti": {
    "name": "opencti",
    "display_name": "OpenCTI",
    "description": "Interact with OpenCTI platform to retrieve threat intelligence data including reports, indicators, malware and threat actors.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Spathodea-Network/opencti-mcp"
    },
    "homepage": "https://github.com/Spathodea-Network/opencti-mcp",
    "author": {
      "name": "Spathodea-Network"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "OpenCTI",
      "Threat Intelligence"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/Spathodea-Network/opencti-mcp"
        ],
        "env": {
          "OPENCTI_URL": "${OPENCTI_URL}",
          "OPENCTI_TOKEN": "${OPENCTI_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Get Latest Reports",
        "description": "Retrieves the most recent threat intelligence reports.",
        "prompt": "{ \"name\": \"get_latest_reports\", \"arguments\": { \"first\": 10 } }"
      },
      {
        "title": "Search Malware",
        "description": "Searches for malware information in the OpenCTI database.",
        "prompt": "{ \"name\": \"search_malware\", \"arguments\": { \"query\": \"ransomware\" } }"
      },
      {
        "title": "User Management - List Users",
        "description": "Lists all users in the system.",
        "prompt": "{ \"name\": \"list_users\", \"arguments\": {} }"
      }
    ],
    "arguments": {
      "OPENCTI_URL": {
        "description": "Your OpenCTI instance URL",
        "required": true
      },
      "OPENCTI_TOKEN": {
        "description": "Your OpenCTI API token",
        "required": true
      }
    },
    "tools": [
      {
        "name": "get_latest_reports",
        "description": "\u7372\u53d6\u6700\u65b0\u7684OpenCTI\u5831\u544a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          }
        }
      },
      {
        "name": "get_report_by_id",
        "description": "\u6839\u64daID\u7372\u53d6OpenCTI\u5831\u544a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "\u5831\u544aID"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "search_indicators",
        "description": "\u641c\u5c0bOpenCTI\u4e2d\u7684\u6307\u6a19",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "\u641c\u5c0b\u95dc\u9375\u5b57"
            },
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "search_malware",
        "description": "\u641c\u5c0bOpenCTI\u4e2d\u7684\u60e1\u610f\u7a0b\u5f0f",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "\u641c\u5c0b\u95dc\u9375\u5b57"
            },
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "search_threat_actors",
        "description": "\u641c\u5c0bOpenCTI\u4e2d\u7684\u5a01\u8105\u884c\u70ba\u8005",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "\u641c\u5c0b\u95dc\u9375\u5b57"
            },
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_user_by_id",
        "description": "\u6839\u64daID\u7372\u53d6\u4f7f\u7528\u8005\u8cc7\u8a0a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "\u4f7f\u7528\u8005ID"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_users",
        "description": "\u5217\u51fa\u6240\u6709\u4f7f\u7528\u8005",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_groups",
        "description": "\u5217\u51fa\u6240\u6709\u7fa4\u7d44",
        "inputSchema": {
          "type": "object",
          "properties": {
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          }
        }
      },
      {
        "name": "list_attack_patterns",
        "description": "\u5217\u51fa\u6240\u6709\u653b\u64ca\u6a21\u5f0f",
        "inputSchema": {
          "type": "object",
          "properties": {
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          }
        }
      },
      {
        "name": "get_campaign_by_name",
        "description": "\u6839\u64da\u540d\u7a31\u7372\u53d6\u884c\u52d5\u8cc7\u8a0a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "\u884c\u52d5\u540d\u7a31"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_connectors",
        "description": "\u5217\u51fa\u6240\u6709\u9023\u63a5\u5668",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_status_templates",
        "description": "\u5217\u51fa\u6240\u6709\u72c0\u614b\u6a21\u677f",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_file_by_id",
        "description": "\u6839\u64daID\u7372\u53d6\u6a94\u6848\u8cc7\u8a0a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "\u6a94\u6848ID"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_files",
        "description": "\u5217\u51fa\u6240\u6709\u6a94\u6848",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_marking_definitions",
        "description": "\u5217\u51fa\u6240\u6709\u6a19\u8a18\u5b9a\u7fa9",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_labels",
        "description": "\u5217\u51fa\u6240\u6709\u6a19\u7c64",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "arangodb": {
    "name": "arangodb",
    "display_name": "ArangoDB",
    "description": "MCP Server that provides database interaction capabilities through [ArangoDB](https://arangodb.com/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/ravenwits/mcp-server-arangodb"
    },
    "homepage": "https://github.com/ravenwits/mcp-server-arangodb",
    "author": {
      "name": "ravenwits"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "ArangoDB",
      "TypeScript"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/ravenwits/mcp-server-arangodb"
        ],
        "description": "Run with npx (requires npm install)",
        "env": {
          "ARANGO_URL": "${ARANGO_URL}",
          "ARANGO_DATABASE": "${ARANGO_DATABASE}",
          "ARANGO_USERNAME": "${ARANGO_USERNAME}",
          "ARANGO_PASSWORD": "${ARANGO_PASSWORD}"
        }
      }
    },
    "examples": [
      {
        "title": "List all collections",
        "description": "Query to list all collections in the database.",
        "prompt": "{}"
      },
      {
        "title": "Insert a new document",
        "description": "Insert a new document into the 'users' collection.",
        "prompt": "{\"collection\": \"users\", \"document\": {\"name\": \"John Doe\", \"email\": \"john@example.com\"}}"
      },
      {
        "title": "Update a document",
        "description": "Update a document in the 'users' collection by key.",
        "prompt": "{\"collection\": \"users\", \"key\": \"123456\", \"update\": {\"name\": \"Jane Doe\"}}"
      },
      {
        "title": "Remove a document",
        "description": "Remove a document from the 'users' collection by key.",
        "prompt": "{\"collection\": \"users\", \"key\": \"123456\"}}"
      },
      {
        "title": "Backup database collections",
        "description": "Backup collections to a specified directory.",
        "prompt": "{\"outputDir\": \"./backup\"}"
      }
    ],
    "arguments": {
      "ARANGO_URL": {
        "description": "ArangoDB server URL (note: 8529 is the default port for ArangoDB for local development)",
        "required": true
      },
      "ARANGO_DATABASE": {
        "description": "Database name",
        "required": true
      },
      "ARANGO_USERNAME": {
        "description": "Database user",
        "required": true
      },
      "ARANGO_PASSWORD": {
        "description": "Database password",
        "required": true
      }
    },
    "tools": [
      {
        "name": "arango_query",
        "description": "Execute an AQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "AQL query string"
            },
            "bindVars": {
              "type": "object",
              "description": "Query bind variables",
              "additionalProperties": true
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "arango_insert",
        "description": "Insert a document into a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "document": {
              "type": "object",
              "description": "Document to insert",
              "additionalProperties": true
            }
          },
          "required": [
            "collection",
            "document"
          ]
        }
      },
      {
        "name": "arango_update",
        "description": "Update a document in a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "key": {
              "type": "string",
              "description": "Document key"
            },
            "update": {
              "type": "object",
              "description": "Update object",
              "additionalProperties": true
            }
          },
          "required": [
            "collection",
            "key",
            "update"
          ]
        }
      },
      {
        "name": "arango_remove",
        "description": "Remove a document from a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "key": {
              "type": "string",
              "description": "Document key"
            }
          },
          "required": [
            "collection",
            "key"
          ]
        }
      },
      {
        "name": "arango_backup",
        "description": "Backup collections to JSON files.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "outputDir": {
              "type": "string",
              "description": "An absolute directory path to store backup files",
              "default": "./backup",
              "optional": true
            },
            "collection": {
              "type": "string",
              "description": "Collection name to backup. If not provided, backs up all collections.",
              "optional": true
            },
            "docLimit": {
              "type": "integer",
              "description": "Limit the number of documents to backup. If not provided, backs up all documents.",
              "optional": true
            }
          },
          "required": [
            "outputDir"
          ]
        }
      },
      {
        "name": "arango_list_collections",
        "description": "List all collections in the database",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "arango_create_collection",
        "description": "Create a new collection in the database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the collection to create"
            },
            "type": {
              "type": {
                "2": "DOCUMENT_COLLECTION",
                "3": "EDGE_COLLECTION",
                "DOCUMENT_COLLECTION": 2,
                "EDGE_COLLECTION": 3
              },
              "description": "Type of collection to create",
              "default": 2
            },
            "waitForSync": {
              "type": "boolean",
              "description": "If true, wait for data to be synchronized to disk before returning",
              "default": false
            }
          },
          "required": [
            "name"
          ]
        }
      }
    ]
  },
  "elasticsearch": {
    "name": "elasticsearch",
    "display_name": "Elasticsearch",
    "description": "MCP server implementation that provides Elasticsearch interaction.",
    "repository": {
      "type": "git",
      "url": "https://github.com/cr7258/elasticsearch-mcp-server"
    },
    "homepage": "https://github.com/cr7258/elasticsearch-mcp-server",
    "author": {
      "name": "cr7258"
    },
    "license": "Apache License Version 2.0",
    "categories": [
      "Databases"
    ],
    "tags": [
      "elasticsearch",
      "server"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "elasticsearch-mcp-server"
        ],
        "env": {
          "ELASTIC_HOST": "${ELASTIC_HOST}",
          "ELASTIC_USERNAME": "${ELASTIC_USERNAME}",
          "ELASTIC_PASSWORD": "${ELASTIC_PASSWORD}"
        }
      }
    },
    "arguments": {
      "ELASTIC_HOST": {
        "description": "The host URL of the Elasticsearch server.",
        "required": true,
        "example": "https://localhost:9200"
      },
      "ELASTIC_USERNAME": {
        "description": "The username for authenticating with the Elasticsearch server.",
        "required": true,
        "example": "elastic"
      },
      "ELASTIC_PASSWORD": {
        "description": "The password for authenticating with the Elasticsearch server.",
        "required": true,
        "example": "test123"
      }
    },
    "tools": [
      {
        "name": "list_indices",
        "description": "List all indices in the Elasticsearch cluster",
        "inputSchema": {
          "properties": {},
          "title": "list_indicesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_mapping",
        "description": "Get index mapping",
        "inputSchema": {
          "properties": {
            "index": {
              "title": "Index",
              "type": "string"
            }
          },
          "required": [
            "index"
          ],
          "title": "get_mappingArguments",
          "type": "object"
        }
      },
      {
        "name": "get_settings",
        "description": "Get index settings",
        "inputSchema": {
          "properties": {
            "index": {
              "title": "Index",
              "type": "string"
            }
          },
          "required": [
            "index"
          ],
          "title": "get_settingsArguments",
          "type": "object"
        }
      },
      {
        "name": "search_documents",
        "description": "Search documents in an index with a custom query",
        "inputSchema": {
          "properties": {
            "index": {
              "title": "Index",
              "type": "string"
            },
            "body": {
              "additionalProperties": true,
              "title": "Body",
              "type": "object"
            }
          },
          "required": [
            "index",
            "body"
          ],
          "title": "search_documentsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_cluster_health",
        "description": "Get cluster health status",
        "inputSchema": {
          "properties": {},
          "title": "get_cluster_healthArguments",
          "type": "object"
        }
      },
      {
        "name": "get_cluster_stats",
        "description": "Get cluster statistics",
        "inputSchema": {
          "properties": {},
          "title": "get_cluster_statsArguments",
          "type": "object"
        }
      }
    ]
  },
  "logfire-mcp": {
    "display_name": "Logfire MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/pydantic/logfire-mcp"
    },
    "license": "MIT",
    "homepage": "https://logfire.pydantic.dev",
    "author": {
      "name": "pydantic"
    },
    "tags": [
      "OpenTelemetry",
      "traces",
      "metrics",
      "logging",
      "monitoring"
    ],
    "arguments": {
      "read_token": {
        "description": "Logfire read token for accessing the Logfire APIs",
        "required": true,
        "example": "YOUR_READ_TOKEN"
      },
      "base_url": {
        "description": "Base URL for the Logfire API (defaults to https://logfire-api.pydantic.dev)",
        "required": false,
        "example": "https://your-logfire-instance.com"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "logfire-mcp"
        ],
        "env": {
          "LOGFIRE_READ_TOKEN": "YOUR_READ_TOKEN"
        },
        "description": "Run using uvx (provided by uv)",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Find exceptions",
        "description": "Find all exceptions in traces from the last hour",
        "prompt": "What exceptions occurred in traces from the last hour across all services?"
      },
      {
        "title": "Analyze file errors",
        "description": "Show recent errors in a specific file with trace context",
        "prompt": "Show me the recent errors in the file 'app/api.py' with their trace context"
      },
      {
        "title": "Error count by service",
        "description": "Count errors in the last 24 hours per service",
        "prompt": "How many errors were there in the last 24 hours per service?"
      }
    ],
    "name": "logfire-mcp",
    "description": "This repository contains a Model Context Protocol (MCP) server with tools that can access the OpenTelemetry traces and",
    "categories": [
      "Dev Tools"
    ],
    "tools": [
      {
        "name": "find_exceptions",
        "description": "Get the exceptions on a file.\n\n    Args:\n        age: Number of minutes to look back, e.g. 30 for last 30 minutes. Maximum allowed value is 7 days.\n    ",
        "inputSchema": {
          "properties": {
            "age": {
              "title": "Age",
              "type": "integer"
            }
          },
          "required": [
            "age"
          ],
          "title": "find_exceptionsArguments",
          "type": "object"
        }
      },
      {
        "name": "find_exceptions_in_file",
        "description": "Get the details about the 10 most recent exceptions on the file.\n\n    Args:\n        filepath: The path to the file to find exceptions in.\n        age: Number of minutes to look back, e.g. 30 for last 30 minutes. Maximum allowed value is 7 days.\n    ",
        "inputSchema": {
          "properties": {
            "filepath": {
              "title": "Filepath",
              "type": "string"
            },
            "age": {
              "title": "Age",
              "type": "integer"
            }
          },
          "required": [
            "filepath",
            "age"
          ],
          "title": "find_exceptions_in_fileArguments",
          "type": "object"
        }
      },
      {
        "name": "arbitrary_query",
        "description": "Run an arbitrary query on the Logfire database.\n\n    The schema is available via the `get_logfire_records_schema` tool.\n\n    Args:\n        query: The query to run, as a SQL string.\n        age: Number of minutes to look back, e.g. 30 for last 30 minutes. Maximum allowed value is 7 days.\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "age": {
              "title": "Age",
              "type": "integer"
            }
          },
          "required": [
            "query",
            "age"
          ],
          "title": "arbitrary_queryArguments",
          "type": "object"
        }
      },
      {
        "name": "get_logfire_records_schema",
        "description": "Get the records schema from Logfire.\n\n    To perform the `arbitrary_query` tool, you can use the `schema://records` to understand the schema.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_logfire_records_schemaArguments",
          "type": "object"
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "goal-story": {
    "name": "goal-story",
    "display_name": "Goal Story",
    "description": "a Goal Tracker and Visualization Tool for personal and professional development.",
    "repository": {
      "type": "git",
      "url": "https://github.com/hichana/goalstory-mcp"
    },
    "homepage": "https://github.com/hichana/goalstory-mcp",
    "author": {
      "name": "hichana"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "goal tracking",
      "storytelling",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "goalstory-mcp",
          "https://prod-goalstory-rqc2.encr.app",
          "${YOUR_API_KEY}"
        ]
      }
    },
    "arguments": {
      "YOUR_API_KEY": {
        "description": "The API key required to authenticate your requests to the Goal Story service.",
        "required": true,
        "example": "abcdefgh12345678"
      }
    },
    "tools": [
      {
        "name": "goalstory_about",
        "description": "Retrieve information about Goal Story's philosophy and the power of story-driven goal achievement. Use this to help users understand the unique approach of Goal Storying.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "goalstory_read_self_user",
        "description": "Get the user's profile data including their preferences, belief systems, and past goal history to enable personalized goal storying and context-aware discussions.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "goalstory_update_self_user",
        "description": "Update the user's profile including their name, visibility preferences, and personal context. When updating 'about' data, guide the user through questions to understand their motivations, beliefs, and goal-achievement style.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The user's preferred name for their Goal Story profile."
            },
            "about": {
              "type": "string",
              "description": "Personal context including motivations, beliefs, and goal-achievement preferences gathered through guided questions."
            },
            "visibility": {
              "type": "number",
              "description": "Profile visibility setting where 0 = public (viewable by others) and 1 = private (only visible to user)."
            }
          }
        }
      },
      {
        "name": "goalstory_count_goals",
        "description": "Get the total number of goals in the user's journey. Useful for tracking overall progress and goal management patterns.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "goalstory_create_goal",
        "description": "Begin the goal clarification process by creating a new goal. Always discuss and refine the goal with the user before or after saving, ensuring it's well-defined and aligned with their aspirations. Confirm if any adjustments are needed after creation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Clear and specific title that captures the essence of the goal."
            },
            "description": {
              "type": "string",
              "description": "Detailed explanation of the goal, including context, motivation, and desired outcomes."
            },
            "story_mode": {
              "type": "string",
              "description": "Narrative approach that shapes how future stories visualize goal achievement."
            },
            "belief_mode": {
              "type": "string",
              "description": "Framework defining how the user's core beliefs and values influence this goal."
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "goalstory_update_goal",
        "description": "Update goal details including name, status, description, outcomes, evidence of completion, and story/belief modes that influence how stories are generated.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the goal to be updated."
            },
            "name": {
              "type": "string",
              "description": "Refined or clarified goal title."
            },
            "status": {
              "type": "number",
              "description": "Goal progress status: 0 = active/in progress, 1 = successfully completed."
            },
            "description": {
              "type": "string",
              "description": "Enhanced goal context, motivation, or outcome details."
            },
            "outcome": {
              "type": "string",
              "description": "Actual results and impact achieved through goal completion or progress."
            },
            "evidence": {
              "type": "string",
              "description": "Concrete proof, measurements, or observations of goal progress/completion."
            },
            "story_mode": {
              "type": "string",
              "description": "Updated narrative style for future goal achievement stories."
            },
            "belief_mode": {
              "type": "string",
              "description": "Refined understanding of how personal beliefs shape this goal."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_destroy_goal",
        "description": "Remove a goal and all its associated steps and stories from the user's journey. Use with confirmation to prevent accidental deletion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the goal to be permanently removed."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_read_one_goal",
        "description": "Retrieve detailed information about a specific goal to support focused discussion and story creation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the goal to retrieve."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_read_goals",
        "description": "Get an overview of the user's goal journey, with optional pagination to manage larger sets of goals.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "description": "Page number for viewing subsets of goals (starts at 1)."
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of goals to return per page."
            }
          }
        }
      },
      {
        "name": "goalstory_read_current_focus",
        "description": "Identify which goal and step the user is currently focused on to maintain context in discussions and story creation.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "goalstory_get_story_context",
        "description": "Gather rich context about the user, their current goal/step, beliefs, and motivations to create deeply personalized and meaningful stories. Combines user profile data with conversation insights.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goalId": {
              "type": "string",
              "description": "Unique identifier of the goal for context gathering."
            },
            "stepId": {
              "type": "string",
              "description": "Unique identifier of the specific step for context gathering."
            },
            "feedback": {
              "type": "string",
              "description": "Additional user input to enhance context understanding."
            }
          },
          "required": [
            "goalId",
            "stepId"
          ]
        }
      },
      {
        "name": "goalstory_create_steps",
        "description": "Formulate actionable steps for a goal through thoughtful discussion. Present the steps for user review either before or after saving, ensuring they're clear and achievable. Confirm if any refinements are needed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal_id": {
              "type": "string",
              "description": "Unique identifier of the goal these steps will help achieve."
            },
            "steps": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of clear, actionable step descriptions in sequence."
            }
          },
          "required": [
            "goal_id",
            "steps"
          ]
        }
      },
      {
        "name": "goalstory_read_steps",
        "description": "Access the action plan for a specific goal, showing all steps in the journey toward achievement.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal_id": {
              "type": "string",
              "description": "Unique identifier of the goal whose steps to retrieve."
            },
            "page": {
              "type": "number",
              "description": "Page number for viewing subsets of steps (starts at 1)."
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of steps to return per page."
            }
          },
          "required": [
            "goal_id"
          ]
        }
      },
      {
        "name": "goalstory_read_one_step",
        "description": "Get detailed information about a specific step to support focused discussion and story creation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the step to retrieve."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_update_step",
        "description": "Update step details including the name, completion status, evidence, and outcome. Use this to track progress and insights.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the step to update."
            },
            "name": {
              "type": "string",
              "description": "Refined or clarified step description."
            },
            "status": {
              "type": "number",
              "description": "Step completion status: 0 = pending/in progress, 1 = completed."
            },
            "outcome": {
              "type": "string",
              "description": "Results and impact achieved through completing this step."
            },
            "evidence": {
              "type": "string",
              "description": "Concrete proof or observations of step completion."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_destroy_step",
        "description": "Remove a specific step from a goal's action plan.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the step to be permanently removed."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_update_step_notes",
        "description": "Update step notes with additional context, insights, or reflections in markdown format. Use this to capture valuable information from discussions.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the step to update."
            },
            "notes": {
              "type": "string",
              "description": "Additional context, insights, or reflections in markdown format."
            }
          },
          "required": [
            "id",
            "notes"
          ]
        }
      },
      {
        "name": "goalstory_create_story",
        "description": "Generate and save a highly personalized story that visualizes achievement of the current goal/step. Uses understanding of the user's beliefs, motivations, and context to create engaging mental imagery. If context is needed, gathers it through user discussion and profile data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal_id": {
              "type": "string",
              "description": "Unique identifier of the goal this story supports."
            },
            "step_id": {
              "type": "string",
              "description": "Unique identifier of the specific step this story visualizes."
            },
            "title": {
              "type": "string",
              "description": "Engaging headline that captures the essence of the story."
            },
            "story_text": {
              "type": "string",
              "description": "Detailed narrative that vividly illustrates goal/step achievement."
            }
          },
          "required": [
            "goal_id",
            "step_id",
            "title",
            "story_text"
          ]
        }
      },
      {
        "name": "goalstory_read_stories",
        "description": "Access the collection of personalized stories created for a specific goal/step pair, supporting reflection and motivation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal_id": {
              "type": "string",
              "description": "Unique identifier of the goal whose stories to retrieve."
            },
            "step_id": {
              "type": "string",
              "description": "Unique identifier of the step whose stories to retrieve."
            },
            "page": {
              "type": "number",
              "description": "Page number for viewing subsets of stories (starts at 1)."
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of stories to return per page."
            }
          },
          "required": [
            "goal_id",
            "step_id"
          ]
        }
      },
      {
        "name": "goalstory_read_one_story",
        "description": "Retrieve a specific story to revisit the visualization and mental imagery created for goal achievement.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the story to retrieve."
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  "heurist-mesh-agent": {
    "name": "heurist-mesh-agent",
    "display_name": "Mesh Agent",
    "description": "Access specialized web3 AI agents for blockchain analysis, smart contract security, token metrics, and blockchain interactions through the [Heurist Mesh network](https://github.com/heurist-network/heurist-agent-framework/tree/main/mesh).",
    "repository": {
      "type": "git",
      "url": "https://github.com/heurist-network/heurist-mesh-mcp-server"
    },
    "homepage": "https://github.com/heurist-network/heurist-mesh-mcp-server",
    "author": {
      "name": "Heurist Network"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Heurist",
      "Agent Framework",
      "Blockchain Tools"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/heurist-network/heurist-mesh-mcp-server",
          "mesh-tool-server"
        ],
        "env": {
          "HEURIST_API_KEY": "${HEURIST_API_KEY}"
        }
      }
    },
    "arguments": {
      "HEURIST_API_KEY": {
        "description": "API key for accessing the Heurist services.",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "tools": [
      {
        "name": "coingeckotokeninfoagent_get_coingecko_id",
        "description": "Search for a token by name to get its CoinGecko ID. This tool helps you find the correct CoinGecko ID for any cryptocurrency when you only know its name or symbol. The CoinGecko ID is required for fetching detailed token information using other CoinGecko tools.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "token_name": {
              "type": "string",
              "description": "The token name to search for"
            }
          },
          "required": [
            "token_name"
          ]
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_token_info",
        "description": "Get detailed token information and market data using CoinGecko ID. This tool provides comprehensive cryptocurrency data including current price, market cap, trading volume, price changes, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "coingecko_id": {
              "type": "string",
              "description": "The CoinGecko ID of the token"
            }
          },
          "required": [
            "coingecko_id"
          ]
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_trending_coins",
        "description": "Get the current top trending cryptocurrencies on CoinGecko. This tool retrieves a list of the most popular cryptocurrencies based on trading volume and social media mentions.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_token_price_multi",
        "description": "Fetch price data for multiple tokens at once using CoinGecko IDs. Efficiently retrieves current prices and optional market data for multiple cryptocurrencies in a single API call.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "string",
              "description": "Comma-separated CoinGecko IDs of the tokens to query"
            },
            "vs_currencies": {
              "type": "string",
              "description": "Comma-separated target currencies (e.g., usd,eur,btc)",
              "default": "usd"
            },
            "include_market_cap": {
              "type": "boolean",
              "description": "Include market capitalization data",
              "default": false
            },
            "include_24hr_vol": {
              "type": "boolean",
              "description": "Include 24hr trading volume data",
              "default": false
            },
            "include_24hr_change": {
              "type": "boolean",
              "description": "Include 24hr price change percentage",
              "default": false
            },
            "include_last_updated_at": {
              "type": "boolean",
              "description": "Include timestamp of when the data was last updated",
              "default": false
            },
            "precision": {
              "type": "string",
              "description": "Decimal precision for currency values (e.g., 'full' for maximum precision)",
              "default": false
            }
          },
          "required": [
            "ids",
            "vs_currencies"
          ]
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_categories_list",
        "description": "Get a list of all available cryptocurrency categories from CoinGecko. This tool retrieves all the category IDs and names that can be used for further category-specific queries.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_category_data",
        "description": "Get market data for all cryptocurrency categories from CoinGecko. This tool retrieves comprehensive information about all categories including market cap, volume, market cap change, top coins in each category, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "order": {
              "type": "string",
              "description": "Sort order for categories (default: market_cap_desc)",
              "enum": [
                "market_cap_desc",
                "market_cap_asc",
                "name_desc",
                "name_asc",
                "market_cap_change_24h_desc",
                "market_cap_change_24h_asc"
              ]
            }
          },
          "required": []
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_tokens_by_category",
        "description": "Get a list of tokens within a specific category. This tool retrieves token data for all cryptocurrencies that belong to a particular category, including price, market cap, volume, and price changes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_id": {
              "type": "string",
              "description": "The CoinGecko category ID (e.g., 'layer-1')"
            },
            "vs_currency": {
              "type": "string",
              "description": "The currency to show results in (default: usd)",
              "default": "usd"
            },
            "order": {
              "type": "string",
              "description": "Sort order for tokens (default: market_cap_desc)",
              "enum": [
                "market_cap_desc",
                "market_cap_asc",
                "volume_desc",
                "volume_asc",
                "id_asc",
                "id_desc"
              ],
              "default": "market_cap_desc"
            },
            "per_page": {
              "type": "integer",
              "description": "Number of results per page (1-250, default: 100)",
              "default": 100,
              "minimum": 1,
              "maximum": 250
            },
            "page": {
              "type": "integer",
              "description": "Page number (default: 1)",
              "default": 1,
              "minimum": 1
            }
          },
          "required": [
            "category_id"
          ]
        }
      },
      {
        "name": "dexscreenertokeninfoagent_search_pairs",
        "description": "Search for trading pairs on decentralized exchanges by token name, symbol, or address. This tool helps you find specific trading pairs across multiple DEXs and blockchains. It returns information about the pairs including price, volume, liquidity, and the exchanges where they're available. Data comes from DexScreener and covers major DEXs on most blockchains. The search results may be incomplete if the token is not traded on any of the supported chains.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search_term": {
              "type": "string",
              "description": "Search term (token name, symbol, or address)"
            }
          },
          "required": [
            "search_term"
          ]
        }
      },
      {
        "name": "dexscreenertokeninfoagent_get_specific_pair_info",
        "description": "Get detailed information about a specific trading pair on a decentralized exchange by chain and pair address. This tool provides comprehensive data about a DEX trading pair including current price, 24h volume, liquidity, price changes, and trading history. Data comes from DexScreener and is updated in real-time. You must specify both the blockchain and the exact pair contract address. The pair address is the LP contract address, not the quote token address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chain": {
              "type": "string",
              "description": "Chain identifier (e.g., solana, bsc, ethereum, base)"
            },
            "pair_address": {
              "type": "string",
              "description": "The pair contract address to look up"
            }
          },
          "required": [
            "chain",
            "pair_address"
          ]
        }
      },
      {
        "name": "dexscreenertokeninfoagent_get_token_pairs",
        "description": "Get all trading pairs for a specific token across decentralized exchanges by chain and token address. This tool retrieves a comprehensive list of all DEX pairs where the specified token is traded on a particular blockchain. It provides data on each pair including the paired token, exchange, price, volume, and liquidity. Data comes from DexScreener and is updated in real-time. You must specify both the blockchain and the exact token contract address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chain": {
              "type": "string",
              "description": "Chain identifier (e.g., solana, bsc, ethereum, base)"
            },
            "token_address": {
              "type": "string",
              "description": "The token contract address to look up all pairs for"
            }
          },
          "required": [
            "chain",
            "token_address"
          ]
        }
      },
      {
        "name": "elfatwitterintelligenceagent_search_mentions",
        "description": "Search for mentions of specific tokens or topics on Twitter. This tool finds discussions about cryptocurrencies, blockchain projects, or other topics of interest. It provides the tweets and mentions of smart accounts (only influential ones) and does not contain all tweets. Use this when you want to understand what influential people are saying about a particular token or topic on Twitter. Each of the search keywords should be one word or phrase. A maximum of 5 keywords are allowed. One key word should be one concept. Never use long sentences or phrases as keywords.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of keywords to search for"
            },
            "days_ago": {
              "type": "number",
              "description": "Number of days to look back",
              "default": 20
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results (minimum: 20)",
              "default": 20
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "elfatwitterintelligenceagent_search_account",
        "description": "Search for a Twitter account with both mention search and account statistics. This tool provides engagement metrics, follower growth, and mentions by smart users. It does not contain all tweets, but only those of influential users. It also identifies the topics and cryptocurrencies they frequently discuss. Data comes from ELFA API and can analyze several weeks of historical activity.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "Twitter username to analyze (without @)"
            },
            "days_ago": {
              "type": "number",
              "description": "Number of days to look back for mentions",
              "default": 30
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of mention results",
              "default": 20
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "elfatwitterintelligenceagent_get_trending_tokens",
        "description": "Get current trending tokens on Twitter. This tool identifies which cryptocurrencies and tokens are generating the most buzz on Twitter right now. The results include token names, their relative popularity, and sentiment indicators. Use this when you want to discover which cryptocurrencies are currently being discussed most actively on social media. Data comes from ELFA API and represents real-time trends.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "time_window": {
              "type": "string",
              "description": "Time window to analyze",
              "default": "24h"
            }
          }
        }
      },
      {
        "name": "exasearchagent_exa_web_search",
        "description": "Search for webpages related to a query using Exa search. This tool performs a web search and returns relevant results including titles, snippets, and URLs. It's useful for finding up-to-date information on any topic, but may fail to find information of niche topics such like small cap crypto projects. Use this when you need to gather information from across the web.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search_term": {
              "type": "string",
              "description": "The search term"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return (default: 10)"
            }
          },
          "required": [
            "search_term"
          ]
        }
      },
      {
        "name": "exasearchagent_exa_answer_question",
        "description": "Get a direct answer to a question using Exa's answer API. This tool provides concise, factual answers to specific questions by searching and analyzing content from across the web. Use this when you need a direct answer to a specific question rather than a list of search results. It may fail to find information of niche topics such like small cap crypto projects.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "question": {
              "type": "string",
              "description": "The question to answer"
            }
          },
          "required": [
            "question"
          ]
        }
      },
      {
        "name": "firecrawlsearchagent_firecrawl_web_search",
        "description": "Execute a web search query by reading the web pages using Firecrawl. It provides more comprehensive information than standard web search by extracting the full contents from the pages. Use this when you need in-depth information on a topic. Data comes from Firecrawl search API. It may fail to find information of niche topics such like small cap crypto projects.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search_term": {
              "type": "string",
              "description": "The search term to execute"
            }
          },
          "required": [
            "search_term"
          ]
        }
      },
      {
        "name": "firecrawlsearchagent_firecrawl_extract_web_data",
        "description": "Extract structured data from one or multiple web pages using natural language instructions using Firecrawl. This tool can process single URLs or entire domains (using wildcards like example.com/*). Use this when you need specific information from websites rather than general search results. You must specify what data to extract from the pages using the 'extraction_prompt' parameter.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of URLs to extract data from. Can include wildcards (e.g., 'example.com/*') to crawl entire domains."
            },
            "extraction_prompt": {
              "type": "string",
              "description": "Natural language description of what data to extract from the pages."
            }
          },
          "required": [
            "urls",
            "extraction_prompt"
          ]
        }
      },
      {
        "name": "goplusanalysisagent_fetch_security_details",
        "description": "Fetch security details of a blockchain token contract",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_address": {
              "type": "string",
              "description": "The token contract address"
            },
            "chain_id": {
              "type": "string",
              "description": "The blockchain chain ID or 'solana' for Solana tokens. Supported chains: Ethereum (1), Optimism (10), Cronos (25), BSC (56), Gnosis (100), HECO (128), Polygon (137), Fantom (250), KCC (321), zkSync Era (324), ETHW (10001), FON (201022), Arbitrum (42161), Avalanche (43114), Linea Mainnet (59144), Base (8453), Tron (tron), Scroll (534352), opBNB (204), Mantle (5000), ZKFair (42766), Blast (81457), Manta Pacific (169), Berachain Artio Testnet (80085), Merlin (4200), Bitlayer Mainnet (200901), zkLink Nova (810180), X Layer Mainnet (196), Solana (solana)",
              "default": 1
            }
          },
          "required": [
            "contract_address"
          ]
        }
      }
    ]
  },
  "json": {
    "name": "json",
    "display_name": "JSON Model Context Protocol",
    "description": "JSON handling and processing server with advanced query capabilities using JSONPath syntax and support for array, string, numeric, and date operations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/JSON-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/JSON-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "json",
      "data querying",
      "standardized tools"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@gongrzhe/server-json-mcp@1.0.3"
        ]
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Query JSON data using JSONPath syntax",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the JSON data source"
            },
            "jsonPath": {
              "type": "string",
              "description": "JSONPath expression (e.g. $.store.book[*].author)"
            }
          },
          "required": [
            "url",
            "jsonPath"
          ]
        }
      },
      {
        "name": "filter",
        "description": "Filter JSON data using conditions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the JSON data source"
            },
            "jsonPath": {
              "type": "string",
              "description": "Base JSONPath expression"
            },
            "condition": {
              "type": "string",
              "description": "Filter condition (e.g. @.price < 10)"
            }
          },
          "required": [
            "url",
            "jsonPath",
            "condition"
          ]
        }
      }
    ]
  },
  "algorand": {
    "name": "algorand",
    "display_name": "Algorand Implementation",
    "description": "A comprehensive MCP server for tooling interactions (40+) and resource accessibility (60+) plus many useful prompts for interacting with the Algorand blockchain.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GoPlausible/algorand-mcp"
    },
    "homepage": "https://github.com/GoPlausible/algorand-mcp",
    "author": {
      "name": "GoPlausible",
      "url": "https://goplausible.com"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Algorand",
      "Blockchain"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "algorand-mcp"
        ],
        "env": {
          "NFD_API_KEY": "${NFD_API_KEY}",
          "NFD_API_URL": "${NFD_API_URL}",
          "ALGORAND_ALGOD": "${ALGORAND_ALGOD}",
          "ALGORAND_TOKEN": "${ALGORAND_TOKEN}",
          "ALGORAND_INDEXER": "${ALGORAND_INDEXER}",
          "ALGORAND_INDEXER_API": "${ALGORAND_INDEXER_API}",
          "ALGORAND_INDEXER_PORT": "${ALGORAND_INDEXER_PORT}",
          "ALGORAND_NETWORK": "${ALGORAND_NETWORK}"
        }
      }
    },
    "arguments": {
      "NFD_API_KEY": {
        "description": "API key for the NFD service, required for accessing domain functionalities.",
        "required": true,
        "example": "your_nfd_api_key_here"
      },
      "NFD_API_URL": {
        "description": "The URL endpoint for the NFD API service.",
        "required": false,
        "example": "https://api.nf.domains"
      },
      "ALGORAND_ALGOD": {
        "description": "The URL endpoint for the Algorand Algod node.",
        "required": true,
        "example": "https://testnet-api.algonode.cloud"
      },
      "ALGORAND_TOKEN": {
        "description": "The token required to interact with the Algorand Algod node, usually a blank string for testnets.",
        "required": false,
        "example": ""
      },
      "ALGORAND_INDEXER": {
        "description": "The URL endpoint for the Algorand Indexer service.",
        "required": true,
        "example": "https://testnet-idx.algonode.cloud"
      },
      "ALGORAND_INDEXER_API": {
        "description": "The API endpoint for accessing Algorand indexer functionalities.",
        "required": false,
        "example": "https://testnet-idx.algonode.cloud/v2"
      },
      "ALGORAND_INDEXER_PORT": {
        "description": "The port for the Algorand indexer service, usually left blank for default settings.",
        "required": false,
        "example": ""
      },
      "ALGORAND_NETWORK": {
        "description": "The network type being used (e.g., testnet or mainnet).",
        "required": true,
        "example": "testnet"
      }
    }
  },
  "mcp-aiven": {
    "display_name": "Aiven MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/Aiven-Open/mcp-aiven"
    },
    "homepage": "[NOT GIVEN]",
    "author": {
      "name": "Aiven-Open"
    },
    "license": "[NOT GIVEN]",
    "tags": [
      "PostgreSQL",
      "Kafka",
      "ClickHouse",
      "Valkey",
      "OpenSearch"
    ],
    "arguments": {
      "AIVEN_BASE_URL": {
        "description": "The Aiven API url",
        "required": true,
        "example": "https://api.aiven.io"
      },
      "AIVEN_TOKEN": {
        "description": "The authentication token",
        "required": true,
        "example": "$AIVEN_TOKEN"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/Aiven-Open/mcp-aiven.git",
          "mcp-aiven"
        ],
        "env": {
          "AIVEN_BASE_URL": "https://api.aiven.io",
          "AIVEN_TOKEN": "$AIVEN_TOKEN"
        },
        "description": "Run using uv package manager",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "List Projects",
        "description": "List all projects on your Aiven account",
        "prompt": "List all my Aiven projects"
      },
      {
        "title": "List Services",
        "description": "List all services in a specific Aiven project",
        "prompt": "Show me all services in my Aiven project"
      },
      {
        "title": "Get Service Details",
        "description": "Get the detail of your service in a specific Aiven project",
        "prompt": "Get details about my PostgreSQL service in Aiven"
      }
    ],
    "name": "mcp-aiven",
    "description": "A [Model Context Protocol](https://modelcontextprotocol.io/) (MCP) server for Aiven.",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "keycloak-mcp": {
    "name": "keycloak-mcp",
    "display_name": "Keycloak Model Context Protocol",
    "description": "This MCP server enables natural language interaction with Keycloak for user and realm management including creating, deleting, and listing users and realms.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ChristophEnglisch/keycloak-model-context-protocol"
    },
    "homepage": "https://github.com/ChristophEnglisch/keycloak-model-context-protocol",
    "author": {
      "name": "ChristophEnglisch"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Keycloak",
      "User Management",
      "Realm Management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "keycloak-model-context-protocol"
        ],
        "env": {
          "KEYCLOAK_URL": "${KEYCLOAK_URL}",
          "KEYCLOAK_ADMIN": "${KEYCLOAK_ADMIN}",
          "KEYCLOAK_ADMIN_PASSWORD": "${KEYCLOAK_ADMIN_PASSWORD}"
        }
      }
    },
    "arguments": {
      "KEYCLOAK_URL": {
        "description": "The URL of the Keycloak server instance that the MCP will connect to.",
        "required": true,
        "example": "http://localhost:8080"
      },
      "KEYCLOAK_ADMIN": {
        "description": "The admin username for accessing the Keycloak server.",
        "required": true,
        "example": "admin"
      },
      "KEYCLOAK_ADMIN_PASSWORD": {
        "description": "The password for the admin user to access the Keycloak server.",
        "required": true,
        "example": "admin"
      }
    }
  },
  "coin-api-mcp": {
    "name": "coin-api-mcp",
    "display_name": "Coin API",
    "description": "Provides access to [coinmarketcap](https://coinmarketcap.com/) cryptocurrency data.",
    "repository": {
      "type": "git",
      "url": "https://github.com/longmans/coin_api_mcp"
    },
    "homepage": "https://github.com/longmans/coin_api_mcp",
    "author": {
      "name": "longmans"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "CoinMarketCap",
      "Cryptocurrency",
      "Data"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/longmans/coin_api_mcp",
          "coin-api"
        ],
        "env": {
          "COINMARKETCAP_API_KEY": "${COINMARKETCAP_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Fetch List of Coins",
        "description": "Retrieve a paginated list of all active cryptocurrencies with market data.",
        "prompt": "Call `listing-coins` to get the latest cryptocurrency listings."
      },
      {
        "title": "Get Coin Information",
        "description": "Retrieve detailed information about a specific cryptocurrency by its ID or symbol.",
        "prompt": "Call `get-coin-info` using the cryptocurrency ID."
      }
    ],
    "arguments": {
      "COINMARKETCAP_API_KEY": {
        "description": "The API key required to access CoinMarketCap data.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "listing-coins",
        "description": "Returns a paginated list of all active cryptocurrencies with latest market data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start": {
              "type": "integer",
              "description": "Optionally offset the start (1-based index) of the paginated list of items to return.",
              "minimum": 1
            },
            "limit": {
              "type": "integer",
              "description": "Optionally specify the number of results to return.",
              "minimum": 1,
              "maximum": 5000
            },
            "price_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum USD price to filter results by.",
              "minimum": 0
            },
            "price_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum USD price to filter results by.",
              "minimum": 0
            },
            "market_cap_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum market cap to filter results by.",
              "minimum": 0
            },
            "market_cap_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum market cap to filter results by.",
              "minimum": 0
            },
            "volume_24h_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum 24 hour USD volume to filter results by.",
              "minimum": 0
            },
            "volume_24h_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum 24 hour USD volume to filter results by.",
              "minimum": 0
            },
            "circulating_supply_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum circulating supply to filter results by.",
              "minimum": 0
            },
            "circulating_supply_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum circulating supply to filter results by.",
              "minimum": 0
            },
            "percent_change_24h_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum 24 hour percent change to filter results by.",
              "minimum": -100
            },
            "percent_change_24h_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum 24 hour percent change to filter results by.",
              "minimum": -100
            },
            "convert": {
              "type": "string",
              "description": "Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols."
            },
            "convert_id": {
              "type": "string",
              "description": "Optionally calculate market quotes by CoinMarketCap ID instead of symbol."
            },
            "sort": {
              "type": "string",
              "description": "What field to sort the list of cryptocurrencies by.",
              "enum": [
                "market_cap",
                "name",
                "symbol",
                "date_added",
                "market_cap_strict",
                "price",
                "circulating_supply",
                "total_supply",
                "max_supply",
                "num_market_pairs",
                "volume_24h",
                "percent_change_1h",
                "percent_change_24h",
                "percent_change_7d",
                "market_cap_by_total_supply_strict",
                "volume_7d",
                "volume_30d"
              ]
            },
            "sort_dir": {
              "type": "string",
              "description": "The direction in which to order cryptocurrencies against the specified sort.",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "cryptocurrency_type": {
              "type": "string",
              "description": "The type of cryptocurrency to include.",
              "enum": [
                "all",
                "coins",
                "tokens"
              ]
            },
            "tag": {
              "type": "string",
              "description": "The tag of cryptocurrency to include.",
              "enum": [
                "all",
                "defi",
                "filesharing"
              ]
            },
            "aux": {
              "type": "string",
              "description": "Optionally specify a comma-separated list of supplemental data fields to return."
            }
          },
          "required": []
        }
      },
      {
        "name": "get-coin-info",
        "description": "Get coins' information includes details like logo, description, official website URL, social links, and links to a cryptocurrency's technical documentation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "One or more comma-separated CoinMarketCap cryptocurrency IDs. Example: \"1,2\""
            },
            "slug": {
              "type": "string",
              "description": "Alternatively pass a comma-separated list of cryptocurrency slugs. Example: \"bitcoin,ethereum\""
            },
            "symbol": {
              "type": "string",
              "description": "Alternatively pass one or more comma-separated cryptocurrency symbols. Example: \"BTC,ETH\""
            },
            "address": {
              "type": "string",
              "description": "Alternatively pass in a contract address. Example: \"0xc40af1e4fecfa05ce6bab79dcd8b373d2e436c4e\""
            },
            "skip_invalid": {
              "type": "boolean",
              "description": "Pass true to relax request validation rules. When requesting records on multiple cryptocurrencies an error is returned if any invalid cryptocurrencies are requested or a cryptocurrency does not have matching records in the requested timeframe. If set to true, invalid lookups will be skipped allowing valid cryptocurrencies to still be returned.",
              "default": false
            },
            "aux": {
              "type": "string",
              "description": "Optionally specify a comma-separated list of supplemental data fields to return. Pass urls,logo,description,tags,platform,date_added,notice,status to include all auxiliary fields."
            }
          },
          "required": []
        }
      },
      {
        "name": "get-coin-quotes",
        "description": "the latest market quote for 1 or more cryptocurrencies. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "One or more comma-separated cryptocurrency CoinMarketCap IDs. Example: 1,2"
            },
            "slug": {
              "type": "string",
              "description": "Alternatively pass a comma-separated list of cryptocurrency slugs. Example: \"bitcoin,ethereum\""
            },
            "symbol": {
              "type": "string",
              "description": "Alternatively pass one or more comma-separated cryptocurrency symbols. Example: \"BTC,ETH\""
            },
            "convert": {
              "type": "string",
              "description": "Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols."
            },
            "convert_id": {
              "type": "string",
              "description": "Optionally calculate market quotes by CoinMarketCap ID instead of symbol. This option is identical to\u00a0convert\u00a0outside of ID format."
            },
            "aux": {
              "type": "string",
              "description": "\"num_market_pairs,cmc_rank,date_added,tags,platform,max_supply,circulating_supply,total_supply,is_active,is_fiat\"Optionally specify a comma-separated list of supplemental data fields to return."
            },
            "skip_invalid": {
              "type": "boolean",
              "description": "Pass true to relax request validation rules.",
              "default": false
            }
          },
          "required": []
        }
      }
    ]
  },
  "pif": {
    "name": "pif",
    "display_name": "PIF Framework",
    "description": "A Personal Intelligence Framework (PIF), providing tools for file operations, structured reasoning, and journal-based documentation to support continuity and evolving human-AI collaboration across sessions.",
    "repository": {
      "type": "git",
      "url": "https://github.com/hungryrobot1/MCP-PIF"
    },
    "homepage": "https://github.com/hungryrobot1/MCP-PIF",
    "author": {
      "name": "hungryrobot1"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "PIF",
      "TypeScript",
      "Node.js"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/hungryrobot1/MCP-PIF"
        ]
      }
    },
    "examples": [
      {
        "title": "Reasoning Example",
        "description": "Create a structured thought pattern.",
        "prompt": "reason: { thoughts: [{ content: 'Initial observation' }, { content: 'Building on previous thought', relationType: 'sequence', relationTo: 0 }] }"
      },
      {
        "title": "Journal Creation Example",
        "description": "Document development for future reference.",
        "prompt": "journal_create: { title: 'Implementation Pattern', content: 'Insights about development...', tags: ['development', 'patterns'] }"
      }
    ],
    "arguments": {
      "MCP_WORKSPACE_ROOT": {
        "description": "Environment variable to specify a workspace location for the server.",
        "required": false,
        "example": "/path/to/workspace"
      },
      "MCP_CONFIG": {
        "description": "Environment variable containing a JSON string of configuration options for the server.",
        "required": false,
        "example": "{\"key\": \"value\"}"
      }
    }
  },
  "graphql-schema": {
    "name": "graphql-schema",
    "display_name": "GraphQL Schema Model Context Protocol",
    "description": "Allow LLMs to explore large GraphQL schemas without bloating the context.",
    "repository": {
      "type": "git",
      "url": "https://github.com/hannesj/mcp-graphql-schema"
    },
    "homepage": "https://github.com/hannesj/mcp-graphql-schema",
    "author": {
      "name": "hannesj"
    },
    "license": "[NOT FOUND]",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "GraphQL",
      "LLMs",
      "Schema",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-graphql-schema",
          "/ABSOLUTE/PATH/TO/schema.graphqls"
        ]
      }
    },
    "examples": [
      {
        "title": "List all query fields",
        "description": "Retrieve a list of all available root-level fields for GraphQL queries.",
        "prompt": "What query fields are available in this GraphQL schema?"
      },
      {
        "title": "User query field details",
        "description": "Get detailed definition for the \"user\" query field.",
        "prompt": "Show me the details of the \"user\" query field."
      },
      {
        "title": "Mutation operations",
        "description": "List all mutation operations that can be performed in the schema.",
        "prompt": "What mutation operations can I perform in this schema?"
      },
      {
        "title": "List all types",
        "description": "Retrieve a list of all types defined in the schema.",
        "prompt": "List all types defined in this schema."
      },
      {
        "title": "Type definition",
        "description": "Show the definition of the \"Product\" type.",
        "prompt": "Show me the definition of the \"Product\" type."
      },
      {
        "title": "Order type fields",
        "description": "List all fields of the \"Order\" type.",
        "prompt": "List all fields of the \"Order\" type."
      },
      {
        "title": "Search for types and fields",
        "description": "Search the schema for types and fields related to \"customer.\"",
        "prompt": "Search for types and fields related to \"customer\"."
      }
    ]
  },
  "hyperbrowser": {
    "display_name": "Hyperbrowser MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/hyperbrowserai/mcp"
    },
    "homepage": "https://docs.hyperbrowser.ai/",
    "author": {
      "name": "hyperbrowserai"
    },
    "license": "MIT",
    "tags": [
      "browser",
      "web",
      "scraping",
      "crawling",
      "automation"
    ],
    "arguments": {
      "HYPERBROWSER_API_KEY": {
        "description": "Your Hyperbrowser API key",
        "required": true,
        "example": "YOUR-API-KEY"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "hyperbrowser-mcp",
          "${HYPERBROWSER_API_KEY}"
        ],
        "package": "hyperbrowser-mcp",
        "env": {},
        "description": "Install via npm",
        "recommended": true
      },
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "dist/server.js"
        ],
        "env": {},
        "description": "Run from source code after building",
        "recommended": false
      }
    },
    "examples": [
      {
        "title": "Scrape webpage",
        "description": "Extract formatted content from any webpage",
        "prompt": "Use the scrape_webpage tool to get the content from https://example.com"
      },
      {
        "title": "Extract structured data",
        "description": "Convert HTML into structured JSON",
        "prompt": "Use the extract_structured_data tool to get product information from an e-commerce page"
      },
      {
        "title": "Web search",
        "description": "Search the web using Bing",
        "prompt": "Use the search_with_bing tool to find information about climate change"
      }
    ],
    "name": "hyperbrowser",
    "description": "This is Hyperbrowser's Model Context Protocol (MCP) Server. It provides various tools to scrape, extract structured data, and crawl webpages. It also provides easy access to general purpose browser agents like OpenAI's CUA, Anthropic's Claude Computer Use, and Browser Use.",
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "scrape_webpage",
        "description": "Scrape a webpage and extract its content in various formats. This tool allows fetching content from a single URL with configurable browser behavior options. Use this for extracting text content, HTML structure, collecting links, or capturing screenshots of webpages.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri",
              "description": "The URL of the webpage to scrape"
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                }
              },
              "additionalProperties": false,
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly"
            },
            "outputFormat": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "markdown",
                  "html",
                  "links",
                  "screenshot"
                ]
              },
              "minItems": 1,
              "description": "The format of the output"
            }
          },
          "required": [
            "url",
            "outputFormat"
          ]
        }
      },
      {
        "name": "crawl_webpages",
        "description": "Crawl a website starting from a URL and explore linked pages. This tool allows systematic collection of content from multiple pages within a domain. Use this for larger data collection tasks, content indexing, or site mapping.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri",
              "description": "The URL of the webpage to crawl."
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                }
              },
              "additionalProperties": false,
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly"
            },
            "outputFormat": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "markdown",
                  "html",
                  "links",
                  "screenshot"
                ]
              },
              "minItems": 1,
              "description": "The format of the output"
            },
            "followLinks": {
              "type": "boolean",
              "description": "Whether to follow links on the crawled webpages"
            },
            "maxPages": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "minimum": 1,
              "maximum": 100,
              "default": 10
            },
            "ignoreSitemap": {
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "url",
            "outputFormat",
            "followLinks"
          ]
        }
      },
      {
        "name": "extract_structured_data",
        "description": "Extract structured data from a webpage. This tool allows you to extract structured data from a webpage using a schema.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uri"
              },
              "description": "The list of URLs of the webpages to extract structured information from. Can include wildcards (e.g. https://example.com/*)"
            },
            "prompt": {
              "type": "string",
              "description": "The prompt to use for the extraction"
            },
            "schema": {
              "description": "The json schema to use for the extraction. Must provide an object describing a spec compliant json schema, any other types are invalid."
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                }
              },
              "additionalProperties": false,
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly"
            }
          },
          "required": [
            "urls",
            "prompt"
          ]
        }
      },
      {
        "name": "browser_use_agent",
        "description": "This tool employs an open-source browser automation agent optimized specifically for fast, efficient, and cost-effective browser tasks using a cloud browser. It requires explicit, detailed instructions to perform highly specific interactions quickly.\n\nOptimal for tasks requiring:\n- Precise, explicitly defined interactions and actions\n- Speed and efficiency with clear, unambiguous instructions\n- Cost-effective automation at scale with straightforward workflows\n\nBest suited use cases include:\n- Explicitly defined registration and login processes\n- Clearly guided navigation through web apps\n- Structured, step-by-step web scraping with detailed guidance\n- Extracting data via explicitly specified browser interactions\n\nYou must provide extremely detailed step-by-step instructions, including exact elements, actions, and explicit context. Clearly define the desired outcome for optimal results. Returns the completed result or an error message if issues arise.\n\nNote: This agent trades off flexibility for significantly faster performance and lower costs compared to Claude and OpenAI agents.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "The task to perform inside the browser"
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                }
              },
              "additionalProperties": false,
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly"
            },
            "returnStepInfo": {
              "type": "boolean",
              "default": false,
              "description": "Whether to return step-by-step information about the task.Should be false by default. May contain excessive information, so we strongly recommend setting this to false."
            },
            "maxSteps": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "minimum": 1,
              "maximum": 100,
              "default": 25
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "openai_computer_use_agent",
        "description": "This tool utilizes OpenAI's model to autonomously execute general-purpose browser-based tasks with balanced performance and reliability using a cloud browser. It handles complex interactions effectively with practical reasoning and clear execution.\n\nOptimal for tasks requiring:\n- Reliable, general-purpose browser automation\n- Clear, structured interactions with moderate complexity\n- Efficient handling of common web tasks and workflows\n\nBest suited use cases include:\n- Standard multi-step registration or form submissions\n- Navigating typical web applications requiring multiple interactions\n- Conducting structured web research tasks\n- Extracting data through interactive web processes\n\nProvide a clear step-by-step description, necessary context, and expected outcomes. Returns the completed result or an error message if issues arise.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "The task to perform inside the browser"
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                }
              },
              "additionalProperties": false,
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly"
            },
            "returnStepInfo": {
              "type": "boolean",
              "default": false,
              "description": "Whether to return step-by-step information about the task.Should be false by default. May contain excessive information, so we strongly recommend setting this to false."
            },
            "maxSteps": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "minimum": 1,
              "maximum": 100,
              "default": 25
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "claude_computer_use_agent",
        "description": "This tool leverages Anthropic's Claude model to autonomously execute complex browser tasks with sophisticated reasoning capabilities using a cloud browser. It specializes in handling intricate, nuanced, or highly context-sensitive web interactions.\n\nOptimal for tasks requiring:\n- Complex reasoning over multiple web pages\n- Nuanced interpretation and flexible decision-making\n- Human-like interaction with detailed context awareness\n\nBest suited use cases include:\n- Multi-step processes requiring reasoning (e.g., detailed registrations or onboarding)\n- Interacting intelligently with advanced web apps\n- Conducting in-depth research with complex conditions\n- Extracting information from dynamic or interactive websites\n\nProvide detailed task instructions, relevant context, and clearly specify the desired outcome for best results. Returns the completed result or an error message if issues arise.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "The task to perform inside the browser"
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                }
              },
              "additionalProperties": false,
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly"
            },
            "returnStepInfo": {
              "type": "boolean",
              "default": false,
              "description": "Whether to return step-by-step information about the task.Should be false by default. May contain excessive information, so we strongly recommend setting this to false."
            },
            "maxSteps": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "minimum": 1,
              "maximum": 100,
              "default": 25
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "search_with_bing",
        "description": "Search the web using Bing. This tool allows you to search the web using bing.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query to submit to Bing"
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                }
              },
              "additionalProperties": false,
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly"
            },
            "numResults": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "minimum": 1,
              "maximum": 50,
              "default": 10,
              "description": "Number of search results to return"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [
      {
        "uri": "hyperbrowser:///",
        "name": "Welcome to Hyperbrowser | Hyperbrowser",
        "description": "Hyperbrowser documentation provides an introduction to web scraping and automation using the Hyperbrowser tool.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///what-are-headless-browsers",
        "name": "What are Headless browsers ? | Hyperbrowser",
        "description": "The page explains headless browsers and their role in Hyperbrowser for web scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///get-started/quickstart/scraping",
        "name": "Scraping | Hyperbrowser",
        "description": "The \"Scraping\" page in Hyperbrowser details how to extract data from websites using the tool's functionalities.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///get-started/quickstart/crawling",
        "name": "Crawling | Hyperbrowser",
        "description": "The \"Crawling\" page of Hyperbrowser covers the tool's web scraping capabilities and how to implement them.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///get-started/quickstart",
        "name": "Quickstart | Hyperbrowser",
        "description": "Quickstart guide for Hyperbrowser provides initial setup and functionality instructions for effective web scraping and automation.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///get-started/quickstart/puppeteer",
        "name": "Puppeteer | Hyperbrowser",
        "description": "Puppeteer integration with Hyperbrowser enables web scraping and automation through headless browser control.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///get-started/quickstart/playwright",
        "name": "Playwright | Hyperbrowser",
        "description": "The page discusses using Playwright with Hyperbrowser for web scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///get-started/quickstart/selenium",
        "name": "Selenium | Hyperbrowser",
        "description": "Selenium integration with Hyperbrowser allows for enhanced web scraping and automation capabilities.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///sessions/overview",
        "name": "Overview | Hyperbrowser",
        "description": "Overview of Hyperbrowser, a tool for web scraping and automation, detailing its features and functionalities.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///sessions/overview/session-parameters",
        "name": "Session Parameters | Hyperbrowser",
        "description": "This page details session parameters for configuring Hyperbrowser's web scraping and automation features.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///sessions/advanced-privacy-and-anti-detection",
        "name": "Advanced Privacy & Anti-Detection | Hyperbrowser",
        "description": "This page discusses Hyperbrowser's advanced privacy features and anti-detection capabilities for web scraping and automation.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///sessions/profiles",
        "name": "Profiles | Hyperbrowser",
        "description": "The \"Profiles\" page in Hyperbrowser outlines how to manage user profiles for data scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///sessions/recordings",
        "name": "Recordings | Hyperbrowser",
        "description": "The page covers Hyperbrowser's recording feature for efficient web scraping and automation processes.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///sessions/live-view",
        "name": "Live View | Hyperbrowser",
        "description": "The Live View feature in Hyperbrowser allows real-time monitoring and interaction with web scraping tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///sessions/extensions",
        "name": "Extensions | Hyperbrowser",
        "description": "The page discusses extensions for Hyperbrowser, enhancing its web scraping and automation capabilities.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///web-scraping/scrape",
        "name": "Scrape | Hyperbrowser",
        "description": "\"Scrape\" page in Hyperbrowser documentation focuses on scraping data from web pages using the tool's features.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///web-scraping/crawl",
        "name": "Crawl | Hyperbrowser",
        "description": "The page discusses how to utilize Hyperbrowser for effective web crawling.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///web-scraping/extract",
        "name": "Extract | Hyperbrowser",
        "description": "The Extract page of Hyperbrowser provides guidelines for web scraping and data extraction techniques using the tool.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///agents/browser-use",
        "name": "Browser Use | Hyperbrowser",
        "description": "The page discusses using Hyperbrowser for web scraping and automation tasks via browser interactions.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///agents/claude-computer-use",
        "name": "Claude Computer Use | Hyperbrowser",
        "description": "The page provides guidelines on using Claude with Hyperbrowser for effective web scraping and automation.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///agents/openai-cua",
        "name": "OpenAI CUA | Hyperbrowser",
        "description": "The page discusses the integration of OpenAI's CUA with Hyperbrowser for enhanced web scraping and automation capabilities.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///guides/ai-function-calling",
        "name": "AI Function Calling | Hyperbrowser",
        "description": "The page discusses AI function calling features within Hyperbrowser for enhanced web scraping and automation.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///guides/scraping",
        "name": "Scraping | Hyperbrowser",
        "description": "The page covers web scraping techniques and documentation for using Hyperbrowser effectively.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///guides/extract-information-with-an-llm",
        "name": "Extract Information with an LLM | Hyperbrowser",
        "description": "Learn how to extract information using a Large Language Model with Hyperbrowser.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///guides/using-hyperbrowser-session",
        "name": "Using Hyperbrowser Session | Hyperbrowser",
        "description": "The page describes how to use sessions in Hyperbrowser for efficient web scraping and automation.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///guides/captcha-solving",
        "name": "CAPTCHA Solving | Hyperbrowser",
        "description": "Hyperbrowser provides tools and guidance for CAPTCHA solving in web scraping and automation processes.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///guides/model-context-protocol",
        "name": "Model Context Protocol | Hyperbrowser",
        "description": "The page covers the Model Context Protocol used in Hyperbrowser for web scraping and automation.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks",
        "name": "SDKs | Hyperbrowser",
        "description": "The page discusses Hyperbrowser SDKs for web scraping and automation, including features and usage details.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/node",
        "name": "Node | Hyperbrowser",
        "description": "Overview of the Node module in Hyperbrowser for web scraping and automation.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/node/sessions",
        "name": "Sessions | Hyperbrowser",
        "description": "The page discusses sessions in Hyperbrowser, detailing how to manage and utilize them effectively for web scraping tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/node/profiles",
        "name": "Profiles | Hyperbrowser",
        "description": "The \"Profiles\" page of Hyperbrowser covers user profiles and their management within the tool.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/node/scrape",
        "name": "Scrape | Hyperbrowser",
        "description": "The \"Scrape\" page of Hyperbrowser outlines techniques and tools for web scraping and automation.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/node/crawl",
        "name": "Crawl | Hyperbrowser",
        "description": "The \"Crawl\" page of Hyperbrowser details how to use the tool for web scraping and automated data extraction.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/node/extensions",
        "name": "Extensions | Hyperbrowser",
        "description": "The Extensions page for Hyperbrowser details available extensions that enhance web scraping and automation functionalities.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/python",
        "name": "Python | Hyperbrowser",
        "description": "The page provides documentation on using Hyperbrowser with Python for web scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/python/sessions",
        "name": "Sessions | Hyperbrowser",
        "description": "The page discusses managing sessions in Hyperbrowser for effective web scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/python/profiles",
        "name": "Profiles | Hyperbrowser",
        "description": "The \"Profiles\" page in Hyperbrowser documentation explains how to manage and use user profiles for web scraping tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/python/scrape",
        "name": "Scrape | Hyperbrowser",
        "description": "The page explains how to use Hyperbrowser for web scraping tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/python/crawl",
        "name": "Crawl | Hyperbrowser",
        "description": "The Crawl section of Hyperbrowser\u2019s documentation explains web scraping techniques and automation processes.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/sdks/python/extensions",
        "name": "Extensions | Hyperbrowser",
        "description": "Explore Hyperbrowser extensions for enhanced web scraping and automation capabilities in your projects.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference",
        "name": "API Reference | Hyperbrowser",
        "description": "API Reference for Hyperbrowser provides detailed information on using its web scraping and automation features.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/sessions",
        "name": "Sessions | Hyperbrowser",
        "description": "The \"Sessions\" page in Hyperbrowser covers managing and utilizing sessions for web scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/crawl",
        "name": "Crawl | Hyperbrowser",
        "description": "The \"Crawl\" section of Hyperbrowser documentation explains how to use the tool for web scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/scrape",
        "name": "Scrape | Hyperbrowser",
        "description": "The \"Scrape\" section of Hyperbrowser documentation explains web scraping techniques and automation features of the tool.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/extract",
        "name": "Extract | Hyperbrowser",
        "description": "The Extract page of Hyperbrowser provides guidelines on data extraction methods and tools for web scraping.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/agents",
        "name": "Agents | Hyperbrowser",
        "description": "The \"Agents\" page in Hyperbrowser documentation discusses automated entities for web scraping and task execution.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/agents/browser-use",
        "name": "Browser Use | Hyperbrowser",
        "description": "The page explains how to effectively utilize browser features in Hyperbrowser for web scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/agents/claude-computer-use",
        "name": "Claude Computer Use | Hyperbrowser",
        "description": "The page discusses using Claude for web scraping and automation with Hyperbrowser tools.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/agents/openai-cua",
        "name": "OpenAI CUA | Hyperbrowser",
        "description": "OpenAI CUA for Hyperbrowser details integration and automation features for effective web scraping.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/profiles",
        "name": "Profiles | Hyperbrowser",
        "description": "The \"Profiles\" page in Hyperbrowser documentation explains how to manage and configure user profiles for scraping tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///reference/api-reference/extensions",
        "name": "Extensions | Hyperbrowser",
        "description": "The page discusses extensions for Hyperbrowser that enhance its web scraping and automation capabilities.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///integrations/langchain",
        "name": "LangChain | Hyperbrowser",
        "description": "LangChain integrates with Hyperbrowser for enhanced web scraping and automation capabilities.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///integrations/llamaindex",
        "name": "LlamaIndex | Hyperbrowser",
        "description": "LlamaIndex documentation for integrating with Hyperbrowser for web scraping and automation tasks.",
        "mimeType": "text/markdown",
        "annotations": null
      },
      {
        "uri": "hyperbrowser:///~gitbook/pdf",
        "name": "Hyperbrowser",
        "description": "Hyperbrowser is a web scraping and automation tool, offering extensive documentation for users.",
        "mimeType": "text/markdown",
        "annotations": null
      }
    ],
    "is_official": true
  },
  "magic-mcp": {
    "display_name": "21st.dev Magic AI Agent",
    "repository": {
      "type": "git",
      "url": "https://github.com/21st-dev/magic-mcp"
    },
    "homepage": "https://21st.dev/magic",
    "author": {
      "name": "21st-dev"
    },
    "license": "MIT",
    "tags": [
      "ui",
      "components",
      "ai",
      "generator",
      "react"
    ],
    "arguments": {
      "API_KEY": {
        "description": "API key for authentication with Magic AI Agent",
        "required": true,
        "example": "your-api-key"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@21st-dev/magic@latest",
          "API_KEY=\"your-api-key\""
        ],
        "package": "@21st-dev/magic",
        "env": {
          "API_KEY": "your-api-key"
        },
        "description": "Install via npm package",
        "recommended": true
      },
      "cli": {
        "type": "cli",
        "command": "npx",
        "args": [
          "@21st-dev/cli@latest",
          "install",
          "<client>",
          "--api-key",
          "<key>"
        ],
        "description": "Install using the CLI tool",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Create a navigation bar",
        "description": "Generate a modern responsive navigation bar component",
        "prompt": "/ui create a modern navigation bar with responsive design"
      }
    ],
    "name": "magic-mcp",
    "description": "Magic Component Platform (MCP) is a powerful AI-driven tool that helps developers create beautiful, modern UI components instantly through natural language descriptions. It integrates seamlessly with popular IDEs and provides a streamlined workflow for UI development.",
    "categories": [
      "Dev Tools"
    ],
    "tools": [
      {
        "name": "21st_magic_component_builder",
        "description": "\n\"Use this tool when the user requests a new UI component\u2014e.g., mentions /ui, /21 /21st, or asks for a button, input, dialog, table, form, banner, card, or other React component.\nThis tool ONLY returns the text snippet for that UI component. \nAfter calling this tool, you must edit or add files to integrate the snippet into the codebase.\"\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "Full users message"
            },
            "searchQuery": {
              "type": "string",
              "description": "Generate a search query for 21st.dev (library for searching UI components) to find a UI component that matches the user's message. Must be a two-four words max or phrase"
            },
            "absolutePathToCurrentFile": {
              "type": "string",
              "description": "Absolute path to the current file to which we want to apply changes"
            },
            "absolutePathToProjectDirectory": {
              "type": "string",
              "description": "Absolute path to the project root directory"
            }
          },
          "required": [
            "message",
            "searchQuery",
            "absolutePathToCurrentFile",
            "absolutePathToProjectDirectory"
          ]
        }
      },
      {
        "name": "logo_search",
        "description": "\nSearch and return logos in specified format (JSX, TSX, SVG).\nSupports single and multiple logo searches with category filtering.\nCan return logos in different themes (light/dark) if available.\n\nWhen to use this tool:\n1. When user types \"/logo\" command (e.g., \"/logo GitHub\")\n2. When user asks to add a company logo that's not in the local project\n\nExample queries:\n- Single company: [\"discord\"]\n- Multiple companies: [\"discord\", \"github\", \"slack\"]\n- Specific brand: [\"microsoft office\"]\n- Command style: \"/logo GitHub\" -> [\"github\"]\n- Request style: \"Add Discord logo to the project\" -> [\"discord\"]\n\nFormat options:\n- TSX: Returns TypeScript React component\n- JSX: Returns JavaScript React component\n- SVG: Returns raw SVG markup\n\nEach result includes:\n- Component name (e.g., DiscordIcon)\n- Component code\n- Import instructions\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "queries": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of company names to search for logos"
            },
            "format": {
              "type": "string",
              "enum": [
                "JSX",
                "TSX",
                "SVG"
              ],
              "description": "Output format"
            }
          },
          "required": [
            "queries",
            "format"
          ]
        }
      },
      {
        "name": "21st_magic_component_inspiration",
        "description": "\n\"Use this tool when the user wants to see component, get inspiration, or /21st fetch data and previews from 21st.dev. This tool returns the JSON data of matching components without generating new code. This tool ONLY returns the text snippet for that UI component. \nAfter calling this tool, you must edit or add files to integrate the snippet into the codebase.\"\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "Full users message"
            },
            "searchQuery": {
              "type": "string",
              "description": "Search query for 21st.dev (library for searching UI components) to find a UI component that matches the user's message. Must be a two-four words max or phrase"
            }
          },
          "required": [
            "message",
            "searchQuery"
          ]
        }
      },
      {
        "name": "21st_magic_component_refiner",
        "description": "\n\"Use this tool when the user requests to refine/improve current UI component with /ui or /21 commands, \nor when context is about improving, or refining UI for a React component or molecule (NOT for big pages).\nThis tool improves UI of components and returns improved version of the component and instructions on how to implement it.\"\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "userMessage": {
              "type": "string",
              "description": "Full user's message about UI refinement"
            },
            "absolutePathToRefiningFile": {
              "type": "string",
              "description": "Absolute path to the file that needs to be refined"
            },
            "context": {
              "type": "string",
              "description": "Extract the specific UI elements and aspects that need improvement based on user messages, code, and conversation history. Identify exactly which components (buttons, forms, modals, etc.) the user is referring to and what aspects (styling, layout, responsiveness, etc.) they want to enhance. Do not include generic improvements - focus only on what the user explicitly mentions or what can be reasonably inferred from the available context. If nothing specific is mentioned or you cannot determine what needs improvement, return an empty string."
            }
          },
          "required": [
            "userMessage",
            "absolutePathToRefiningFile",
            "context"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "onchain-mcp": {
    "display_name": "Bankless Onchain MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/bankless/onchain-mcp"
    },
    "homepage": "https://docs.bankless.com/bankless-api/other-services/onchain-mcp",
    "author": {
      "name": "bankless"
    },
    "license": "MIT",
    "tags": [
      "blockchain",
      "MCP",
      "smart contracts",
      "ethereum",
      "onchain"
    ],
    "arguments": {
      "BANKLESS_API_TOKEN": {
        "description": "API token for Bankless API authentication",
        "required": true,
        "example": "your_api_token_here"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@bankless/onchain-mcp"
        ],
        "package": "@bankless/onchain-mcp",
        "env": {
          "BANKLESS_API_TOKEN": "your_api_token_here"
        },
        "description": "Run directly using npx",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Read Contract State",
        "description": "Read the balance of an address from a token contract",
        "prompt": "What's the balance of address 0xabcd... in the token contract at 0x1234...?"
      },
      {
        "title": "Get Proxy Implementation",
        "description": "Find the implementation address for a proxy contract",
        "prompt": "What's the implementation contract for the proxy at 0x1234...?"
      },
      {
        "title": "Fetch Event Logs",
        "description": "Get Transfer events for a specific token contract",
        "prompt": "Show me the recent Transfer events for the contract at 0x1234..."
      }
    ],
    "name": "onchain-mcp",
    "description": "MCP (Model Context Protocol) server for blockchain data interaction through the Bankless API.",
    "categories": [
      "Finance"
    ],
    "tools": [
      {
        "name": "read_contract",
        "description": "Read contract state from a blockchain. important:  \n                \n                In case of a tuple, don't use type tuple, but specify the inner types (found in the source) in order. For nested structs, include the substructs types.\n    \n    Example: \n    struct DataTypeA {\n    DataTypeB b;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    }\n    \n    struct DataTypeB {\n    address token;\n    }\n    \n    results in outputs for function with return type DataTypeA (tuple in abi): outputs: [{\"type\": \"address\"}, {\"type\": \"uint128\"}]",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "contract": {
              "type": "string",
              "description": "The contract address"
            },
            "method": {
              "type": "string",
              "description": "The contract method to call"
            },
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "description": "The type of the input parameter"
                  },
                  "value": {
                    "description": "The value of the input parameter"
                  }
                },
                "required": [
                  "type"
                ],
                "additionalProperties": false
              },
              "description": "Input parameters for the method call"
            },
            "outputs": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "description": "Expected output types for the method call. \n    In case of a tuple, don't use type tuple, but specify the inner types (found in the source) in order. For nested structs, include the substructs types.\n    \n    Example: \n    struct DataTypeA {\n    DataTypeB b;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    }\n    \n    struct DataTypeB {\n    address token;\n    }\n    \n    results in outputs for function with return type DataTypeA (tuple in abi): outputs: [{\"type\": \"address\"}, {\"type\": \"uint128\"}]\n  "
                  },
                  "components": {
                    "type": "array",
                    "items": {
                      "$ref": "#/properties/outputs/items"
                    },
                    "description": "optional components for tuple types"
                  }
                },
                "required": [
                  "type"
                ],
                "additionalProperties": false
              },
              "description": "Expected output types for the method call. \n    In case of a tuple, don't use type tuple, but specify the inner types (found in the source) in order. For nested structs, include the substructs types.\n    \n    Example: \n    struct DataTypeA {\n    DataTypeB b;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    }\n    \n    struct DataTypeB {\n    address token;\n    }\n    \n    results in outputs for function with return type DataTypeA (tuple in abi): outputs: [{\"type\": \"address\"}, {\"type\": \"uint128\"}]\n  "
            }
          },
          "required": [
            "network",
            "contract",
            "method",
            "inputs",
            "outputs"
          ]
        }
      },
      {
        "name": "get_proxy",
        "description": "Gets the proxy address for a given network and contract",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "contract": {
              "type": "string",
              "description": "The contract address to request the proxy implementation contract for"
            }
          },
          "required": [
            "network",
            "contract"
          ]
        }
      },
      {
        "name": "get_abi",
        "description": "Gets the ABI for a given contract on a specific network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "contract": {
              "type": "string",
              "description": "The contract address"
            }
          },
          "required": [
            "network",
            "contract"
          ]
        }
      },
      {
        "name": "get_source",
        "description": "Gets the source code for a given contract on a specific network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "contract": {
              "type": "string",
              "description": "The contract address"
            }
          },
          "required": [
            "network",
            "contract"
          ]
        }
      },
      {
        "name": "get_events",
        "description": "Fetches event logs for a given network and filter criteria",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "addresses": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of contract addresses to filter events"
            },
            "topic": {
              "type": "string",
              "description": "Primary topic to filter events"
            },
            "optionalTopics": {
              "type": "array",
              "items": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "description": "Optional additional topics"
            },
            "fromBlock": {
              "type": "number",
              "description": "Block number to start fetching logs from"
            },
            "toBlock": {
              "type": "number",
              "description": "Block number to stop fetching logs at"
            }
          },
          "required": [
            "network",
            "addresses",
            "topic"
          ]
        }
      },
      {
        "name": "build_event_topic",
        "description": "Builds an event topic signature based on event name and arguments",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "name": {
              "type": "string",
              "description": "Event name (e.g., \"Transfer(address,address,uint256)\")"
            },
            "arguments": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "description": "Expected output types for the method call. \n    In case of a tuple, don't use type tuple, but specify the inner types (found in the source) in order. For nested structs, include the substructs types.\n    \n    Example: \n    struct DataTypeA {\n    DataTypeB b;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    }\n    \n    struct DataTypeB {\n    address token;\n    }\n    \n    results in outputs for function with return type DataTypeA (tuple in abi): outputs: [{\"type\": \"address\"}, {\"type\": \"uint128\"}]\n  "
                  },
                  "components": {
                    "type": "array",
                    "items": {
                      "$ref": "#/properties/arguments/items"
                    },
                    "description": "optional components for tuple types"
                  }
                },
                "required": [
                  "type"
                ],
                "additionalProperties": false
              },
              "description": "Event arguments types"
            }
          },
          "required": [
            "network",
            "name",
            "arguments"
          ]
        }
      },
      {
        "name": "get_transaction_history_for_user",
        "description": "Gets transaction history for a user and optional contract",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "user": {
              "type": "string",
              "description": "The user address"
            },
            "contract": {
              "type": [
                "string",
                "null"
              ],
              "description": "The contract address (optional)"
            },
            "methodId": {
              "type": [
                "string",
                "null"
              ],
              "description": "The method ID to filter by (optional)"
            },
            "startBlock": {
              "type": [
                "string",
                "null"
              ],
              "description": "The starting block number (optional)"
            },
            "includeData": {
              "type": "boolean",
              "default": true,
              "description": "Whether to include transaction data"
            }
          },
          "required": [
            "network",
            "user"
          ]
        }
      },
      {
        "name": "get_transaction_info",
        "description": "Gets detailed information about a specific transaction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"polygon\")"
            },
            "txHash": {
              "type": "string",
              "description": "The transaction hash to fetch details for"
            }
          },
          "required": [
            "network",
            "txHash"
          ]
        }
      },
      {
        "name": "get_token_balances_on_network",
        "description": "Gets all token balances for a given address on a specific network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "address": {
              "type": "string",
              "description": "The address to check token balances for"
            }
          },
          "required": [
            "network",
            "address"
          ]
        }
      },
      {
        "name": "get_block_info",
        "description": "Gets detailed information about a specific block by number or hash",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "The blockchain network (e.g., \"ethereum\", \"base\")"
            },
            "blockId": {
              "type": "string",
              "description": "The block number or block hash to fetch information for"
            }
          },
          "required": [
            "network",
            "blockId"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "lightdash": {
    "name": "lightdash",
    "display_name": "Lightdash",
    "description": "Interact with [Lightdash](https://www.lightdash.com/), a BI tool.",
    "repository": {
      "type": "git",
      "url": "https://github.com/syucream/lightdash-mcp-server"
    },
    "homepage": "https://github.com/syucream/lightdash-mcp-server",
    "author": {
      "name": "syucream"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Lightdash",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "lightdash-mcp-server"
        ],
        "env": {
          "LIGHTDASH_API_KEY": "${LIGHTDASH_API_KEY}",
          "LIGHTDASH_API_URL": "${LIGHTDASH_API_URL}"
        }
      }
    },
    "arguments": {
      "LIGHTDASH_API_KEY": {
        "description": "Your Lightdash PAT (Personal Access Token) required for authenticating API requests.",
        "required": true,
        "example": "your_personal_access_token_here"
      },
      "LIGHTDASH_API_URL": {
        "description": "The base URL for the Lightdash API that you are connecting to.",
        "required": true,
        "example": "https://your.base.url"
      }
    },
    "tools": [
      {
        "name": "lightdash_list_projects",
        "description": "List all projects in the Lightdash organization",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "lightdash_get_project",
        "description": "Get details of a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_list_spaces",
        "description": "List all spaces in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_list_charts",
        "description": "List all charts in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_list_dashboards",
        "description": "List all dashboards in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_custom_metrics",
        "description": "Get custom metrics for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_catalog",
        "description": "Get catalog for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_metrics_catalog",
        "description": "Get metrics catalog for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_charts_as_code",
        "description": "Get charts as code for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_dashboards_as_code",
        "description": "Get dashboards as code for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_metadata",
        "description": "Get metadata for a specific table in the data catalog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            },
            "table": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "projectUuid",
            "table"
          ]
        }
      },
      {
        "name": "lightdash_get_analytics",
        "description": "Get analytics for a specific table in the data catalog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            },
            "table": {
              "type": "string"
            }
          },
          "required": [
            "projectUuid",
            "table"
          ]
        }
      },
      {
        "name": "lightdash_get_user_attributes",
        "description": "Get organization user attributes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "goodnews": {
    "name": "goodnews",
    "display_name": "Goodnews",
    "description": "A simple MCP server that delivers curated positive and uplifting news stories.",
    "repository": {
      "type": "git",
      "url": "https://github.com/VectorInstitute/mcp-goodnews"
    },
    "homepage": "https://github.com/VectorInstitute/mcp-goodnews",
    "author": {
      "name": "VectorInstitute"
    },
    "license": "Apache 2.0",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "positive news",
      "uplifting",
      "Cohere",
      "NewsAPI"
    ],
    "examples": [
      {
        "title": "Fetch list of good news",
        "description": "Retrieve uplifting news articles using MCP Goodnews.",
        "prompt": "Show me some good news from today."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/VectorInstitute/mcp-goodnews",
          "server.py"
        ],
        "env": {
          "NEWS_API_KEY": "<newsapi-api-key>",
          "COHERE_API_KEY": "<cohere-api-key>"
        }
      }
    },
    "arguments": {
      "NEWS_API_KEY": {
        "description": "API key for NewsAPI to fetch news articles",
        "required": true,
        "example": "your_newsapi_key_here"
      },
      "COHERE_API_KEY": {
        "description": "API key for Cohere to analyze sentiment of news articles",
        "required": true,
        "example": "your_cohere_api_key_here"
      }
    }
  },
  "oxylabs-mcp": {
    "display_name": "Oxylabs Scraper",
    "repository": {
      "type": "git",
      "url": "https://github.com/oxylabs/oxylabs-mcp"
    },
    "homepage": "https://github.com/oxylabs/oxylabs-mcp",
    "author": {
      "name": "oxylabs"
    },
    "license": "MIT",
    "tags": [
      "web scraping",
      "data extraction",
      "web unblocker"
    ],
    "arguments": {
      "url": {
        "description": "The URL to scrape",
        "required": true,
        "example": "https://www.google.com/search?q=ai"
      },
      "parse": {
        "description": "Enable structured data extraction",
        "required": false,
        "example": "True"
      },
      "render": {
        "description": "Use headless browser rendering",
        "required": false,
        "example": "html"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "oxylabs-mcp"
        ],
        "env": {
          "OXYLABS_USERNAME": "YOUR_USERNAME_HERE",
          "OXYLABS_PASSWORD": "YOUR_PASSWORD_HERE"
        },
        "description": "Install using uv in Claude Desktop"
      }
    },
    "examples": [
      {
        "title": "Basic Google Search",
        "description": "Scrape a Google search results page",
        "prompt": "Could you scrape https://www.google.com/search?q=ai page?"
      },
      {
        "title": "Amazon Product with Parse",
        "description": "Scrape an Amazon product page with parsing enabled",
        "prompt": "Scrape https://www.amazon.de/-/en/Smartphone-Contract-Function-Manufacturer-Exclusive/dp/B0CNKD651V with parse enabled"
      },
      {
        "title": "Amazon Bestsellers with Parse and Render",
        "description": "Scrape an Amazon bestsellers page with parsing and rendering enabled",
        "prompt": "Scrape https://www.amazon.de/-/en/gp/bestsellers/beauty/ref=zg_bs_nav_beauty_0 with parse and render enabled"
      },
      {
        "title": "Best Buy with Web Unblocker",
        "description": "Use web unblocker with rendering to scrape a Best Buy page",
        "prompt": "Use web unblocker with render to scrape https://www.bestbuy.com/site/top-deals/all-electronics-on-sale/pcmcat1674241939957.c"
      }
    ],
    "name": "oxylabs-mcp",
    "description": "A Model Context Protocol (MCP) server that enables AI assistants like Claude to seamlessly access web data through Oxylabs' powerful web scraping technology.",
    "categories": [
      "Web Services"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "oxylabs_scraper",
        "description": "Scrape url using Oxylabs Web Api",
        "inputSchema": {
          "properties": {
            "url": {
              "description": "Url to scrape",
              "title": "Url",
              "type": "string"
            },
            "parse": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Should result be parsed. If result should not be parsed then html will be stripped and converted to markdown file",
              "title": "Parse"
            },
            "render": {
              "anyOf": [
                {
                  "enum": [
                    "html",
                    "None"
                  ],
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Whether a headless browser should be used to render the page. See: https://developers.oxylabs.io/scraper-apis/web-scraper-api/features/javascript-rendering `html` will return rendered html page `None` will not use render for scraping.",
              "title": "Render"
            }
          },
          "required": [
            "url"
          ],
          "title": "scrape_urlArguments",
          "type": "object"
        }
      },
      {
        "name": "oxylabs_web_unblocker",
        "description": "Scrape url using Oxylabs Web Unblocker",
        "inputSchema": {
          "properties": {
            "url": {
              "description": "Url to scrape with web unblocker",
              "title": "Url",
              "type": "string"
            },
            "render": {
              "anyOf": [
                {
                  "enum": [
                    "html",
                    "None"
                  ],
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Whether a headless browser should be used to render the page. See: https://developers.oxylabs.io/advanced-proxy-solutions/web-unblocker/headless-browser/javascript-rendering `html` will return rendered html page `None` will not use render for scraping.",
              "title": "Render"
            }
          },
          "required": [
            "url"
          ],
          "title": "scrape_with_web_unblockerArguments",
          "type": "object"
        }
      }
    ]
  },
  "postman": {
    "name": "postman",
    "display_name": "Postman",
    "description": "MCP server for running Postman Collections locally via Newman. Allows for simple execution of Postman Server and returns the results of whether the collection passed all the tests.",
    "repository": {
      "type": "git",
      "url": "https://github.com/shannonlal/mcp-postman"
    },
    "homepage": "https://github.com/shannonlal/mcp-postman",
    "author": {
      "name": "shannonlal"
    },
    "license": "ISC",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Postman",
      "Newman",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/shannonlal/mcp-postman"
        ]
      }
    },
    "tools": [
      {
        "name": "run-collection",
        "description": "Run a Postman Collection using Newman",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Path or URL to the Postman collection"
            },
            "environment": {
              "type": "string",
              "description": "Optional path or URL to environment file"
            },
            "globals": {
              "type": "string",
              "description": "Optional path or URL to globals file"
            },
            "iterationCount": {
              "type": "number",
              "description": "Optional number of iterations to run"
            }
          },
          "required": [
            "collection"
          ]
        }
      }
    ]
  },
  "reaper": {
    "name": "reaper",
    "display_name": "Reaper",
    "description": "Interact with your [Reaper](https://www.reaper.fm/) (Digital Audio Workstation) projects.",
    "repository": {
      "type": "git",
      "url": "https://github.com/dschuler36/reaper-mcp-server"
    },
    "homepage": "https://github.com/dschuler36/reaper-mcp-server",
    "author": {
      "name": "dschuler36"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Reaper",
      "Claude"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/dschuler36/reaper-mcp-server",
          "reaper-mcp-server",
          "--reaper-projects-dir",
          "${REAPER_PROJECTS_DIR}"
        ]
      }
    },
    "examples": [
      {
        "title": "Ask about a Reaper project",
        "description": "Request information about a specific Reaper project you have.",
        "prompt": "What are the tracks in my 'Project A' Reaper file?"
      },
      {
        "title": "Find Reaper projects",
        "description": "Use the tool to locate all Reaper projects in the configured directory.",
        "prompt": "Find all my Reaper projects."
      }
    ],
    "arguments": {
      "REAPER_PROJECTS_DIR": {
        "description": "The directory where Reaper projects are stored, allowing the MCP server to find and interact with them.",
        "required": true,
        "example": "/path/to/reaper/projects"
      }
    }
  },
  "hyperliquid": {
    "name": "hyperliquid",
    "display_name": "Hyperliquid",
    "description": "An MCP server implementation that integrates the Hyperliquid SDK for exchange data.",
    "repository": {
      "type": "git",
      "url": "https://github.com/mektigboy/server-hyperliquid"
    },
    "license": "MIT",
    "author": {
      "name": "mektigboy"
    },
    "homepage": "https://github.com/mektigboy/server-hyperliquid",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Hyperliquid",
      "Exchange"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@mektigboy/server-hyperliquid"
        ]
      }
    },
    "tools": [
      {
        "name": "get_all_mids",
        "description": "Get mid prices for all coins on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_candle_snapshot",
        "description": "Get candlestick data for a token on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {
            "coin": {
              "type": "string",
              "description": "The symbol of the token to get candlestick data for"
            },
            "interval": {
              "type": "string",
              "description": "Time interval (e.g., '15m', '1h')"
            },
            "startTime": {
              "type": "number",
              "description": "Start time in milliseconds since epoch"
            },
            "endTime": {
              "type": "number",
              "description": "End time in milliseconds since epoch (optional)"
            }
          },
          "required": [
            "coin",
            "interval",
            "startTime"
          ]
        }
      },
      {
        "name": "get_l2_book",
        "description": "Get the L2 book of a token on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "The symbol of the token to get the price of"
            },
            "required": [
              "symbol"
            ]
          }
        }
      }
    ]
  },
  "evm-mcp-server": {
    "name": "evm-mcp-server",
    "display_name": "EVM Server",
    "description": "Comprehensive blockchain services for 30+ EVM networks, supporting native tokens, ERC20, NFTs, smart contracts, transactions, and ENS resolution.",
    "repository": {
      "type": "git",
      "url": "https://github.com/mcpdotdirect/evm-mcp-server"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Ethereum",
      "Smart Contracts",
      "AI",
      "Token Transfers",
      "NFTs"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@mcpdotdirect/evm-mcp-server"
        ]
      }
    },
    "author": {
      "name": "mcpdotdirect"
    },
    "homepage": "https://github.com/mcpdotdirect/evm-mcp-server",
    "tools": [
      {
        "name": "get_chain_info",
        "description": "Get information about an EVM network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          }
        }
      },
      {
        "name": "resolve_ens",
        "description": "Resolve an ENS name to an Ethereum address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ensName": {
              "type": "string",
              "description": "ENS name to resolve (e.g., 'vitalik.eth')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. ENS resolution works best on Ethereum mainnet. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "ensName"
          ]
        }
      },
      {
        "name": "get_supported_networks",
        "description": "Get a list of supported EVM networks",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_block_by_number",
        "description": "Get a block by its block number",
        "inputSchema": {
          "type": "object",
          "properties": {
            "blockNumber": {
              "type": "number",
              "description": "The block number to fetch"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "blockNumber"
          ]
        }
      },
      {
        "name": "get_latest_block",
        "description": "Get the latest block from the EVM",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          }
        }
      },
      {
        "name": "get_balance",
        "description": "Get the native token balance (ETH, MATIC, etc.) for an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The wallet address or ENS name (e.g., '0x1234...' or 'vitalik.eth') to check the balance for"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_erc20_balance",
        "description": "Get the ERC20 token balance of an Ethereum address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The Ethereum address to check"
            },
            "tokenAddress": {
              "type": "string",
              "description": "The ERC20 token contract address"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "address",
            "tokenAddress"
          ]
        }
      },
      {
        "name": "get_token_balance",
        "description": "Get the balance of an ERC20 token for an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address or ENS name of the ERC20 token (e.g., '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' for USDC or 'uniswap.eth')"
            },
            "ownerAddress": {
              "type": "string",
              "description": "The wallet address or ENS name to check the balance for (e.g., '0x1234...' or 'vitalik.eth')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_transaction",
        "description": "Get detailed information about a specific transaction by its hash. Includes sender, recipient, value, data, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txHash": {
              "type": "string",
              "description": "The transaction hash to look up (e.g., '0x1234...')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "txHash"
          ]
        }
      },
      {
        "name": "get_transaction_receipt",
        "description": "Get a transaction receipt by its hash",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txHash": {
              "type": "string",
              "description": "The transaction hash to look up"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "txHash"
          ]
        }
      },
      {
        "name": "estimate_gas",
        "description": "Estimate the gas cost for a transaction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "description": "The recipient address"
            },
            "value": {
              "type": "string",
              "description": "The amount of ETH to send in ether (e.g., '0.1')"
            },
            "data": {
              "type": "string",
              "description": "The transaction data as a hex string"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "to"
          ]
        }
      },
      {
        "name": "transfer_eth",
        "description": "Transfer native tokens (ETH, MATIC, etc.) to an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the sender account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "to": {
              "type": "string",
              "description": "The recipient address or ENS name (e.g., '0x1234...' or 'vitalik.eth')"
            },
            "amount": {
              "type": "string",
              "description": "Amount to send in ETH (or the native token of the network), as a string (e.g., '0.1')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "to",
            "amount"
          ]
        }
      },
      {
        "name": "transfer_erc20",
        "description": "Transfer ERC20 tokens to another address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the sending account (this is used for signing and is never stored)"
            },
            "tokenAddress": {
              "type": "string",
              "description": "The address of the ERC20 token contract"
            },
            "toAddress": {
              "type": "string",
              "description": "The recipient address"
            },
            "amount": {
              "type": "string",
              "description": "The amount of tokens to send (in token units, e.g., '10' for 10 tokens)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "toAddress",
            "amount"
          ]
        }
      },
      {
        "name": "approve_token_spending",
        "description": "Approve another address (like a DeFi protocol or exchange) to spend your ERC20 tokens. This is often required before interacting with DeFi protocols.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the token owner account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC20 token to approve for spending (e.g., '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' for USDC on Ethereum)"
            },
            "spenderAddress": {
              "type": "string",
              "description": "The contract address being approved to spend your tokens (e.g., a DEX or lending protocol)"
            },
            "amount": {
              "type": "string",
              "description": "The amount of tokens to approve in token units, not wei (e.g., '1000' to approve spending 1000 tokens). Use a very large number for unlimited approval."
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "spenderAddress",
            "amount"
          ]
        }
      },
      {
        "name": "transfer_nft",
        "description": "Transfer an NFT (ERC721 token) from one address to another. Requires the private key of the current owner for signing the transaction.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the NFT owner account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the NFT collection (e.g., '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D' for Bored Ape Yacht Club)"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific NFT to transfer (e.g., '1234')"
            },
            "toAddress": {
              "type": "string",
              "description": "The recipient wallet address that will receive the NFT"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Most NFTs are on Ethereum mainnet, which is the default."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "tokenId",
            "toAddress"
          ]
        }
      },
      {
        "name": "transfer_erc1155",
        "description": "Transfer ERC1155 tokens to another address. ERC1155 is a multi-token standard that can represent both fungible and non-fungible tokens in a single contract.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the token owner account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC1155 token collection (e.g., '0x76BE3b62873462d2142405439777e971754E8E77')"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific token to transfer (e.g., '1234')"
            },
            "amount": {
              "type": "string",
              "description": "The quantity of tokens to send (e.g., '1' for a single NFT or '10' for 10 fungible tokens)"
            },
            "toAddress": {
              "type": "string",
              "description": "The recipient wallet address that will receive the tokens"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. ERC1155 tokens exist across many networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "tokenId",
            "amount",
            "toAddress"
          ]
        }
      },
      {
        "name": "transfer_token",
        "description": "Transfer ERC20 tokens to an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the sender account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "tokenAddress": {
              "type": "string",
              "description": "The contract address or ENS name of the ERC20 token to transfer (e.g., '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' for USDC or 'uniswap.eth')"
            },
            "toAddress": {
              "type": "string",
              "description": "The recipient address or ENS name that will receive the tokens (e.g., '0x1234...' or 'vitalik.eth')"
            },
            "amount": {
              "type": "string",
              "description": "Amount of tokens to send as a string (e.g., '100' for 100 tokens). This will be adjusted for the token's decimals."
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "toAddress",
            "amount"
          ]
        }
      },
      {
        "name": "read_contract",
        "description": "Read data from a smart contract by calling a view/pure function. This doesn't modify blockchain state and doesn't require gas or signing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contractAddress": {
              "type": "string",
              "description": "The address of the smart contract to interact with"
            },
            "abi": {
              "type": "array",
              "description": "The ABI (Application Binary Interface) of the smart contract function, as a JSON array"
            },
            "functionName": {
              "type": "string",
              "description": "The name of the function to call on the contract (e.g., 'balanceOf')"
            },
            "args": {
              "type": "array",
              "description": "The arguments to pass to the function, as an array (e.g., ['0x1234...'])"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "contractAddress",
            "abi",
            "functionName"
          ]
        }
      },
      {
        "name": "write_contract",
        "description": "Write data to a smart contract by calling a state-changing function. This modifies blockchain state and requires gas payment and transaction signing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contractAddress": {
              "type": "string",
              "description": "The address of the smart contract to interact with"
            },
            "abi": {
              "type": "array",
              "description": "The ABI (Application Binary Interface) of the smart contract function, as a JSON array"
            },
            "functionName": {
              "type": "string",
              "description": "The name of the function to call on the contract (e.g., 'transfer')"
            },
            "args": {
              "type": "array",
              "description": "The arguments to pass to the function, as an array (e.g., ['0x1234...', '1000000000000000000'])"
            },
            "privateKey": {
              "type": "string",
              "description": "Private key of the sending account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "contractAddress",
            "abi",
            "functionName",
            "args",
            "privateKey"
          ]
        }
      },
      {
        "name": "is_contract",
        "description": "Check if an address is a smart contract or an externally owned account (EOA)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The wallet or contract address or ENS name to check (e.g., '0x1234...' or 'uniswap.eth')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_token_info",
        "description": "Get comprehensive information about an ERC20 token including name, symbol, decimals, total supply, and other metadata. Use this to analyze any token on EVM chains.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC20 token (e.g., '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' for USDC on Ethereum)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress"
          ]
        }
      },
      {
        "name": "get_token_balance_erc20",
        "description": "Get ERC20 token balance for an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The address to check balance for"
            },
            "tokenAddress": {
              "type": "string",
              "description": "The ERC20 token contract address"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "address",
            "tokenAddress"
          ]
        }
      },
      {
        "name": "get_nft_info",
        "description": "Get detailed information about a specific NFT (ERC721 token), including collection name, symbol, token URI, and current owner if available.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the NFT collection (e.g., '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D' for Bored Ape Yacht Club)"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific NFT token to query (e.g., '1234')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Most NFTs are on Ethereum mainnet, which is the default."
            }
          },
          "required": [
            "tokenAddress",
            "tokenId"
          ]
        }
      },
      {
        "name": "check_nft_ownership",
        "description": "Check if an address owns a specific NFT",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address or ENS name of the NFT collection (e.g., '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D' for BAYC or 'boredapeyachtclub.eth')"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the NFT to check (e.g., '1234')"
            },
            "ownerAddress": {
              "type": "string",
              "description": "The wallet address or ENS name to check ownership against (e.g., '0x1234...' or 'vitalik.eth')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress",
            "tokenId",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_erc1155_token_uri",
        "description": "Get the metadata URI for an ERC1155 token (multi-token standard used for both fungible and non-fungible tokens). The URI typically points to JSON metadata about the token.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC1155 token collection (e.g., '0x76BE3b62873462d2142405439777e971754E8E77')"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific token to query metadata for (e.g., '1234')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. ERC1155 tokens exist across many networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress",
            "tokenId"
          ]
        }
      },
      {
        "name": "get_nft_balance",
        "description": "Get the total number of NFTs owned by an address from a specific collection. This returns the count of NFTs, not individual token IDs.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the NFT collection (e.g., '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D' for Bored Ape Yacht Club)"
            },
            "ownerAddress": {
              "type": "string",
              "description": "The wallet address to check the NFT balance for (e.g., '0x1234...')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Most NFTs are on Ethereum mainnet, which is the default."
            }
          },
          "required": [
            "tokenAddress",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_erc1155_balance",
        "description": "Get the balance of a specific ERC1155 token ID owned by an address. ERC1155 allows multiple tokens of the same ID, so the balance can be greater than 1.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC1155 token collection (e.g., '0x76BE3b62873462d2142405439777e971754E8E77')"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific token to check the balance for (e.g., '1234')"
            },
            "ownerAddress": {
              "type": "string",
              "description": "The wallet address to check the token balance for (e.g., '0x1234...')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. ERC1155 tokens exist across many networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress",
            "tokenId",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_address_from_private_key",
        "description": "Get the EVM address derived from a private key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key in hex format (with or without 0x prefix). SECURITY: This is used only for address derivation and is not stored."
            }
          },
          "required": [
            "privateKey"
          ]
        }
      }
    ]
  },
  "neovim": {
    "name": "neovim",
    "display_name": "Neovim Server",
    "description": "An MCP Server for your Neovim session.",
    "repository": {
      "type": "git",
      "url": "https://github.com/bigcodegen/mcp-neovim-server"
    },
    "homepage": "https://github.com/bigcodegen/mcp-neovim-server",
    "author": {
      "name": "bigcodegen"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Neovim",
      "MCP",
      "Claude Desktop"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-neovim-server"
        ],
        "env": {
          "ALLOW_SHELL_COMMANDS": "${ALLOW_SHELL_COMMANDS}",
          "NVIM_SOCKET_PATH": "${NVIM_SOCKET_PATH}"
        }
      }
    },
    "arguments": {
      "ALLOW_SHELL_COMMANDS": {
        "description": "Set to 'true' to enable shell command execution (e.g. `!ls`).",
        "required": false,
        "example": "true"
      },
      "NVIM_SOCKET_PATH": {
        "description": "Set to the path of your Neovim socket.",
        "required": false,
        "example": "/tmp/nvim"
      }
    },
    "tools": [
      {
        "name": "vim_buffer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filename": {
              "type": "string",
              "description": "Optional file name to view a specific buffer"
            }
          }
        }
      },
      {
        "name": "vim_command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "Vim command to execute (use ! prefix for shell commands if enabled)"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "vim_status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filename": {
              "type": "string",
              "description": "Optional file name to get status for a specific buffer"
            }
          }
        }
      },
      {
        "name": "vim_edit",
        "inputSchema": {
          "type": "object",
          "properties": {
            "startLine": {
              "type": "number",
              "description": "The line number where editing should begin (1-indexed)"
            },
            "mode": {
              "type": "string",
              "enum": [
                "insert",
                "replace",
                "replaceAll"
              ],
              "description": "Whether to insert new content, replace existing content, or replace entire buffer"
            },
            "lines": {
              "type": "string",
              "description": "The text content to insert or use as replacement"
            }
          },
          "required": [
            "startLine",
            "mode",
            "lines"
          ]
        }
      },
      {
        "name": "vim_window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "enum": [
                "split",
                "vsplit",
                "only",
                "close",
                "wincmd h",
                "wincmd j",
                "wincmd k",
                "wincmd l"
              ],
              "description": "Window manipulation command: split or vsplit to create new window, only to keep just current window, close to close current window, or wincmd with h/j/k/l to navigate between windows"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "vim_mark",
        "inputSchema": {
          "type": "object",
          "properties": {
            "mark": {
              "type": "string",
              "pattern": "^[a-z]$",
              "description": "Single lowercase letter [a-z] to use as the mark name"
            },
            "line": {
              "type": "number",
              "description": "The line number where the mark should be placed (1-indexed)"
            },
            "column": {
              "type": "number",
              "description": "The column number where the mark should be placed (0-indexed)"
            }
          },
          "required": [
            "mark",
            "line",
            "column"
          ]
        }
      },
      {
        "name": "vim_register",
        "inputSchema": {
          "type": "object",
          "properties": {
            "register": {
              "type": "string",
              "pattern": "^[a-z\\\"]$",
              "description": "Register name - a lowercase letter [a-z] or double-quote [\"] for the unnamed register"
            },
            "content": {
              "type": "string",
              "description": "The text content to store in the specified register"
            }
          },
          "required": [
            "register",
            "content"
          ]
        }
      },
      {
        "name": "vim_visual",
        "inputSchema": {
          "type": "object",
          "properties": {
            "startLine": {
              "type": "number",
              "description": "The starting line number for visual selection (1-indexed)"
            },
            "startColumn": {
              "type": "number",
              "description": "The starting column number for visual selection (0-indexed)"
            },
            "endLine": {
              "type": "number",
              "description": "The ending line number for visual selection (1-indexed)"
            },
            "endColumn": {
              "type": "number",
              "description": "The ending column number for visual selection (0-indexed)"
            }
          },
          "required": [
            "startLine",
            "startColumn",
            "endLine",
            "endColumn"
          ]
        }
      }
    ]
  },
  "aws-resources-operations": {
    "name": "aws-resources-operations",
    "display_name": "AWS Resources",
    "description": "Run generated python code to securely query or modify any AWS resources supported by boto3.",
    "repository": {
      "type": "git",
      "url": "https://github.com/baryhuang/mcp-server-aws-resources-python"
    },
    "homepage": "https://github.com/baryhuang/mcp-server-aws-resources-python",
    "author": {
      "name": "baryhuang"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "AWS",
      "Docker",
      "boto3"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}",
          "-e",
          "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}",
          "-e",
          "AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION}",
          "buryhuang/mcp-server-aws-resources:latest"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_DEFAULT_REGION": "${AWS_DEFAULT_REGION}"
        }
      }
    },
    "arguments": {
      "AWS_ACCESS_KEY_ID": {
        "description": "Your AWS access key.",
        "required": true,
        "example": "your_access_key_id_here"
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "Your AWS secret key.",
        "required": true,
        "example": "your_secret_access_key_here"
      },
      "AWS_DEFAULT_REGION": {
        "description": "AWS region to operate in. Defaults to 'us-east-1' if not set.",
        "required": false,
        "example": "us-east-1"
      }
    },
    "tools": [
      {
        "name": "query_aws_resources",
        "description": "Execute a boto3 code snippet to query AWS resources",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code_snippet": {
              "type": "string",
              "description": "Python code using boto3 to query AWS resources. The code should have default execution setting variable named 'result'. Example code: 'result = boto3.client('s3').list_buckets()'"
            }
          },
          "required": [
            "code_snippet"
          ]
        }
      }
    ]
  },
  "filesystem": {
    "name": "filesystem",
    "display_name": "Filesystem",
    "description": "Secure file operations with configurable access controls",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/filesystem",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Node.js",
      "server",
      "filesystem",
      "operations"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-filesystem",
          "${USER_FILESYSTEM_DIRECTORY}",
          "${USER_FILESYSTEM_ALLOWED_DIR}"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "--mount",
          "type=bind,src=${USER_FILESYSTEM_DIRECTORY},dst=/projects/Desktop",
          "--mount",
          "type=bind,src=${USER_FILESYSTEM_ALLOWED_DIR},dst=/projects/other/allowed/dir,ro",
          "--mount",
          "type=bind,src=${USER_FILESYSTEM_ALLOWED_FILE},dst=/projects/path/to/file.txt",
          "mcp/filesystem",
          "/projects"
        ]
      }
    },
    "arguments": {
      "USER_FILESYSTEM_DIRECTORY": {
        "description": "The directory to be mounted in the container",
        "required": true,
        "example": "/Users/username/Desktop"
      },
      "USER_FILESYSTEM_ALLOWED_DIR": {
        "description": "The directory to be mounted in the container",
        "required": true,
        "example": "/Users/username/Desktop"
      }
    },
    "tools": [
      {
        "name": "read_file",
        "description": "Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "read_multiple_files",
        "description": "Read the contents of multiple files simultaneously. This is more efficient than reading files one by one when you need to analyze or compare multiple files. Each file's content is returned with its path as a reference. Failed reads for individual files won't stop the entire operation. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "paths"
          ]
        }
      },
      {
        "name": "write_file",
        "description": "Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "content": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "content"
          ]
        }
      },
      {
        "name": "edit_file",
        "description": "Make line-based edits to a text file. Each edit replaces exact line sequences with new content. Returns a git-style diff showing the changes made. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "edits": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "oldText": {
                    "type": "string",
                    "description": "Text to search for - must match exactly"
                  },
                  "newText": {
                    "type": "string",
                    "description": "Text to replace with"
                  }
                },
                "required": [
                  "oldText",
                  "newText"
                ],
                "additionalProperties": false
              }
            },
            "dryRun": {
              "type": "boolean",
              "default": false,
              "description": "Preview changes using git-style diff format"
            }
          },
          "required": [
            "path",
            "edits"
          ]
        }
      },
      {
        "name": "create_directory",
        "description": "Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. If the directory already exists, this operation will succeed silently. Perfect for setting up directory structures for projects or ensuring required paths exist. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list_directory",
        "description": "Get a detailed listing of all files and directories in a specified path. Results clearly distinguish between files and directories with [FILE] and [DIR] prefixes. This tool is essential for understanding directory structure and finding specific files within a directory. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "directory_tree",
        "description": "Get a recursive tree view of files and directories as a JSON structure. Each entry includes 'name', 'type' (file/directory), and 'children' for directories. Files have no children array, while directories always have a children array (which may be empty). The output is formatted with 2-space indentation for readability. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "move_file",
        "description": "Move or rename files and directories. Can move files between directories and rename them in a single operation. If the destination exists, the operation will fail. Works across different directories and can be used for simple renaming within the same directory. Both source and destination must be within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "source": {
              "type": "string"
            },
            "destination": {
              "type": "string"
            }
          },
          "required": [
            "source",
            "destination"
          ]
        }
      },
      {
        "name": "search_files",
        "description": "Recursively search for files and directories matching a pattern. Searches through all subdirectories from the starting path. The search is case-insensitive and matches partial names. Returns full paths to all matching items. Great for finding files when you don't know their exact location. Only searches within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "pattern": {
              "type": "string"
            },
            "excludePatterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": []
            }
          },
          "required": [
            "path",
            "pattern"
          ]
        }
      },
      {
        "name": "get_file_info",
        "description": "Retrieve detailed metadata about a file or directory. Returns comprehensive information including size, creation time, last modified time, permissions, and type. This tool is perfect for understanding file characteristics without reading the actual content. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list_allowed_directories",
        "description": "Returns the list of directories that this server is allowed to access. Use this to understand which directories are available before trying to access files.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ],
    "is_official": true
  },
  "ergo-blockchain-mcp": {
    "name": "ergo-blockchain-mcp",
    "display_name": "Ergo Blockchain Explorer",
    "description": "-An MCP server to integrate Ergo Blockchain Node and Explorer APIs for checking address balances, analyzing transactions, viewing transaction history, performing forensic analysis of addresses, searching for tokens, and monitoring network status.",
    "repository": {
      "type": "git",
      "url": "https://github.com/marctheshark3/ergo-mcp"
    },
    "homepage": "https://github.com/marctheshark3/ergo-mcp",
    "author": {
      "name": "marctheshark3"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Ergo",
      "Blockchain",
      "Python",
      "API"
    ],
    "examples": [
      {
        "title": "Running the MCP Server as a Module",
        "description": "Run the server using Python module command.",
        "prompt": "```bash\n# Make sure your virtual environment is activated:\n# Using the full path (recommended):\n/path/to/your/project/.venv/bin/python -m ergo_explorer\n\n# Or with activated virtual environment:\npython -m ergo_explorer\n```"
      },
      {
        "title": "Running Tests",
        "description": "Execute tests using pytest framework.",
        "prompt": "```bash\n# Run all tests\npython -m pytest\n\n# Run specific test files\npython -m pytest tests/unit/test_address_tools.py\n```"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "ergo-mcp"
        ],
        "env": {
          "SERVER_HOST": "<YOUR_HOST>",
          "SERVER_PORT": "<YOUR_PORT>",
          "SERVER_WORKERS": "<YOUR_WORKERS>",
          "ERGO_NODE_API": "<YOUR_ERGO_NODE_API>",
          "ERGO_NODE_API_KEY": "<YOUR_ERGO_NODE_API_KEY>"
        }
      }
    },
    "arguments": {
      "SERVER_HOST": {
        "description": "Host to bind the server to (default: 0.0.0.0)",
        "required": false,
        "example": "localhost"
      },
      "SERVER_PORT": {
        "description": "Port to run the server on (default: 3001)",
        "required": false,
        "example": "3001"
      },
      "SERVER_WORKERS": {
        "description": "Number of worker processes (default: 4)",
        "required": false,
        "example": "4"
      },
      "ERGO_NODE_API": {
        "description": "URL of the Ergo node API (for node-specific features)",
        "required": false,
        "example": "http://localhost:8080"
      },
      "ERGO_NODE_API_KEY": {
        "description": "API key for the Ergo node (if required)",
        "required": false,
        "example": "your_api_key"
      }
    }
  },
  "nasa": {
    "name": "nasa",
    "display_name": "NASA",
    "description": "Access to a unified gateway of NASA's data sources including but not limited to APOD, NEO, EPIC, GIBS.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ProgramComputer/NASA-MCP-server"
    },
    "homepage": "https://github.com/ProgramComputer/NASA-MCP-server",
    "author": {
      "name": "ProgramComputer"
    },
    "license": "ISC",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "NASA",
      "API",
      "Data",
      "Space",
      "Science"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@programcomputer/nasa-mcp-server"
        ],
        "env": {
          "NASA_API_KEY": "${NASA_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Get Today's Astronomy Picture of the Day",
        "description": "Fetch the APOD from NASA's API.",
        "prompt": "GET /nasa/apod"
      },
      {
        "title": "Get Mars Rover Photos",
        "description": "Retrieve photos taken by the Curiosity rover on a specific sol.",
        "prompt": "GET /nasa/mars-rover?rover=curiosity&sol=1000"
      },
      {
        "title": "Search for Near Earth Objects",
        "description": "Find any near earth objects recorded in a specified date range.",
        "prompt": "GET /nasa/neo?start_date=2023-01-01&end_date=2023-01-07"
      }
    ],
    "arguments": {
      "NASA_API_KEY": {
        "description": "Your NASA API key (get at api.nasa.gov)",
        "required": false,
        "example": "DEMO_KEY"
      }
    },
    "tools": [
      {
        "name": "nasa/apod",
        "description": "Fetch NASA's Astronomy Picture of the Day",
        "inputSchema": {
          "type": "object",
          "properties": {
            "date": {
              "type": "string",
              "description": "The date of the APOD image to retrieve (YYYY-MM-DD)"
            },
            "count": {
              "type": "number",
              "description": "Count of random APODs to retrieve"
            },
            "start_date": {
              "type": "string",
              "description": "Start date for date range search (YYYY-MM-DD)"
            },
            "end_date": {
              "type": "string",
              "description": "End date for date range search (YYYY-MM-DD)"
            },
            "thumbs": {
              "type": "boolean",
              "description": "Return URL of thumbnail for video content"
            }
          },
          "required": [
            "date"
          ]
        }
      },
      {
        "name": "nasa/neo",
        "description": "Near Earth Object Web Service - information about asteroids",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start_date": {
              "type": "string",
              "description": "Start date for asteroid search (YYYY-MM-DD)"
            },
            "end_date": {
              "type": "string",
              "description": "End date for asteroid search (YYYY-MM-DD)"
            },
            "asteroid_id": {
              "type": "string",
              "description": "ID of a specific asteroid"
            }
          },
          "required": [
            "start_date",
            "end_date"
          ]
        }
      },
      {
        "name": "nasa/epic",
        "description": "Earth Polychromatic Imaging Camera - views of Earth",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Image collection (natural or enhanced)"
            },
            "date": {
              "type": "string",
              "description": "Date of the image (YYYY-MM-DD)"
            }
          }
        }
      },
      {
        "name": "nasa/gibs",
        "description": "Global Imagery Browse Services - satellite imagery",
        "inputSchema": {
          "type": "object",
          "properties": {
            "layer": {
              "type": "string",
              "description": "Layer name (e.g., MODIS_Terra_CorrectedReflectance_TrueColor)"
            },
            "date": {
              "type": "string",
              "description": "Date of imagery (YYYY-MM-DD)"
            },
            "format": {
              "type": "string",
              "description": "Image format (png, jpg, jpeg)"
            },
            "resolution": {
              "type": "number",
              "description": "Resolution in pixels per degree"
            }
          },
          "required": [
            "layer",
            "date"
          ]
        }
      },
      {
        "name": "nasa/cmr",
        "description": "NASA Common Metadata Repository - search for NASA data collections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string",
              "description": "Search keyword"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination"
            },
            "sort_key": {
              "type": "string",
              "description": "Field to sort results by"
            }
          },
          "required": [
            "keyword"
          ]
        }
      },
      {
        "name": "nasa/firms",
        "description": "NASA Fire Information for Resource Management System - fire data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "latitude": {
              "type": "number",
              "description": "Latitude coordinate"
            },
            "longitude": {
              "type": "number",
              "description": "Longitude coordinate"
            },
            "days": {
              "type": "number",
              "description": "Number of days of data to retrieve"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ]
        }
      },
      {
        "name": "nasa/images",
        "description": "NASA Image and Video Library - search NASA's media archive",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "Search query"
            },
            "media_type": {
              "type": "string",
              "description": "Media type (image, video, audio)"
            },
            "year_start": {
              "type": "string",
              "description": "Start year for results"
            },
            "year_end": {
              "type": "string",
              "description": "End year for results"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination"
            }
          },
          "required": [
            "q"
          ]
        }
      },
      {
        "name": "nasa/exoplanet",
        "description": "NASA Exoplanet Archive - data about planets beyond our solar system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table": {
              "type": "string",
              "description": "Database table to query"
            },
            "select": {
              "type": "string",
              "description": "Columns to return"
            },
            "where": {
              "type": "string",
              "description": "Filter conditions"
            },
            "order": {
              "type": "string",
              "description": "Ordering of results"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results"
            }
          },
          "required": [
            "table"
          ]
        }
      },
      {
        "name": "nasa/donki",
        "description": "Space Weather Database Of Notifications, Knowledge, Information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Type of space weather event"
            },
            "startDate": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD)"
            },
            "endDate": {
              "type": "string",
              "description": "End date (YYYY-MM-DD)"
            }
          },
          "required": [
            "type"
          ]
        }
      },
      {
        "name": "nasa/mars-rover",
        "description": "NASA Mars Rover Photos - images from Mars rovers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rover": {
              "type": "string",
              "description": "Name of the rover (curiosity, opportunity, spirit, perseverance)"
            },
            "sol": {
              "type": "number",
              "description": "Martian sol (day) of the photos"
            },
            "earth_date": {
              "type": "string",
              "description": "Earth date of the photos (YYYY-MM-DD)"
            },
            "camera": {
              "type": "string",
              "description": "Camera name"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination"
            }
          },
          "required": [
            "rover"
          ]
        }
      },
      {
        "name": "nasa/eonet",
        "description": "Earth Observatory Natural Event Tracker - natural events data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category": {
              "type": "string",
              "description": "Event category (wildfires, volcanoes, etc.)"
            },
            "days": {
              "type": "number",
              "description": "Number of days to look back"
            },
            "source": {
              "type": "string",
              "description": "Data source"
            },
            "status": {
              "type": "string",
              "description": "Event status (open, closed)"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of events to return"
            }
          }
        }
      },
      {
        "name": "nasa/power",
        "description": "Prediction of Worldwide Energy Resources - meteorological data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "parameters": {
              "type": "string",
              "description": "Comma-separated data parameters"
            },
            "community": {
              "type": "string",
              "description": "User community (RE, SB, AG, etc.)"
            },
            "longitude": {
              "type": "number",
              "description": "Longitude coordinate"
            },
            "latitude": {
              "type": "number",
              "description": "Latitude coordinate"
            },
            "start": {
              "type": "string",
              "description": "Start date (YYYYMMDD)"
            },
            "end": {
              "type": "string",
              "description": "End date (YYYYMMDD)"
            },
            "format": {
              "type": "string",
              "description": "Response format (json, csv, etc.)"
            }
          },
          "required": [
            "parameters",
            "community",
            "longitude",
            "latitude",
            "start",
            "end"
          ]
        }
      },
      {
        "name": "jpl/sbdb",
        "description": "Small-Body Database (SBDB) - asteroid and comet data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sstr": {
              "type": "string",
              "description": "Search string (e.g., asteroid name, number, or designation)"
            },
            "cad": {
              "type": "boolean",
              "description": "Include close approach data"
            }
          },
          "required": [
            "sstr"
          ]
        }
      },
      {
        "name": "jpl/fireball",
        "description": "Fireball data - atmospheric impact events",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "date-min": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD)"
            },
            "date-max": {
              "type": "string",
              "description": "End date (YYYY-MM-DD)"
            }
          }
        }
      },
      {
        "name": "jpl/jd_cal",
        "description": "Julian Day number to/from calendar date/time converter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "jd": {
              "type": "string",
              "description": "Julian date to convert to calendar date"
            },
            "cd": {
              "type": "string",
              "description": "Calendar date to convert to Julian date (YYYY-MM-DD or YYYY-MM-DDThh:mm:ss format)"
            }
          }
        }
      },
      {
        "name": "jpl/nhats",
        "description": "Human-accessible NEOs (Near-Earth Objects) data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dv": {
              "type": "number",
              "description": "Minimum total delta-V (km/s). Values: 4-12, default: 12"
            },
            "dur": {
              "type": "number",
              "description": "Minimum total mission duration (days). Values: 60-450, default: 450"
            },
            "stay": {
              "type": "number",
              "description": "Minimum stay time (days). Values: 8, 16, 24, 32, default: 8"
            },
            "launch": {
              "type": "string",
              "description": "Launch window (year range). Values: 2020-2025, 2025-2030, 2030-2035, 2035-2040, 2040-2045, 2020-2045, default: 2020-2045"
            },
            "h": {
              "type": "number",
              "description": "Object's maximum absolute magnitude (mag). Values: 16-30"
            },
            "occ": {
              "type": "number",
              "description": "Object's maximum orbit condition code. Values: 0-8"
            },
            "des": {
              "type": "string",
              "description": "Object designation (e.g., '2000 SG344' or '433')"
            },
            "spk": {
              "type": "string",
              "description": "Object SPK-ID (e.g., '2000433')"
            },
            "plot": {
              "type": "boolean",
              "description": "Include base-64 encoded plot image"
            }
          }
        }
      },
      {
        "name": "jpl/cad",
        "description": "Asteroid and comet close approaches to the planets in the past and future",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dist-max": {
              "type": "string",
              "description": "Maximum approach distance (e.g., 0.05, 10LD). Default: 0.05 au"
            },
            "dist-min": {
              "type": "string",
              "description": "Minimum approach distance. Default: none"
            },
            "date-min": {
              "type": "string",
              "description": "Start date for search (YYYY-MM-DD). Default: now"
            },
            "date-max": {
              "type": "string",
              "description": "End date for search (YYYY-MM-DD). Default: +60 days"
            },
            "body": {
              "type": "string",
              "description": "Body to find close approaches to (e.g., Earth, Mars, ALL). Default: Earth"
            },
            "sort": {
              "type": "string",
              "description": "Sort field: date, dist, dist-min, v-inf, v-rel, h, object. Default: date"
            },
            "des": {
              "type": "string",
              "description": "Object designation (e.g., '2000 SG344' or '433')"
            },
            "spk": {
              "type": "string",
              "description": "Object SPK-ID (e.g., '2000433')"
            },
            "neo": {
              "type": "boolean",
              "description": "Limit to NEOs. Default: true"
            },
            "fullname": {
              "type": "boolean",
              "description": "Include full object name in result. Default: false"
            }
          }
        }
      },
      {
        "name": "jpl/sentry",
        "description": "JPL Sentry - NEO Earth impact risk assessment data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "date-min": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD)"
            },
            "date-max": {
              "type": "string",
              "description": "End date (YYYY-MM-DD)"
            },
            "des": {
              "type": "string",
              "description": "Object designation (e.g., '2011 AG5' or '29075')"
            },
            "spk": {
              "type": "string",
              "description": "Object SPK-ID"
            },
            "h-max": {
              "type": "number",
              "description": "Maximum absolute magnitude (size filter)"
            },
            "ps-min": {
              "type": "string",
              "description": "Minimum Palermo Scale value"
            },
            "ip-min": {
              "type": "string",
              "description": "Minimum impact probability"
            },
            "removed": {
              "type": "boolean",
              "description": "Get objects removed from Sentry monitoring"
            },
            "all": {
              "type": "boolean",
              "description": "Get all virtual impactors data"
            }
          }
        }
      },
      {
        "name": "jpl/horizons",
        "description": "JPL Horizons - Solar system objects ephemeris data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "format": {
              "type": "string",
              "description": "Response format (json, text)",
              "enum": [
                "json",
                "text"
              ]
            },
            "COMMAND": {
              "type": "string",
              "description": "Target object identifier (e.g., '499' for Mars, '1' for Ceres, 'C/2020 F3' for Comet NEOWISE)"
            },
            "OBJ_DATA": {
              "type": "string",
              "description": "Include object data",
              "enum": [
                "YES",
                "NO"
              ]
            },
            "MAKE_EPHEM": {
              "type": "string",
              "description": "Generate ephemeris",
              "enum": [
                "YES",
                "NO"
              ]
            },
            "EPHEM_TYPE": {
              "type": "string",
              "description": "Type of ephemeris (OBSERVER, VECTORS, ELEMENTS)",
              "enum": [
                "OBSERVER",
                "VECTORS",
                "ELEMENTS"
              ]
            },
            "CENTER": {
              "type": "string",
              "description": "Coordinate center (e.g., '500@399' for Earth)"
            },
            "START_TIME": {
              "type": "string",
              "description": "Start time for ephemeris (e.g., '2023-01-01')"
            },
            "STOP_TIME": {
              "type": "string",
              "description": "Stop time for ephemeris (e.g., '2023-01-02')"
            },
            "STEP_SIZE": {
              "type": "string",
              "description": "Step size for ephemeris points (e.g., '1d' for daily, '1h' for hourly)"
            },
            "QUANTITIES": {
              "type": "string",
              "description": "Observable quantities to include (e.g., 'A' for all, or '1,2,20,23' for specific ones)"
            },
            "OUT_UNITS": {
              "type": "string",
              "description": "Output units for vector tables",
              "enum": [
                "KM-S",
                "AU-D",
                "KM-D"
              ]
            }
          },
          "required": [
            "COMMAND"
          ]
        }
      }
    ]
  },
  "perplexity": {
    "display_name": "Perplexity Ask MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/ppl-ai/modelcontextprotocol"
    },
    "homepage": "https://github.com/ppl-ai/modelcontextprotocol",
    "author": {
      "name": "ppl-ai"
    },
    "license": "MIT",
    "tags": [
      "perplexity",
      "search",
      "sonar-api",
      "web-search"
    ],
    "arguments": {
      "PERPLEXITY_API_KEY": {
        "description": "API key for the Perplexity Sonar API",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      }
    },
    "installations": {
      "npx": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "server-perplexity-ask"
        ],
        "package": "server-perplexity-ask",
        "env": {
          "PERPLEXITY_API_KEY": "YOUR_API_KEY_HERE"
        },
        "description": "Run using NPX"
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "PERPLEXITY_API_KEY",
          "mcp/perplexity-ask"
        ],
        "env": {
          "PERPLEXITY_API_KEY": "YOUR_API_KEY_HERE"
        },
        "description": "Run using Docker"
      }
    },
    "examples": [
      {
        "title": "Web Search",
        "description": "Use Perplexity to search the web for information",
        "prompt": "Search the web for the latest information about climate change policies."
      }
    ],
    "name": "perplexity",
    "description": "An MCP server implementation that integrates the Sonar API to provide Claude with unparalleled real-time, web-wide research.",
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "perplexity_ask",
        "description": "Engages in a conversation using the Sonar API. Accepts an array of messages (each with a role and content) and returns a ask completion response from the Perplexity model.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "messages": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "role": {
                    "type": "string",
                    "description": "Role of the message (e.g., system, user, assistant)"
                  },
                  "content": {
                    "type": "string",
                    "description": "The content of the message"
                  }
                },
                "required": [
                  "role",
                  "content"
                ]
              },
              "description": "Array of conversation messages"
            }
          },
          "required": [
            "messages"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "discourse": {
    "name": "discourse",
    "display_name": "Discourse",
    "description": "A MCP server to search Discourse posts on a Discourse forum.",
    "repository": {
      "type": "git",
      "url": "https://github.com/AshDevFr/discourse-mcp-server"
    },
    "license": "MIT",
    "tags": [
      "discourse",
      "search"
    ],
    "author": {
      "name": "AshDevFr"
    },
    "homepage": "https://github.com/AshDevFr/discourse-mcp-server",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@ashdev/discourse-mcp-server"
        ],
        "env": {
          "DISCOURSE_API_URL": "${DISCOURSE_API_URL}",
          "DISCOURSE_API_KEY": "${DISCOURSE_API_KEY}",
          "DISCOURSE_API_USERNAME": "${DISCOURSE_API_USERNAME}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "DISCOURSE_API_URL=${DISCOURSE_API_URL}",
          "-e",
          "DISCOURSE_API_KEY=${DISCOURSE_API_KEY}",
          "-e",
          "DISCOURSE_API_USERNAME=${DISCOURSE_API_USERNAME}",
          "ashdev/discourse-mcp-server"
        ]
      }
    },
    "arguments": {
      "DISCOURSE_API_URL": {
        "description": "API URL for the Discourse forum that the server will connect to.",
        "required": true,
        "example": "https://try.discourse.org"
      },
      "DISCOURSE_API_KEY": {
        "description": "API key for authenticating to the Discourse forum.",
        "required": true,
        "example": "1234"
      },
      "DISCOURSE_API_USERNAME": {
        "description": "Username for authenticating to the Discourse forum.",
        "required": true,
        "example": "ash"
      }
    },
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "search_posts",
        "description": "Search Discourse posts",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "minLength": 5,
              "description": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "webflow": {
    "name": "webflow",
    "display_name": "Webflow",
    "description": "Interfact with the Webflow APIs",
    "repository": {
      "type": "git",
      "url": "https://github.com/kapilduraphe/webflow-mcp-server"
    },
    "homepage": "https://github.com/kapilduraphe/webflow-mcp-server",
    "author": {
      "name": "kapilduraphe"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "webflow",
      "api"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/kapilduraphe/webflow-mcp-server"
        ],
        "env": {
          "WEBFLOW_API_TOKEN": "${WEBFLOW_API_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Get Sites",
        "description": "Retrieve a list of all Webflow sites accessible to the authenticated user.",
        "prompt": "get_sites"
      },
      {
        "title": "Get Site",
        "description": "Retrieve detailed information about a specific Webflow site by ID.",
        "prompt": "get_site siteId"
      }
    ],
    "arguments": {
      "WEBFLOW_API_TOKEN": {
        "description": "Your Webflow API token to authenticate requests to the Webflow API. This token is required for the server to function and should be kept secure.",
        "required": true,
        "example": "your-api-token"
      }
    }
  },
  "opik": {
    "display_name": "Opik",
    "repository": {
      "type": "git",
      "url": "https://github.com/comet-ml/opik"
    },
    "homepage": "https://www.comet.com/site/products/opik/",
    "author": {
      "name": "comet-ml"
    },
    "license": "MIT",
    "tags": [
      "llm",
      "evaluation",
      "tracing",
      "monitoring"
    ],
    "arguments": {
      "use_local": {
        "description": "Configure SDK to run on local installation",
        "required": false,
        "example": "True"
      }
    },
    "installations": {
      "docker": {
        "type": "docker",
        "command": "./opik.sh",
        "args": [],
        "description": "Start the Opik platform using Docker Compose",
        "recommended": false
      },
      "pip": {
        "type": "python",
        "command": "pip",
        "args": [
          "install",
          "opik"
        ],
        "package": "opik",
        "description": "Install the Python SDK",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Basic Trace Logging",
        "description": "Track LLM function calls using the decorator",
        "prompt": "import opik\n\nopik.configure(use_local=True) # Run locally\n\n@opik.track\ndef my_llm_function(user_question: str) -> str:\n    # Your LLM code here\n\n    return \"Hello\""
      },
      {
        "title": "Using LLM as a Judge Metrics",
        "description": "Evaluate LLM outputs for hallucination",
        "prompt": "from opik.evaluation.metrics import Hallucination\n\nmetric = Hallucination()\nscore = metric.score(\n    input=\"What is the capital of France?\",\n    output=\"Paris\",\n    context=[\"France is a country in Europe.\"]\n)\nprint(score)"
      }
    ],
    "name": "opik",
    "description": "<div align=\"center\"><b><a href=\"readme.md\">English</a> | <a href=\"readme_CN.md\">\u7b80\u4f53\u4e2d\u6587</a> | <a href=\"readme_JP.md\">\u65e5\u672c\u8a9e</a> | <a href=\"readme_KO.md\">\ud55c\uad6d\uc5b4</a></b></div>",
    "categories": [
      "MCP Tools"
    ],
    "is_official": true
  },
  "airtable": {
    "name": "airtable",
    "display_name": "Airtable",
    "description": "Airtable Model Context Protocol Server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/felores/airtable-mcp"
    },
    "author": {
      "name": "felores"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Airtable",
      "Database",
      "API"
    ],
    "arguments": {
      "AIRTABLE_API_KEY": {
        "description": "Airtable API key for authenticating with the Airtable API",
        "required": true,
        "example": "pat.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@felores/airtable-mcp-server"
        ],
        "env": {
          "AIRTABLE_API_KEY": "${AIRTABLE_API_KEY}"
        },
        "description": "Run with npx (requires npm install)"
      }
    },
    "homepage": "https://github.com/felores/airtable-mcp",
    "tools": [
      {
        "name": "list_bases",
        "description": "List all accessible Airtable bases",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_tables",
        "description": "List all tables in a base",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            }
          },
          "required": [
            "base_id"
          ]
        }
      },
      {
        "name": "create_table",
        "description": "Create a new table in a base",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the new table"
            },
            "description": {
              "type": "string",
              "description": "Description of the table"
            },
            "fields": {
              "type": "array",
              "description": "Initial fields for the table",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the field"
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of the field (e.g., singleLineText, multilineText, number, etc.)"
                  },
                  "description": {
                    "type": "string",
                    "description": "Description of the field"
                  },
                  "options": {
                    "type": "object",
                    "description": "Field-specific options"
                  }
                },
                "required": [
                  "name",
                  "type"
                ]
              }
            }
          },
          "required": [
            "base_id",
            "table_name"
          ]
        }
      },
      {
        "name": "update_table",
        "description": "Update a table's schema",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_id": {
              "type": "string",
              "description": "ID of the table to update"
            },
            "name": {
              "type": "string",
              "description": "New name for the table"
            },
            "description": {
              "type": "string",
              "description": "New description for the table"
            }
          },
          "required": [
            "base_id",
            "table_id"
          ]
        }
      },
      {
        "name": "create_field",
        "description": "Create a new field in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_id": {
              "type": "string",
              "description": "ID of the table"
            },
            "field": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the field"
                },
                "type": {
                  "type": "string",
                  "description": "Type of the field"
                },
                "description": {
                  "type": "string",
                  "description": "Description of the field"
                },
                "options": {
                  "type": "object",
                  "description": "Field-specific options"
                }
              },
              "required": [
                "name",
                "type"
              ]
            }
          },
          "required": [
            "base_id",
            "table_id",
            "field"
          ]
        }
      },
      {
        "name": "update_field",
        "description": "Update a field in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_id": {
              "type": "string",
              "description": "ID of the table"
            },
            "field_id": {
              "type": "string",
              "description": "ID of the field to update"
            },
            "updates": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "New name for the field"
                },
                "description": {
                  "type": "string",
                  "description": "New description for the field"
                },
                "options": {
                  "type": "object",
                  "description": "New field-specific options"
                }
              }
            }
          },
          "required": [
            "base_id",
            "table_id",
            "field_id",
            "updates"
          ]
        }
      },
      {
        "name": "list_records",
        "description": "List records in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "max_records": {
              "type": "number",
              "description": "Maximum number of records to return"
            }
          },
          "required": [
            "base_id",
            "table_name"
          ]
        }
      },
      {
        "name": "create_record",
        "description": "Create a new record in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "fields": {
              "type": "object",
              "description": "Record fields as key-value pairs"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "fields"
          ]
        }
      },
      {
        "name": "update_record",
        "description": "Update an existing record in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "record_id": {
              "type": "string",
              "description": "ID of the record to update"
            },
            "fields": {
              "type": "object",
              "description": "Record fields to update as key-value pairs"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "record_id",
            "fields"
          ]
        }
      },
      {
        "name": "delete_record",
        "description": "Delete a record from a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "record_id": {
              "type": "string",
              "description": "ID of the record to delete"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "record_id"
          ]
        }
      },
      {
        "name": "search_records",
        "description": "Search for records in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "field_name": {
              "type": "string",
              "description": "Name of the field to search in"
            },
            "value": {
              "type": "string",
              "description": "Value to search for"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "field_name",
            "value"
          ]
        }
      },
      {
        "name": "get_record",
        "description": "Get a single record by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "record_id": {
              "type": "string",
              "description": "ID of the record to retrieve"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "record_id"
          ]
        }
      }
    ]
  },
  "sequential-thinking": {
    "name": "sequential-thinking",
    "display_name": "Sequential Thinking",
    "description": "Dynamic and reflective problem-solving through thought sequences",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/sequentialthinking",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "dynamic thinking",
      "reflective process",
      "structured thinking"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-sequential-thinking"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/sequentialthinking"
        ]
      }
    },
    "examples": [
      {
        "title": "Example Usage",
        "description": "Using the Sequential Thinking tool for a complex problem",
        "prompt": "Break down the complex problem of organizing an event into manageable steps."
      }
    ],
    "tools": [
      {
        "name": "sequentialthinking",
        "description": "A detailed tool for dynamic and reflective problem-solving through thoughts.\nThis tool helps analyze problems through a flexible thinking process that can adapt and evolve.\nEach thought can build on, question, or revise previous insights as understanding deepens.\n\nWhen to use this tool:\n- Breaking down complex problems into steps\n- Planning and design with room for revision\n- Analysis that might need course correction\n- Problems where the full scope might not be clear initially\n- Problems that require a multi-step solution\n- Tasks that need to maintain context over multiple steps\n- Situations where irrelevant information needs to be filtered out\n\nKey features:\n- You can adjust total_thoughts up or down as you progress\n- You can question or revise previous thoughts\n- You can add more thoughts even after reaching what seemed like the end\n- You can express uncertainty and explore alternative approaches\n- Not every thought needs to build linearly - you can branch or backtrack\n- Generates a solution hypothesis\n- Verifies the hypothesis based on the Chain of Thought steps\n- Repeats the process until satisfied\n- Provides a correct answer\n\nParameters explained:\n- thought: Your current thinking step, which can include:\n* Regular analytical steps\n* Revisions of previous thoughts\n* Questions about previous decisions\n* Realizations about needing more analysis\n* Changes in approach\n* Hypothesis generation\n* Hypothesis verification\n- next_thought_needed: True if you need more thinking, even if at what seemed like the end\n- thought_number: Current number in sequence (can go beyond initial total if needed)\n- total_thoughts: Current estimate of thoughts needed (can be adjusted up/down)\n- is_revision: A boolean indicating if this thought revises previous thinking\n- revises_thought: If is_revision is true, which thought number is being reconsidered\n- branch_from_thought: If branching, which thought number is the branching point\n- branch_id: Identifier for the current branch (if any)\n- needs_more_thoughts: If reaching end but realizing more thoughts needed\n\nYou should:\n1. Start with an initial estimate of needed thoughts, but be ready to adjust\n2. Feel free to question or revise previous thoughts\n3. Don't hesitate to add more thoughts if needed, even at the \"end\"\n4. Express uncertainty when present\n5. Mark thoughts that revise previous thinking or branch into new paths\n6. Ignore information that is irrelevant to the current step\n7. Generate a solution hypothesis when appropriate\n8. Verify the hypothesis based on the Chain of Thought steps\n9. Repeat the process until satisfied with the solution\n10. Provide a single, ideally correct answer as the final output\n11. Only set next_thought_needed to false when truly done and a satisfactory answer is reached",
        "inputSchema": {
          "type": "object",
          "properties": {
            "thought": {
              "type": "string",
              "description": "Your current thinking step"
            },
            "nextThoughtNeeded": {
              "type": "boolean",
              "description": "Whether another thought step is needed"
            },
            "thoughtNumber": {
              "type": "integer",
              "description": "Current thought number",
              "minimum": 1
            },
            "totalThoughts": {
              "type": "integer",
              "description": "Estimated total thoughts needed",
              "minimum": 1
            },
            "isRevision": {
              "type": "boolean",
              "description": "Whether this revises previous thinking"
            },
            "revisesThought": {
              "type": "integer",
              "description": "Which thought is being reconsidered",
              "minimum": 1
            },
            "branchFromThought": {
              "type": "integer",
              "description": "Branching point thought number",
              "minimum": 1
            },
            "branchId": {
              "type": "string",
              "description": "Branch identifier"
            },
            "needsMoreThoughts": {
              "type": "boolean",
              "description": "If more thoughts are needed"
            }
          },
          "required": [
            "thought",
            "nextThoughtNeeded",
            "thoughtNumber",
            "totalThoughts"
          ]
        }
      }
    ],
    "is_official": true
  },
  "agentql-mcp": {
    "display_name": "AgentQL MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/tinyfish-io/agentql-mcp"
    },
    "license": "[NOT GIVEN]",
    "homepage": "https://agentql.com",
    "author": {
      "name": "tinyfish-io"
    },
    "tags": [
      "data extraction",
      "web scraping"
    ],
    "arguments": {
      "AGENTQL_API_KEY": {
        "description": "API key from AgentQL Dev Portal",
        "required": true,
        "example": "YOUR_API_KEY"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "agentql-mcp"
        ],
        "package": "agentql-mcp",
        "env": {
          "AGENTQL_API_KEY": "YOUR_API_KEY"
        },
        "description": "Install via npm and run with npx",
        "recommended": true
      },
      "development": {
        "type": "custom",
        "command": "/path/to/agentql-mcp/dist/index.js",
        "args": [],
        "env": {
          "AGENTQL_API_KEY": "YOUR_API_KEY"
        },
        "description": "Run development version from local build",
        "recommended": false
      }
    },
    "examples": [
      {
        "title": "Extract YouTube search results",
        "description": "Extract structured data from YouTube search results",
        "prompt": "Extract the list of videos from the page https://www.youtube.com/results?search_query=agentql, every video should have a title, an author name, a number of views and a url to the video. Make sure to exclude ads items. Format this as a markdown table."
      }
    ],
    "name": "agentql-mcp",
    "description": "This is a Model Context Protocol (MCP) server that integrates [AgentQL](https://agentql.com)'s data extraction capabilities.",
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "extract-web-data",
        "description": "Extracts structured data as JSON from a web page given a URL using a Natural Language description of the data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL of the public webpage to extract data from"
            },
            "prompt": {
              "type": "string",
              "description": "Natural Language description of the data to extract from the page"
            }
          },
          "required": [
            "url",
            "prompt"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "hdw-linkedin": {
    "name": "hdw-linkedin",
    "display_name": "HDW",
    "description": "Access to profile data and management of user account with [HorizonDataWave.ai](https://horizondatawave.ai/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/horizondatawave/hdw-mcp-server"
    },
    "homepage": "https://github.com/horizondatawave/hdw-mcp-server",
    "author": {
      "name": "horizondatawave"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "LinkedIn",
      "API access",
      "Data retrieval",
      "User management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@horizondatawave/mcp"
        ],
        "env": {
          "HDW_ACCESS_TOKEN": "${HDW_ACCESS_TOKEN}",
          "HDW_ACCOUNT_ID": "${HDW_ACCOUNT_ID}"
        }
      }
    },
    "arguments": {
      "HDW_ACCESS_TOKEN": {
        "description": "Access token for HorizonDataWave API, used for authentication and authorization to access user data.",
        "required": true,
        "example": "YOUR_HD_W_ACCESS_TOKEN"
      },
      "HDW_ACCOUNT_ID": {
        "description": "Account ID for HorizonDataWave API, used to identify the user's account.",
        "required": true,
        "example": "YOUR_HD_W_ACCOUNT_ID"
      }
    },
    "tools": [
      {
        "name": "search_linkedin_users",
        "description": "Search for LinkedIn users with various filters like keywords, name, title, company, location etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string",
              "description": "Any keyword for searching in the user page."
            },
            "first_name": {
              "type": "string",
              "description": "Exact first name"
            },
            "last_name": {
              "type": "string",
              "description": "Exact last name"
            },
            "title": {
              "type": "string",
              "description": "Exact word in the title"
            },
            "company_keywords": {
              "type": "string",
              "description": "Exact word in the company name"
            },
            "school_keywords": {
              "type": "string",
              "description": "Exact word in the school name"
            },
            "current_company": {
              "type": "string",
              "description": "Company URN or name"
            },
            "past_company": {
              "type": "string",
              "description": "Past company URN or name"
            },
            "location": {
              "type": "string",
              "description": "Location name or URN"
            },
            "industry": {
              "type": "string",
              "description": "Industry URN or name"
            },
            "education": {
              "type": "string",
              "description": "Education URN or name"
            },
            "count": {
              "type": "number",
              "description": "Maximum number of results (max 1000)",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds (20-1500)",
              "default": 300
            }
          },
          "required": [
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_profile",
        "description": "Get detailed information about a LinkedIn user profile",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "User alias, URL, or URN"
            },
            "with_experience": {
              "type": "boolean",
              "description": "Include experience info",
              "default": true
            },
            "with_education": {
              "type": "boolean",
              "description": "Include education info",
              "default": true
            },
            "with_skills": {
              "type": "boolean",
              "description": "Include skills info",
              "default": true
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "get_linkedin_email_user",
        "description": "Get LinkedIn user details by email",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "description": "Email address"
            },
            "count": {
              "type": "number",
              "description": "Max results",
              "default": 5
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "email"
          ]
        }
      },
      {
        "name": "get_linkedin_user_posts",
        "description": "Get LinkedIn posts for a user by URN (must include prefix, example: fsd_profile:ACoAAEWn01QBWENVMWqyM3BHfa1A-xsvxjdaXsY)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "User URN (must include prefix, example: fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "description": "Max posts",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_user_reactions",
        "description": "Get LinkedIn reactions for a user by URN (must include prefix, example: fsd_profile:ACoAA...)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "User URN (must include prefix, example: fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "description": "Max reactions",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_chat_messages",
        "description": "Get top chat messages from LinkedIn management API. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "User URN for filtering messages (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "description": "Max messages to return",
              "default": 20
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "send_linkedin_chat_message",
        "description": "Send a chat message via LinkedIn management API. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "Recipient user URN (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "text": {
              "type": "string",
              "description": "Message text"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "user",
            "text"
          ]
        }
      },
      {
        "name": "send_linkedin_connection",
        "description": "Send a connection invitation to LinkedIn user. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "Recipient user URN (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "send_linkedin_post_comment",
        "description": "Create a comment on a LinkedIn post or on another comment. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Comment text"
            },
            "urn": {
              "type": "string",
              "description": "URN of the activity or comment to comment on (e.g., 'activity:123' or 'comment:(activity:123,456)')"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "text",
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_user_connections",
        "description": "Get list of LinkedIn user connections. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connected_after": {
              "type": "number",
              "description": "Filter users that added after the specified date (timestamp)"
            },
            "count": {
              "type": "number",
              "description": "Max connections to return",
              "default": 20
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": []
        }
      },
      {
        "name": "get_linkedin_post_reposts",
        "description": "Get LinkedIn reposts for a post by URN",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "Post URN, only activity urn type is allowed (example: activity:7234173400267538433)"
            },
            "count": {
              "type": "number",
              "description": "Max reposts to return",
              "default": 50
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "urn",
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_post_comments",
        "description": "Get LinkedIn comments for a post by URN",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "Post URN, only activity urn type is allowed (example: activity:7234173400267538433)"
            },
            "sort": {
              "type": "string",
              "description": "Sort type (relevance or recent)",
              "enum": [
                "relevance",
                "recent"
              ],
              "default": "relevance"
            },
            "count": {
              "type": "number",
              "description": "Max comments to return",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "urn",
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_google_company",
        "description": "Search for LinkedIn companies using Google search. First result is usually the best match.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Company keywords for search. For example, company name or company website",
              "examples": [
                [
                  "Software as a Service (SaaS)"
                ],
                [
                  "google.com"
                ]
              ]
            },
            "with_urn": {
              "type": "boolean",
              "description": "Include URNs in response (increases execution time)",
              "default": false
            },
            "count_per_keyword": {
              "type": "number",
              "description": "Max results per keyword",
              "default": 1,
              "minimum": 1,
              "maximum": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "get_linkedin_company",
        "description": "Get detailed information about a LinkedIn company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "company": {
              "type": "string",
              "description": "Company Alias or URL or URN (example: 'openai' or 'company:1441')"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "company"
          ]
        }
      },
      {
        "name": "get_linkedin_company_employees",
        "description": "Get employees of a LinkedIn company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "companies": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Company URNs (example: ['company:14064608'])"
            },
            "keywords": {
              "type": "string",
              "description": "Any keyword for searching employees",
              "examples": [
                "Alex"
              ]
            },
            "first_name": {
              "type": "string",
              "description": "Search for exact first name",
              "examples": [
                "Bill"
              ]
            },
            "last_name": {
              "type": "string",
              "description": "Search for exact last name",
              "examples": [
                "Gates"
              ]
            },
            "count": {
              "type": "number",
              "description": "Maximum number of results",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "companies",
            "count"
          ]
        }
      },
      {
        "name": "send_linkedin_post",
        "description": "Create a post on LinkedIn. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Post text content"
            },
            "visibility": {
              "type": "string",
              "description": "Post visibility",
              "enum": [
                "ANYONE",
                "CONNECTIONS_ONLY"
              ],
              "default": "ANYONE"
            },
            "comment_scope": {
              "type": "string",
              "description": "Who can comment on the post",
              "enum": [
                "ALL",
                "CONNECTIONS_ONLY",
                "NONE"
              ],
              "default": "ALL"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "linkedin_sn_search_users",
        "description": "Advanced search for LinkedIn users using Sales Navigator filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string",
              "description": "Any keyword for searching in the user profile. Using this may reduce result count."
            },
            "first_names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact first names to search for"
            },
            "last_names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact last names to search for"
            },
            "current_titles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact words to search in current titles"
            },
            "location": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Location URN (geo:*) or name, or array of them"
            },
            "education": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Education URN (company:*) or name, or array of them"
            },
            "languages": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Arabic",
                  "English",
                  "Spanish",
                  "Portuguese",
                  "Chinese",
                  "French",
                  "Italian",
                  "Russian",
                  "German",
                  "Dutch",
                  "Turkish",
                  "Tagalog",
                  "Polish",
                  "Korean",
                  "Japanese",
                  "Malay",
                  "Norwegian",
                  "Danish",
                  "Romanian",
                  "Swedish",
                  "Bahasa Indonesia",
                  "Czech"
                ]
              },
              "description": "Profile languages"
            },
            "past_titles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact words to search in past titles"
            },
            "functions": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Accounting",
                  "Administrative",
                  "Arts and Design",
                  "Business",
                  "Development",
                  "Community and Social Services",
                  "Consulting",
                  "Education",
                  "Engineering",
                  "Entrepreneurship",
                  "Finance",
                  "Healthcare Services",
                  "Human Resources",
                  "Information Technology",
                  "Legal",
                  "Marketing",
                  "Media and Communication",
                  "Military and Protective Services",
                  "Operations",
                  "Product Management",
                  "Program and Project Management",
                  "Purchasing",
                  "Quality Assurance",
                  "Research",
                  "Real Estate",
                  "Sales",
                  "Customer Success and Support"
                ]
              },
              "description": "Job functions"
            },
            "levels": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Entry",
                  "Director",
                  "Owner",
                  "CXO",
                  "Vice President",
                  "Experienced Manager",
                  "Entry Manager",
                  "Strategic",
                  "Senior",
                  "Trainy"
                ]
              },
              "description": "Job seniority levels"
            },
            "years_in_the_current_company": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "0-1",
                  "1-2",
                  "3-5",
                  "6-10",
                  "10+"
                ]
              },
              "description": "Years in current company ranges"
            },
            "years_in_the_current_position": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "0-1",
                  "1-2",
                  "3-5",
                  "6-10",
                  "10+"
                ]
              },
              "description": "Years in current position ranges"
            },
            "company_sizes": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Self-employed",
                  "1-10",
                  "11-50",
                  "51-200",
                  "201-500",
                  "501-1,000",
                  "1,001-5,000",
                  "5,001-10,000",
                  "10,001+"
                ]
              },
              "description": "Company size ranges"
            },
            "company_types": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Public Company",
                  "Privately Held",
                  "Non Profit",
                  "Educational Institution",
                  "Partnership",
                  "Self Employed",
                  "Self Owned",
                  "Government Agency"
                ]
              },
              "description": "Company types"
            },
            "company_locations": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Company location URN (geo:*) or name, or array of them"
            },
            "current_companies": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Current company URN (company:*) or name, or array of them"
            },
            "past_companies": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Past company URN (company:*) or name, or array of them"
            },
            "industry": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Industry URN (industry:*) or name, or array of them"
            },
            "count": {
              "type": "number",
              "description": "Maximum number of results (max 2500)",
              "default": 10,
              "minimum": 1,
              "maximum": 2500
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds (20-1500)",
              "default": 300,
              "minimum": 20,
              "maximum": 1500
            }
          },
          "required": [
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_conversations",
        "description": "Get list of LinkedIn conversations from the messaging interface. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connected_after": {
              "type": "number",
              "description": "Filter conversations created after the specified date (timestamp)"
            },
            "count": {
              "type": "number",
              "description": "Max conversations to return",
              "default": 20
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": []
        }
      },
      {
        "name": "google_search",
        "description": "Search for information using Google search API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query. For example: 'python fastapi'"
            },
            "count": {
              "type": "number",
              "description": "Maximum number of results (from 1 to 20)",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds (20-1500)",
              "default": 300
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "unity-integration-advanced": {
    "name": "unity-integration-advanced",
    "display_name": "Unity Integration",
    "description": "Advanced Unity3d Game Engine MCP which supports ,Execution of Any Editor Related Code Directly Inside of Unity, Fetch Logs, Get Editor State and Allow File Access of the Project making it much more useful in Script Editing or asset creation.",
    "repository": {
      "type": "git",
      "url": "https://github.com/quazaai/UnityMCPIntegration"
    },
    "homepage": "https://github.com/quazaai/UnityMCPIntegration",
    "author": {
      "name": "quazaai"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Unity",
      "Integration",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/quazaai/UnityMCPIntegration"
        ],
        "env": {
          "MCP_WEBSOCKET_PORT": "${MCP_WEBSOCKET_PORT}"
        }
      }
    },
    "examples": [
      {
        "title": "Get Unity Editor State",
        "description": "Retrieve comprehensive information about the current Unity project and editor state.",
        "prompt": "get_editor_state()"
      },
      {
        "title": "Execute C# Code",
        "description": "Run specific C# code directly within the Unity Editor.",
        "prompt": "execute_editor_command('Debug.Log(\"Hello, World!\");')"
      }
    ],
    "arguments": {
      "MCP_WEBSOCKET_PORT": {
        "description": "Environment variable to specify the WebSocket port used by the MCP server.",
        "required": false,
        "example": "5010"
      }
    },
    "tools": [
      {
        "name": "get_current_scene_info",
        "description": "Retrieve information about the current scene in Unity Editor with configurable detail level",
        "inputSchema": {
          "type": "object",
          "properties": {
            "detailLevel": {
              "type": "string",
              "enum": [
                "RootObjectsOnly",
                "FullHierarchy"
              ],
              "description": "RootObjectsOnly: Returns just root GameObjects. FullHierarchy: Returns complete hierarchy with all children.",
              "default": "RootObjectsOnly"
            }
          }
        },
        "category": "Editor State",
        "tags": [
          "unity",
          "editor",
          "scene"
        ],
        "returns": {
          "type": "object",
          "description": "Returns information about the current scene and its hierarchy based on requested detail level"
        }
      },
      {
        "name": "get_game_objects_info",
        "description": "Retrieve detailed information about specific GameObjects in the current scene",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instanceIDs": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Array of GameObject instance IDs to get information for",
              "minItems": 1
            },
            "detailLevel": {
              "type": "string",
              "enum": [
                "BasicInfo",
                "IncludeComponents",
                "IncludeChildren",
                "IncludeComponentsAndChildren"
              ],
              "description": "BasicInfo: Basic GameObject information. IncludeComponents: Includes component details. IncludeChildren: Includes child GameObjects. IncludeComponentsAndChildren: Includes both components and a full hierarchy with components on children.",
              "default": "IncludeComponents"
            }
          },
          "required": [
            "instanceIDs"
          ]
        },
        "category": "Editor State",
        "tags": [
          "unity",
          "editor",
          "gameobjects"
        ],
        "returns": {
          "type": "object",
          "description": "Returns detailed information about the requested GameObjects"
        }
      },
      {
        "name": "execute_editor_command",
        "description": "Execute C# code directly in the Unity Editor - allows full flexibility including custom namespaces and multiple classes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "C# code to execute in Unity Editor. You MUST define a public class named \"McpScript\" with a public static method named \"Execute\" that returns an object. Example: \"public class McpScript { public static object Execute() { /* your code here */ return result; } }\". You can include any necessary namespaces, additional classes, and methods.",
              "minLength": 1
            }
          },
          "required": [
            "code"
          ]
        },
        "category": "Editor Control",
        "tags": [
          "unity",
          "editor",
          "command",
          "c#"
        ],
        "returns": {
          "type": "object",
          "description": "Returns the execution result, execution time, and status"
        }
      },
      {
        "name": "get_logs",
        "description": "Retrieve Unity Editor logs with filtering options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "types": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Log",
                  "Warning",
                  "Error",
                  "Exception"
                ]
              },
              "description": "Filter logs by type"
            },
            "count": {
              "type": "number",
              "description": "Maximum number of log entries to return",
              "minimum": 1,
              "maximum": 1000
            },
            "fields": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "message",
                  "stackTrace",
                  "logType",
                  "timestamp"
                ]
              },
              "description": "Specify which fields to include in the output"
            },
            "messageContains": {
              "type": "string",
              "description": "Filter logs by message content"
            },
            "stackTraceContains": {
              "type": "string",
              "description": "Filter logs by stack trace content"
            },
            "timestampAfter": {
              "type": "string",
              "description": "Filter logs after this ISO timestamp"
            },
            "timestampBefore": {
              "type": "string",
              "description": "Filter logs before this ISO timestamp"
            }
          }
        },
        "category": "Debugging",
        "tags": [
          "unity",
          "editor",
          "logs",
          "debugging"
        ],
        "returns": {
          "type": "array",
          "description": "Returns an array of log entries matching the specified filters"
        }
      },
      {
        "name": "verify_connection",
        "description": "Verify that the MCP server has an active connection to Unity Editor",
        "inputSchema": {
          "type": "object",
          "properties": {}
        },
        "category": "Connection",
        "tags": [
          "unity",
          "editor",
          "connection"
        ],
        "returns": {
          "type": "object",
          "description": "Returns connection status information"
        }
      },
      {
        "name": "get_editor_state",
        "description": "Get the current Unity Editor state including project information",
        "inputSchema": {
          "type": "object",
          "properties": {}
        },
        "category": "Editor State",
        "tags": [
          "unity",
          "editor",
          "project"
        ],
        "returns": {
          "type": "object",
          "description": "Returns detailed information about the current Unity Editor state, project settings, and environment"
        }
      },
      {
        "name": "read_file",
        "description": "Read the contents of a file from the Unity project. Paths are relative to the project's Assets folder. For example, use 'Scenes/MainScene.unity' to read Assets/Scenes/MainScene.unity.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file to read. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder."
            }
          },
          "required": [
            "path"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file"
        ]
      },
      {
        "name": "read_multiple_files",
        "description": "Read the contents of multiple files from the Unity project simultaneously.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of file paths to read. Paths can be absolute or relative to Unity project Assets folder."
            }
          },
          "required": [
            "paths"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file",
          "batch"
        ]
      },
      {
        "name": "write_file",
        "description": "Create a new file or completely overwrite an existing file in the Unity project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file to write. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder."
            },
            "content": {
              "type": "string",
              "description": "Content to write to the file"
            }
          },
          "required": [
            "path",
            "content"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file",
          "write"
        ]
      },
      {
        "name": "edit_file",
        "description": "Make precise edits to a text file in the Unity project. Returns a git-style diff showing changes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file to edit. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder."
            },
            "edits": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "oldText": {
                    "type": "string",
                    "description": "Text to search for - must match exactly"
                  },
                  "newText": {
                    "type": "string",
                    "description": "Text to replace with"
                  }
                },
                "required": [
                  "oldText",
                  "newText"
                ],
                "additionalProperties": false
              },
              "description": "Array of edit operations to apply"
            },
            "dryRun": {
              "type": "boolean",
              "default": false,
              "description": "Preview changes using git-style diff format"
            }
          },
          "required": [
            "path",
            "edits"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file",
          "edit"
        ]
      },
      {
        "name": "list_directory",
        "description": "Get a listing of all files and directories in a specified path in the Unity project. Paths are relative to the Assets folder unless absolute. For example, use 'Scenes' to list all files in Assets/Scenes directory. Use empty string to list the Assets folder.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the directory to list. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder. Example: \"Scenes\" will list all files in the Assets/Scenes directory."
            }
          },
          "required": [
            "path"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "directory",
          "list"
        ]
      },
      {
        "name": "directory_tree",
        "description": "Get a recursive tree view of files and directories in the Unity project as a JSON structure.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the directory to get tree of. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder. Example: \"Prefabs\" will show the tree for Assets/Prefabs."
            },
            "maxDepth": {
              "type": "number",
              "default": 5,
              "description": "Maximum depth to traverse"
            }
          },
          "required": [
            "path"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "directory",
          "tree"
        ]
      },
      {
        "name": "search_files",
        "description": "Recursively search for files and directories matching a pattern in the Unity project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to search from. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder. Example: \"Scripts\" will search within Assets/Scripts."
            },
            "pattern": {
              "type": "string",
              "description": "Pattern to search for"
            },
            "excludePatterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Patterns to exclude"
            }
          },
          "required": [
            "path",
            "pattern"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "search"
        ]
      },
      {
        "name": "get_file_info",
        "description": "Retrieve detailed metadata about a file or directory in the Unity project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file to get info for. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder."
            }
          },
          "required": [
            "path"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file",
          "metadata"
        ]
      },
      {
        "name": "find_assets_by_type",
        "description": "Find all Unity assets of a specified type (e.g., Material, Prefab, Scene, Script) in the project. Set searchPath to an empty string to search the entire Assets folder.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetType": {
              "type": "string",
              "description": "Type of assets to find (e.g., \"Material\", \"Prefab\", \"Scene\", \"Script\")"
            },
            "searchPath": {
              "type": "string",
              "default": "",
              "description": "Directory to search in. Can be absolute or relative to Unity project Assets folder. An empty string will search the entire Assets folder."
            },
            "maxDepth": {
              "type": "number",
              "default": 1,
              "description": "Maximum depth to search. 1 means search only in the specified directory, 2 includes immediate subdirectories, and so on. Set to -1 for unlimited depth."
            }
          },
          "required": [
            "assetType"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "assets",
          "search"
        ]
      }
    ]
  },
  "playwright": {
    "display_name": "Playwright MCP",
    "license": "MIT",
    "tags": [
      "browser automation",
      "web",
      "playwright",
      "accessibility",
      "LLM",
      "MCP",
      "Model Context Protocol",
      "web navigation",
      "form-filling",
      "data extraction"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@playwright/mcp@latest"
        ],
        "description": "Using Vision Mode with screenshots for visual-based interactions"
      }
    },
    "examples": [
      {
        "title": "",
        "description": "",
        "prompt": "Navigate to google.com and search for 'playwright automation'"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Fill out a login form with username 'test@example.com' and password 'password123'"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Take a snapshot of the current page and click on the first search result"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Open a new tab, navigate to github.com, and then switch back to the first tab"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Navigate to a shopping website, add an item to cart, and proceed to checkout"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Fill out a form with multiple fields and submit it"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Take a screenshot of the current page"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Navigate to a website with a dropdown menu and select an option"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Upload a file to a website"
      },
      {
        "title": "",
        "description": "",
        "prompt": "Extract data from a table on a webpage"
      }
    ],
    "name": "playwright",
    "repository": {
      "type": "git",
      "url": "https://github.com/microsoft/playwright-mcp"
    },
    "homepage": "https://github.com/microsoft/playwright-mcp",
    "author": {
      "name": "microsoft"
    },
    "description": "A Model Context Protocol (MCP) server that provides browser automation capabilities using [Playwright](https://playwright.dev). This server enables LLMs to interact with web pages through structured accessibility snapshots, bypassing the need for screenshots or visually-tuned models.",
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "browser_close",
        "description": "Close the page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_wait",
        "description": "Wait for a specified time in seconds",
        "inputSchema": {
          "type": "object",
          "properties": {
            "time": {
              "type": "number",
              "description": "The time to wait in seconds"
            }
          },
          "required": [
            "time"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_resize",
        "description": "Resize the browser window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "width": {
              "type": "number",
              "description": "Width of the browser window"
            },
            "height": {
              "type": "number",
              "description": "Height of the browser window"
            }
          },
          "required": [
            "width",
            "height"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_file_upload",
        "description": "Upload one or multiple files",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The absolute paths to the files to upload. Can be a single file or multiple files."
            }
          },
          "required": [
            "paths"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_install",
        "description": "Install the browser specified in the config. Call this if you get an error about the browser not being installed.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_press_key",
        "description": "Press a key on the keyboard",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Name of the key to press or a character to generate, such as `ArrowLeft` or `a`"
            }
          },
          "required": [
            "key"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_navigate",
        "description": "Navigate to a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to navigate to"
            }
          },
          "required": [
            "url"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_navigate_back",
        "description": "Go back to the previous page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_navigate_forward",
        "description": "Go forward to the next page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_pdf_save",
        "description": "Save page as PDF",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_screen_capture",
        "description": "Take a screenshot of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_screen_move_mouse",
        "description": "Move mouse to a given position",
        "inputSchema": {
          "type": "object",
          "properties": {
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to interact with the element"
            },
            "x": {
              "type": "number",
              "description": "X coordinate"
            },
            "y": {
              "type": "number",
              "description": "Y coordinate"
            }
          },
          "required": [
            "element",
            "x",
            "y"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_screen_click",
        "description": "Click left mouse button",
        "inputSchema": {
          "type": "object",
          "properties": {
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to interact with the element"
            },
            "x": {
              "type": "number",
              "description": "X coordinate"
            },
            "y": {
              "type": "number",
              "description": "Y coordinate"
            }
          },
          "required": [
            "element",
            "x",
            "y"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_screen_drag",
        "description": "Drag left mouse button",
        "inputSchema": {
          "type": "object",
          "properties": {
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to interact with the element"
            },
            "startX": {
              "type": "number",
              "description": "Start X coordinate"
            },
            "startY": {
              "type": "number",
              "description": "Start Y coordinate"
            },
            "endX": {
              "type": "number",
              "description": "End X coordinate"
            },
            "endY": {
              "type": "number",
              "description": "End Y coordinate"
            }
          },
          "required": [
            "element",
            "startX",
            "startY",
            "endX",
            "endY"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_screen_type",
        "description": "Type text",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Text to type into the element"
            },
            "submit": {
              "type": "boolean",
              "description": "Whether to submit entered text (press Enter after)"
            }
          },
          "required": [
            "text"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_tab_list",
        "description": "List browser tabs",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_tab_new",
        "description": "Open a new tab",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to navigate to in the new tab. If not provided, the new tab will be blank."
            }
          },
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_tab_select",
        "description": "Select a tab by index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "number",
              "description": "The index of the tab to select"
            }
          },
          "required": [
            "index"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "browser_tab_close",
        "description": "Close a tab",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "number",
              "description": "The index of the tab to close. Closes current tab if not provided."
            }
          },
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      }
    ],
    "prompts": [],
    "resources": [
      {
        "uri": "browser://console",
        "name": "Page console",
        "mimeType": "text/plain"
      }
    ],
    "is_official": true
  },
  "screenshotone": {
    "display_name": "ScreenshotOne MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/screenshotone/mcp"
    },
    "homepage": "https://screenshotone.com",
    "author": {
      "name": "screenshotone"
    },
    "license": "MIT",
    "tags": [
      "screenshot",
      "website",
      "image"
    ],
    "arguments": {
      "SCREENSHOTONE_API_KEY": {
        "description": "API key for ScreenshotOne service",
        "required": true,
        "example": "<your api key>"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "build/index.js"
        ],
        "env": {
          "SCREENSHOTONE_API_KEY": "your_api_key"
        },
        "description": "Run as standalone server",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Render Website Screenshot",
        "description": "Render a screenshot of a website and return it as an image",
        "prompt": "Take a screenshot of the website https://example.com"
      }
    ],
    "name": "screenshotone",
    "description": "An official implementation of an [MCP (Model Context Protocol)](https://modelcontextprotocol.io/) server for [ScreenshotOne](https://screenshotone.com).",
    "categories": [
      "Web Services"
    ],
    "is_official": true
  },
  "mailgun-mcp-server": {
    "display_name": "Mailgun MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/mailgun/mailgun-mcp-server"
    },
    "homepage": "https://github.com/mailgun/mailgun-mcp-server",
    "author": {
      "name": "mailgun"
    },
    "license": "Apache-2.0",
    "tags": [
      "email",
      "mailgun",
      "mcp"
    ],
    "arguments": {
      "MAILGUN_API_KEY": {
        "description": "Your Mailgun API key",
        "required": true,
        "example": "YOUR-mailgun-api-key"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "path/to/mailgun-mcp-server/src/mailgun-mcp.js"
        ],
        "env": {
          "MAILGUN_API_KEY": "YOUR-mailgun-api-key"
        },
        "description": "Run the server using Node.js",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Send an Email",
        "description": "Send an email with a funny body from IT Desk",
        "prompt": "Can you send an email to EMAIL_HERE with a funny email body that makes it sound like it's from the IT Desk from Office Space? Please use the sending domain DOMAIN_HERE, and make the email from \"postmaster@DOMAIN_HERE\"!"
      },
      {
        "title": "Fetch and Visualize Sending Statistics",
        "description": "Create a chart with email delivery statistics",
        "prompt": "Would you be able to make a chart with email delivery statistics for the past week?"
      }
    ],
    "name": "mailgun",
    "description": "A Model Context Protocol (MCP) server implementation for [Mailgun](https://mailgun.com), enabling MCP-compatible AI clients like Claude Desktop to interract with the service.",
    "categories": [
      "Messaging"
    ],
    "is_official": true
  },
  "productboard": {
    "name": "productboard",
    "display_name": "Productboard",
    "description": "Integrate the Productboard API into agentic workflows via MCP.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kenjihikmatullah/productboard-mcp"
    },
    "author": {
      "name": "kenjihikmatullah"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Productboard",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "productboard-mcp"
        ],
        "env": {
          "PRODUCTBOARD_ACCESS_TOKEN": "<YOUR_TOKEN>"
        }
      }
    },
    "homepage": "https://github.com/kenjihikmatullah/productboard-mcp",
    "arguments": {
      "PRODUCTBOARD_ACCESS_TOKEN": {
        "description": "An access token needed to authenticate with the Productboard API. This token is required to make requests to the API and must be kept confidential.",
        "required": true,
        "example": "your_access_token_here"
      }
    },
    "tools": [
      {
        "name": "get_products",
        "description": "Returns detail of all products. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_product_detail",
        "description": "Returns detailed information about a specific product",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productId": {
              "type": "string",
              "description": "ID of the product to retrieve"
            }
          },
          "required": [
            "productId"
          ]
        }
      },
      {
        "name": "get_features",
        "description": "Returns a list of all features. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_feature_detail",
        "description": "Returns detailed information about a specific feature",
        "inputSchema": {
          "type": "object",
          "properties": {
            "featureId": {
              "type": "string",
              "description": "ID of the feature to retrieve"
            }
          },
          "required": [
            "featureId"
          ]
        }
      },
      {
        "name": "get_components",
        "description": "Returns a list of all components. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_component_detail",
        "description": "Returns detailed information about a specific component",
        "inputSchema": {
          "type": "object",
          "properties": {
            "componentId": {
              "type": "string",
              "description": "ID of the component to retrieve"
            }
          },
          "required": [
            "componentId"
          ]
        }
      },
      {
        "name": "get_feature_statuses",
        "description": "Returns a list of all feature statuses. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_notes",
        "description": "Returns a list of all notes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "last": {
              "type": "string",
              "description": "Return only notes created since given span of months (m), days (s), or hours (h). E.g. 6m | 10d | 24h | 1h. Cannot be combined with createdFrom, createdTo, dateFrom, or dateTo"
            },
            "createdFrom": {
              "type": "string",
              "format": "date",
              "description": "Return only notes created since given date. Cannot be combined with last"
            },
            "createdTo": {
              "type": "string",
              "format": "date",
              "description": "Return only notes created before or equal to the given date. Cannot be combined with last"
            },
            "updatedFrom": {
              "type": "string",
              "format": "date",
              "description": "Return only notes updated since given date"
            },
            "updatedTo": {
              "type": "string",
              "format": "date",
              "description": "Return only notes updated before or equal to the given date"
            },
            "term": {
              "type": "string",
              "description": "Return only notes by fulltext search"
            },
            "featureId": {
              "type": "string",
              "description": "Return only notes for specific feature ID or its descendants"
            },
            "companyId": {
              "type": "string",
              "description": "Return only notes for specific company ID"
            },
            "ownerEmail": {
              "type": "string",
              "description": "Return only notes owned by a specific owner email"
            },
            "source": {
              "type": "string",
              "description": "Return only notes from a specific source origin. This is the unique string identifying the external system from which the data came"
            },
            "anyTag": {
              "type": "string",
              "description": "Return only notes that have been assigned any of the tags in the array. Cannot be combined with allTags"
            },
            "allTags": {
              "type": "string",
              "description": "Return only notes that have been assigned all of the tags in the array. Cannot be combined with anyTag"
            },
            "pageLimit": {
              "type": "number",
              "description": "Page limit"
            },
            "pageCursor": {
              "type": "string",
              "description": "Page cursor to get next page of results"
            }
          }
        }
      },
      {
        "name": "get_note_detail",
        "description": "Returns detailed information about a specific note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string",
              "description": "ID of the note to retrieve"
            }
          },
          "required": [
            "noteId"
          ]
        }
      },
      {
        "name": "get_companies",
        "description": "Returns a list of all companies. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_company_detail",
        "description": "Returns detailed information about a specific company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "companyId": {
              "type": "string",
              "description": "ID of the company to retrieve"
            }
          },
          "required": [
            "companyId"
          ]
        }
      }
    ]
  },
  "qwen-max": {
    "name": "qwen-max",
    "display_name": "Qwen Max",
    "description": "A Model Context Protocol (MCP) server implementation for the Qwen models.",
    "repository": {
      "type": "git",
      "url": "https://github.com/66julienmartin/MCP-server-Qwen_Max"
    },
    "homepage": "https://github.com/66julienmartin/MCP-server-Qwen_Max",
    "author": {
      "name": "66julienmartin"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Qwen Max",
      "Server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@gongrzhe/quickchart-mcp-server"
        ]
      }
    },
    "arguments": {
      "DASHSCOPE_API_KEY": {
        "description": "API key required for authentication with the Dashscope service.",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "tools": [
      {
        "name": "generate_chart",
        "description": "Generate a chart using QuickChart",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Chart type (bar, line, pie, doughnut, radar, polarArea, scatter, bubble, radialGauge, speedometer)"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Labels for data points"
            },
            "datasets": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "label": {
                    "type": "string"
                  },
                  "data": {
                    "type": "array"
                  },
                  "backgroundColor": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "borderColor": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "additionalConfig": {
                    "type": "object"
                  }
                },
                "required": [
                  "data"
                ]
              }
            },
            "title": {
              "type": "string"
            },
            "options": {
              "type": "object"
            }
          },
          "required": [
            "type",
            "datasets"
          ]
        }
      },
      {
        "name": "download_chart",
        "description": "Download a chart image to a local file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "config": {
              "type": "object",
              "description": "Chart configuration object"
            },
            "outputPath": {
              "type": "string",
              "description": "Path where the chart image should be saved"
            }
          },
          "required": [
            "config",
            "outputPath"
          ]
        }
      }
    ]
  },
  "inkeep": {
    "display_name": "Inkeep MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/inkeep/mcp-server-python"
    },
    "homepage": "https://inkeep.com",
    "author": {
      "name": "inkeep"
    },
    "license": "MIT",
    "tags": [
      "rag",
      "documentation",
      "product content"
    ],
    "arguments": {
      "INKEEP_API_BASE_URL": {
        "description": "Base URL for the Inkeep API",
        "required": true,
        "example": "https://api.inkeep.com/v1"
      },
      "INKEEP_API_KEY": {
        "description": "API key for authenticating with Inkeep",
        "required": true,
        "example": "<YOUR_INKEEP_API_KEY>"
      },
      "INKEEP_API_MODEL": {
        "description": "The Inkeep model to use",
        "required": true,
        "example": "inkeep-rag"
      },
      "INKEEP_MCP_TOOL_NAME": {
        "description": "Name of the MCP tool",
        "required": true,
        "example": "search-product-content"
      },
      "INKEEP_MCP_TOOL_DESCRIPTION": {
        "description": "Description of the MCP tool",
        "required": true,
        "example": "Retrieves product documentation about Inkeep. The query should be framed as a conversational question about Inkeep."
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "uv",
        "args": [
          "--directory",
          "<YOUR_INKEEP_MCP_SERVER_ABSOLUTE_PATH>",
          "run",
          "-m",
          "inkeep_mcp_server"
        ],
        "env": {
          "INKEEP_API_BASE_URL": "https://api.inkeep.com/v1",
          "INKEEP_API_KEY": "<YOUR_INKEEP_API_KEY>",
          "INKEEP_API_MODEL": "inkeep-rag",
          "INKEEP_MCP_TOOL_NAME": "search-product-content",
          "INKEEP_MCP_TOOL_DESCRIPTION": "Retrieves product documentation about Inkeep. The query should be framed as a conversational question about Inkeep."
        },
        "description": "Run using uv Python project manager",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Search Inkeep Documentation",
        "description": "Ask a question about Inkeep's product",
        "prompt": "How do I integrate Inkeep with my website?"
      }
    ],
    "name": "inkeep",
    "description": "Inkeep MCP Server powered by your docs and product content.",
    "categories": [
      "Knowledge Base"
    ],
    "is_official": true
  },
  "mcp-neo4j-aura-api": {
    "display_name": "Neo4j MCP (Aura API)",
    "repository": {
      "type": "git",
      "url": "https://github.com/neo4j-contrib/mcp-neo4j"
    },
    "homepage": "https://github.com/neo4j-contrib/mcp-neo4j",
    "author": {
      "name": "neo4j-contrib"
    },
    "license": "MIT",
    "tags": [
      "neo4j",
      "mcp",
      "knowledge graph",
      "aura"
    ],
    "arguments": {
      "NEO4J_CLIENT_ID": {
        "description": "Neo4j client ID",
        "required": true,
        "example": "<client_id>"
      },
      "NEO4J_CLIENT_SECRET": {
        "description": "Neo4j client secret",
        "required": true,
        "example": "<client_secret>"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-neo4j-aura-manager",
          "--client-id",
          "${NEO4J_CLIENT_ID}",
          "--client-secret",
          "${NEO4J_CLIENT_SECRET}"
        ],
        "description": "Clone the repository to access multiple Neo4j MCP servers",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Database Schema Query",
        "description": "Get information about what's in the graph database",
        "prompt": "What is in this graph?"
      },
      {
        "title": "Data Visualization",
        "description": "Generate charts from graph data",
        "prompt": "Render a chart from the top products sold by frequency, total and average volume"
      },
      {
        "title": "Instance Management",
        "description": "List Neo4j Aura instances",
        "prompt": "List my instances"
      },
      {
        "title": "Instance Creation",
        "description": "Create a new Neo4j Aura instance",
        "prompt": "Create a new instance named mcp-test for Aura Professional with 4GB and Graph Data Science enabled"
      },
      {
        "title": "Knowledge Storage",
        "description": "Store information in the knowledge graph",
        "prompt": "Store the fact that I worked on the Neo4j MCP Servers today with Andreas and Oskar"
      }
    ],
    "name": "mcp-neo4j-aura-api",
    "description": "Neo4j graph database server (schema + read/write-cypher) and separate graph database backed memory",
    "categories": [
      "Databases"
    ],
    "is_official": true,
    "tools": [
      {
        "name": "list_instances",
        "description": "List all Neo4j Aura database instances",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_instance_details",
        "description": "Get details for one or more Neo4j Aura instances by ID, including status, region, memory, storage",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instance_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of instance IDs to retrieve"
            }
          },
          "required": [
            "instance_ids"
          ]
        }
      },
      {
        "name": "get_instance_by_name",
        "description": "Find a Neo4j Aura instance by name and returns the details including the id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the instance to find"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create_instance",
        "description": "Create a new Neo4j Aura database instance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tenant_id": {
              "type": "string",
              "description": "ID of the tenant/project where the instance will be created"
            },
            "name": {
              "type": "string",
              "description": "Name for the new instance"
            },
            "memory": {
              "type": "integer",
              "description": "Memory allocation in GB",
              "default": 1
            },
            "region": {
              "type": "string",
              "description": "Region for the instance (e.g., 'us-east-1')",
              "default": "us-central1"
            },
            "type": {
              "type": "string",
              "description": "Instance type (free-db, professional-db, enterprise-db, or business-critical)",
              "default": "free-db"
            },
            "vector_optimized": {
              "type": "boolean",
              "description": "Whether the instance is optimized for vector operations",
              "default": false
            },
            "cloud_provider": {
              "type": "string",
              "description": "Cloud provider (gcp, aws, azure)",
              "default": "gcp"
            },
            "graph_analytics_plugin": {
              "type": "boolean",
              "description": "Whether to enable the graph analytics plugin",
              "default": false
            },
            "source_instance_id": {
              "type": "string",
              "description": "ID of the source instance to clone from (for professional/enterprise instances)"
            }
          },
          "required": [
            "tenant_id",
            "name"
          ]
        }
      },
      {
        "name": "update_instance_name",
        "description": "Update the name of a Neo4j Aura instance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instance_id": {
              "type": "string",
              "description": "ID of the instance to update"
            },
            "name": {
              "type": "string",
              "description": "New name for the instance"
            }
          },
          "required": [
            "instance_id",
            "name"
          ]
        }
      },
      {
        "name": "update_instance_memory",
        "description": "Update the memory allocation of a Neo4j Aura instance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instance_id": {
              "type": "string",
              "description": "ID of the instance to update"
            },
            "memory": {
              "type": "integer",
              "description": "New memory allocation in GB"
            }
          },
          "required": [
            "instance_id",
            "memory"
          ]
        }
      },
      {
        "name": "update_instance_vector_optimization",
        "description": "Update the vector optimization setting of a Neo4j Aura instance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instance_id": {
              "type": "string",
              "description": "ID of the instance to update"
            },
            "vector_optimized": {
              "type": "boolean",
              "description": "Whether the instance should be optimized for vector operations"
            }
          },
          "required": [
            "instance_id",
            "vector_optimized"
          ]
        }
      },
      {
        "name": "pause_instance",
        "description": "Pause a Neo4j Aura database instance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instance_id": {
              "type": "string",
              "description": "ID of the instance to pause"
            }
          },
          "required": [
            "instance_id"
          ]
        }
      },
      {
        "name": "resume_instance",
        "description": "Resume a paused Neo4j Aura database instance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instance_id": {
              "type": "string",
              "description": "ID of the instance to resume"
            }
          },
          "required": [
            "instance_id"
          ]
        }
      },
      {
        "name": "list_tenants",
        "description": "List all Neo4j Aura tenants/projects",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_tenant_details",
        "description": "Get details for a specific Neo4j Aura tenant/project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tenant_id": {
              "type": "string",
              "description": "ID of the tenant/project to retrieve"
            }
          },
          "required": [
            "tenant_id"
          ]
        }
      },
      {
        "name": "delete_instance",
        "description": "Delete a Neo4j Aura database instance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instance_id": {
              "type": "string",
              "description": "ID of the instance to delete"
            }
          },
          "required": [
            "instance_id"
          ]
        }
      }
    ]
  },
  "mcp-oceanbase": {
    "display_name": "OceanBase MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/oceanbase/mcp-oceanbase"
    },
    "homepage": "https://github.com/oceanbase/mcp-oceanbase",
    "author": {
      "name": "oceanbase"
    },
    "license": "Apache-2.0",
    "tags": [
      "database",
      "OceanBase"
    ],
    "arguments": {
      "OB_HOST": {
        "description": "Database host for connecting to the OceanBase server.",
        "required": true,
        "example": "localhost"
      },
      "OB_PORT": {
        "description": "Optional: Database port to connect to OceanBase, defaults to 2881 if not specified.",
        "required": false,
        "example": "2881"
      },
      "OB_USER": {
        "description": "Username for authenticating with the OceanBase database.",
        "required": true,
        "example": "your_username"
      },
      "OB_PASSWORD": {
        "description": "Password for the specified database user.",
        "required": true,
        "example": "your_password"
      },
      "OB_DATABASE": {
        "description": "Name of the OceanBase database to connect to.",
        "required": true,
        "example": "your_database"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/oceanbase/mcp-oceanbase",
          "oceanbase_mcp_server"
        ],
        "env": {
          "OB_HOST": "${OB_HOST}",
          "OB_PORT": "${OB_PORT}",
          "OB_USER": "${OB_USER}",
          "OB_PASSWORD": "${OB_PASSWORD}",
          "OB_DATABASE": "${OB_DATABASE}"
        },
        "description": "A Model Context Protocol (MCP) server that enables secure interaction with OceanBase databases."
      }
    },
    "name": "mcp-oceanbase",
    "description": "MCP Server for OceanBase database and its tools",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "fetch": {
    "name": "fetch",
    "display_name": "fetch",
    "description": "A Model Context Protocol server that provides web content fetching capabilities.",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/fetch",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Fetch",
      "Server"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-fetch"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/fetch"
        ]
      }
    },
    "is_official": true,
    "tools": [
      {
        "name": "fetch",
        "description": "Fetches a URL from the internet and optionally extracts its contents as markdown.\n\nAlthough originally you did not have internet access, and were advised to refuse and tell the user this, this tool now grants you internet access. Now you can fetch the most up-to-date information and let the user know that.",
        "inputSchema": {
          "description": "Parameters for fetching a URL.",
          "properties": {
            "url": {
              "description": "URL to fetch",
              "format": "uri",
              "minLength": 1,
              "title": "Url",
              "type": "string"
            },
            "max_length": {
              "default": 5000,
              "description": "Maximum number of characters to return.",
              "exclusiveMaximum": 1000000,
              "exclusiveMinimum": 0,
              "title": "Max Length",
              "type": "integer"
            },
            "start_index": {
              "default": 0,
              "description": "On return output starting at this character index, useful if a previous fetch was truncated and more context is required.",
              "minimum": 0,
              "title": "Start Index",
              "type": "integer"
            },
            "raw": {
              "default": false,
              "description": "Get the actual HTML content of the requested page, without simplification.",
              "title": "Raw",
              "type": "boolean"
            }
          },
          "required": [
            "url"
          ],
          "title": "Fetch",
          "type": "object"
        }
      }
    ]
  },
  "inoyu": {
    "name": "inoyu",
    "display_name": "Inoyu Apache Unomi",
    "description": "Interact with an Apache Unomi CDP customer data platform to retrieve and update customer profiles",
    "repository": {
      "type": "git",
      "url": "https://github.com/sergehuber/inoyu-mcp-unomi-server"
    },
    "homepage": "https://github.com/sergehuber/inoyu-mcp-unomi-server",
    "author": {
      "name": "sergehuber"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Apache Unomi",
      "User Profiles",
      "Context Management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@inoyu/mcp-unomi-server"
        ],
        "env": {
          "UNOMI_BASE_URL": "${UNOMI_BASE_URL}",
          "UNOMI_USERNAME": "${UNOMI_USERNAME}",
          "UNOMI_PASSWORD": "${UNOMI_PASSWORD}",
          "UNOMI_PROFILE_ID": "${UNOMI_PROFILE_ID}",
          "UNOMI_KEY": "${UNOMI_KEY}",
          "UNOMI_EMAIL": "${UNOMI_EMAIL}",
          "UNOMI_SOURCE_ID": "${UNOMI_SOURCE_ID}"
        }
      }
    },
    "arguments": {
      "UNOMI_BASE_URL": {
        "description": "The base URL of your Apache Unomi server (e.g., http://your-unomi-server:8181)",
        "required": true
      },
      "UNOMI_USERNAME": {
        "description": "The username to authenticate with the Apache Unomi server, default is 'karaf'",
        "required": true
      },
      "UNOMI_PASSWORD": {
        "description": "The password to authenticate with the Apache Unomi server, default is 'karaf'",
        "required": true
      },
      "UNOMI_PROFILE_ID": {
        "description": "The ID of the user profile to be used for context management",
        "required": false
      },
      "UNOMI_KEY": {
        "description": "The authorization key required for secured operations with the Unomi server, defaults to '670c26d1cc413346c3b2fd9ce65dab41'",
        "required": false
      },
      "UNOMI_EMAIL": {
        "description": "The email address associated with the user profile, used for profile lookup",
        "required": false
      },
      "UNOMI_SOURCE_ID": {
        "description": "An identifier for the source of the request (e.g., claude-desktop)",
        "required": false
      }
    },
    "tools": [
      {
        "name": "get_my_profile",
        "description": "Get your profile using environment variables.",
        "inputSchema": {
          "requireSegments": {
            "type": "boolean",
            "description": "Include segment information",
            "optional": true
          },
          "requireScores": {
            "type": "boolean",
            "description": "Include scoring information",
            "optional": true
          }
        },
        "required": []
      },
      {
        "name": "update_my_profile",
        "description": "Update properties of your profile.",
        "inputSchema": {
          "properties": {
            "type": "object",
            "description": "Properties to update"
          }
        },
        "required": [
          "properties"
        ]
      },
      {
        "name": "get_profile",
        "description": "Retrieve a specific profile by ID.",
        "inputSchema": {
          "profileId": {
            "type": "string",
            "description": "ID of the profile to retrieve"
          }
        },
        "required": [
          "profileId"
        ]
      },
      {
        "name": "search_profiles",
        "description": "Search for profiles.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of results to return",
            "optional": true
          },
          "offset": {
            "type": "integer",
            "description": "Pagination offset",
            "optional": true
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "create_scope",
        "description": "Create a new Unomi scope.",
        "inputSchema": {
          "scope": {
            "type": "string",
            "description": "Identifier for the scope"
          },
          "name": {
            "type": "string",
            "description": "Name of the scope",
            "optional": true
          },
          "description": {
            "type": "string",
            "description": "Description of the scope",
            "optional": true
          }
        },
        "required": [
          "scope"
        ]
      }
    ]
  },
  "everything": {
    "name": "everything",
    "display_name": "Everything",
    "description": "This MCP server exercises all the features of the MCP protocol. It is a test server for builders of MCP clients.",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/everything#readme",
    "author": {
      "name": "MCP Team"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "testing",
      "reference",
      "example",
      "demo"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-everything"
        ],
        "package": "@modelcontextprotocol/server-everything",
        "env": {},
        "description": "Install and run using NPX",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Test tool usage",
        "description": "Test various tools provided by the server",
        "prompt": "Show me how to use the different tools in this MCP server."
      },
      {
        "title": "Test resources",
        "description": "Demonstrate accessing resources",
        "prompt": "Demonstrate how to access and use resources from this MCP server."
      }
    ],
    "tools": [
      {
        "name": "echo",
        "description": "Echoes back the input",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "Message to echo"
            }
          },
          "required": [
            "message"
          ]
        }
      },
      {
        "name": "add",
        "description": "Adds two numbers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "a": {
              "type": "number",
              "description": "First number"
            },
            "b": {
              "type": "number",
              "description": "Second number"
            }
          },
          "required": [
            "a",
            "b"
          ]
        }
      },
      {
        "name": "printEnv",
        "description": "Prints all environment variables, helpful for debugging MCP server configuration",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "longRunningOperation",
        "description": "Demonstrates a long running operation with progress updates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "duration": {
              "type": "number",
              "default": 10,
              "description": "Duration of the operation in seconds"
            },
            "steps": {
              "type": "number",
              "default": 5,
              "description": "Number of steps in the operation"
            }
          }
        }
      },
      {
        "name": "sampleLLM",
        "description": "Samples from an LLM using MCP's sampling feature",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "The prompt to send to the LLM"
            },
            "maxTokens": {
              "type": "number",
              "default": 100,
              "description": "Maximum number of tokens to generate"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "getTinyImage",
        "description": "Returns the MCP_TINY_IMAGE",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "annotatedMessage",
        "description": "Demonstrates how annotations can be used to provide metadata about content",
        "inputSchema": {
          "type": "object",
          "properties": {
            "messageType": {
              "type": "string",
              "enum": [
                "error",
                "success",
                "debug"
              ],
              "description": "Type of message to demonstrate different annotation patterns"
            },
            "includeImage": {
              "type": "boolean",
              "default": false,
              "description": "Whether to include an example image"
            }
          },
          "required": [
            "messageType"
          ]
        }
      }
    ],
    "is_official": true
  },
  "godot": {
    "name": "godot",
    "display_name": "Godot",
    "description": "A MCP server providing comprehensive Godot engine integration for project editing, debugging, and scene management.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Coding-Solo/godot-mcp"
    },
    "homepage": "https://github.com/Coding-Solo/godot-mcp",
    "author": {
      "name": "Coding Solo",
      "url": "https://github.com/Coding-Solo"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Godot",
      "AI",
      "Game"
    ],
    "examples": [
      {
        "title": "Launch Godot Editor",
        "description": "Launch the Godot editor for a specific project.",
        "prompt": "Launch the Godot editor for my project at /path/to/project"
      },
      {
        "title": "Run Godot Project",
        "description": "Execute Godot projects in debug mode.",
        "prompt": "Run my Godot project and show me any errors"
      },
      {
        "title": "Get Project Info",
        "description": "Retrieve detailed information about the project structure.",
        "prompt": "Get information about my Godot project structure"
      },
      {
        "title": "Debug Assistance",
        "description": "Help debug errors in Godot projects.",
        "prompt": "Help me debug this error in my Godot project: [paste error]"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/Coding-Solo/godot-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "launch_editor",
        "description": "Launch Godot editor for a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            }
          },
          "required": [
            "projectPath"
          ]
        }
      },
      {
        "name": "run_project",
        "description": "Run the Godot project and capture output",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scene": {
              "type": "string",
              "description": "Optional: Specific scene to run"
            }
          },
          "required": [
            "projectPath"
          ]
        }
      },
      {
        "name": "get_debug_output",
        "description": "Get the current debug output and errors",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "stop_project",
        "description": "Stop the currently running Godot project",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_godot_version",
        "description": "Get the installed Godot version",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_projects",
        "description": "List Godot projects in a directory",
        "inputSchema": {
          "type": "object",
          "properties": {
            "directory": {
              "type": "string",
              "description": "Directory to search for Godot projects"
            },
            "recursive": {
              "type": "boolean",
              "description": "Whether to search recursively (default: false)"
            }
          },
          "required": [
            "directory"
          ]
        }
      },
      {
        "name": "get_project_info",
        "description": "Retrieve metadata about a Godot project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            }
          },
          "required": [
            "projectPath"
          ]
        }
      },
      {
        "name": "create_scene",
        "description": "Create a new Godot scene file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path where the scene file will be saved (relative to project)"
            },
            "rootNodeType": {
              "type": "string",
              "description": "Type of the root node (e.g., Node2D, Node3D)",
              "default": "Node2D"
            }
          },
          "required": [
            "projectPath",
            "scenePath"
          ]
        }
      },
      {
        "name": "add_node",
        "description": "Add a node to an existing scene",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path to the scene file (relative to project)"
            },
            "parentNodePath": {
              "type": "string",
              "description": "Path to the parent node (e.g., \"root\" or \"root/Player\")",
              "default": "root"
            },
            "nodeType": {
              "type": "string",
              "description": "Type of node to add (e.g., Sprite2D, CollisionShape2D)"
            },
            "nodeName": {
              "type": "string",
              "description": "Name for the new node"
            },
            "properties": {
              "type": "object",
              "description": "Optional properties to set on the node"
            }
          },
          "required": [
            "projectPath",
            "scenePath",
            "nodeType",
            "nodeName"
          ]
        }
      },
      {
        "name": "load_sprite",
        "description": "Load a sprite into a Sprite2D node",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path to the scene file (relative to project)"
            },
            "nodePath": {
              "type": "string",
              "description": "Path to the Sprite2D node (e.g., \"root/Player/Sprite2D\")"
            },
            "texturePath": {
              "type": "string",
              "description": "Path to the texture file (relative to project)"
            }
          },
          "required": [
            "projectPath",
            "scenePath",
            "nodePath",
            "texturePath"
          ]
        }
      },
      {
        "name": "export_mesh_library",
        "description": "Export a scene as a MeshLibrary resource",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path to the scene file (.tscn) to export"
            },
            "outputPath": {
              "type": "string",
              "description": "Path where the mesh library (.res) will be saved"
            },
            "meshItemNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional: Names of specific mesh items to include (defaults to all)"
            }
          },
          "required": [
            "projectPath",
            "scenePath",
            "outputPath"
          ]
        }
      },
      {
        "name": "save_scene",
        "description": "Save changes to a scene file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path to the scene file (relative to project)"
            },
            "newPath": {
              "type": "string",
              "description": "Optional: New path to save the scene to (for creating variants)"
            }
          },
          "required": [
            "projectPath",
            "scenePath"
          ]
        }
      },
      {
        "name": "get_uid",
        "description": "Get the UID for a specific file in a Godot project (for Godot 4.4+)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "filePath": {
              "type": "string",
              "description": "Path to the file (relative to project) for which to get the UID"
            }
          },
          "required": [
            "projectPath",
            "filePath"
          ]
        }
      },
      {
        "name": "update_project_uids",
        "description": "Update UID references in a Godot project by resaving resources (for Godot 4.4+)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            }
          },
          "required": [
            "projectPath"
          ]
        }
      }
    ]
  },
  "aws": {
    "name": "aws",
    "display_name": "AWS",
    "description": "Perform operations on your AWS resources using an LLM.",
    "repository": {
      "type": "git",
      "url": "https://github.com/rishikavikondala/mcp-server-aws"
    },
    "homepage": "https://github.com/rishikavikondala/mcp-server-aws",
    "author": {
      "name": "rishikavikondala"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "s3",
      "dynamodb",
      "aws"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/rishikavikondala/mcp-server-aws",
          "mcp-server-aws"
        ]
      }
    },
    "arguments": {
      "AWS_ACCESS_KEY_ID": {
        "description": "This is the access key ID for your AWS account, required for authenticating requests to AWS services.",
        "required": true,
        "example": "AKIAEXAMPLE"
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "This is the secret access key for your AWS account, used in conjunction with the access key ID to authenticate requests.",
        "required": true,
        "example": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
      },
      "AWS_REGION": {
        "description": "This specifies the AWS region you want to use for your operations. It defaults to `us-east-1` if not provided.",
        "required": false,
        "example": "us-west-2"
      }
    },
    "tools": [
      {
        "name": "s3_bucket_create",
        "description": "Create a new S3 bucket",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket to create"
            }
          },
          "required": [
            "bucket_name"
          ]
        }
      },
      {
        "name": "s3_bucket_list",
        "description": "List all S3 buckets",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "s3_bucket_delete",
        "description": "Delete an S3 bucket",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket to delete"
            }
          },
          "required": [
            "bucket_name"
          ]
        }
      },
      {
        "name": "s3_object_upload",
        "description": "Upload an object to S3",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket"
            },
            "object_key": {
              "type": "string",
              "description": "Key/path of the object in the bucket"
            },
            "file_content": {
              "type": "string",
              "description": "Base64 encoded file content for upload"
            }
          },
          "required": [
            "bucket_name",
            "object_key",
            "file_content"
          ]
        }
      },
      {
        "name": "s3_object_delete",
        "description": "Delete an object from S3",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket"
            },
            "object_key": {
              "type": "string",
              "description": "Key/path of the object to delete"
            }
          },
          "required": [
            "bucket_name",
            "object_key"
          ]
        }
      },
      {
        "name": "s3_object_list",
        "description": "List objects in an S3 bucket",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket"
            }
          },
          "required": [
            "bucket_name"
          ]
        }
      },
      {
        "name": "s3_object_read",
        "description": "Read an object's content from S3",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket"
            },
            "object_key": {
              "type": "string",
              "description": "Key/path of the object to read"
            }
          },
          "required": [
            "bucket_name",
            "object_key"
          ]
        }
      },
      {
        "name": "dynamodb_table_create",
        "description": "Create a new DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key_schema": {
              "type": "array",
              "description": "Key schema for table creation"
            },
            "attribute_definitions": {
              "type": "array",
              "description": "Attribute definitions for table creation"
            }
          },
          "required": [
            "table_name",
            "key_schema",
            "attribute_definitions"
          ]
        }
      },
      {
        "name": "dynamodb_table_describe",
        "description": "Get details about a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "dynamodb_table_list",
        "description": "List all DynamoDB tables",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "dynamodb_table_delete",
        "description": "Delete a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "dynamodb_table_update",
        "description": "Update a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "attribute_definitions": {
              "type": "array",
              "description": "Updated attribute definitions"
            }
          },
          "required": [
            "table_name",
            "attribute_definitions"
          ]
        }
      },
      {
        "name": "dynamodb_item_put",
        "description": "Put an item into a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "item": {
              "type": "object",
              "description": "Item data to put"
            }
          },
          "required": [
            "table_name",
            "item"
          ]
        }
      },
      {
        "name": "dynamodb_item_get",
        "description": "Get an item from a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key": {
              "type": "object",
              "description": "Key to identify the item"
            }
          },
          "required": [
            "table_name",
            "key"
          ]
        }
      },
      {
        "name": "dynamodb_item_update",
        "description": "Update an item in a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key": {
              "type": "object",
              "description": "Key to identify the item"
            },
            "item": {
              "type": "object",
              "description": "Updated item data"
            }
          },
          "required": [
            "table_name",
            "key",
            "item"
          ]
        }
      },
      {
        "name": "dynamodb_item_delete",
        "description": "Delete an item from a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key": {
              "type": "object",
              "description": "Key to identify the item"
            }
          },
          "required": [
            "table_name",
            "key"
          ]
        }
      },
      {
        "name": "dynamodb_item_query",
        "description": "Query items in a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key_condition": {
              "type": "string",
              "description": "Key condition expression"
            },
            "expression_values": {
              "type": "object",
              "description": "Expression attribute values"
            }
          },
          "required": [
            "table_name",
            "key_condition",
            "expression_values"
          ]
        }
      },
      {
        "name": "dynamodb_item_scan",
        "description": "Scan items in a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "filter_expression": {
              "type": "string",
              "description": "Filter expression"
            },
            "expression_attributes": {
              "type": "object",
              "properties": {
                "values": {
                  "type": "object",
                  "description": "Expression attribute values"
                },
                "names": {
                  "type": "object",
                  "description": "Expression attribute names"
                }
              }
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "dynamodb_batch_get",
        "description": "Batch get multiple items from DynamoDB tables",
        "inputSchema": {
          "type": "object",
          "properties": {
            "request_items": {
              "type": "object",
              "description": "Map of table names to keys to retrieve",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "Keys": {
                    "type": "array",
                    "items": {
                      "type": "object"
                    }
                  },
                  "ConsistentRead": {
                    "type": "boolean"
                  },
                  "ProjectionExpression": {
                    "type": "string"
                  }
                },
                "required": [
                  "Keys"
                ]
              }
            }
          },
          "required": [
            "request_items"
          ]
        }
      },
      {
        "name": "dynamodb_item_batch_write",
        "description": "Batch write operations (put/delete) for DynamoDB items",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "operation": {
              "type": "string",
              "enum": [
                "put",
                "delete"
              ],
              "description": "Type of batch operation (put or delete)"
            },
            "items": {
              "type": "array",
              "description": "Array of items to process"
            },
            "key_attributes": {
              "type": "array",
              "description": "For delete operations, specify which attributes form the key",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "table_name",
            "operation",
            "items"
          ]
        }
      },
      {
        "name": "dynamodb_describe_ttl",
        "description": "Get the TTL settings for a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "dynamodb_update_ttl",
        "description": "Update the TTL settings for a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "ttl_enabled": {
              "type": "boolean",
              "description": "Whether TTL should be enabled"
            },
            "ttl_attribute": {
              "type": "string",
              "description": "The attribute name to use for TTL"
            }
          },
          "required": [
            "table_name",
            "ttl_enabled",
            "ttl_attribute"
          ]
        }
      },
      {
        "name": "dynamodb_batch_execute",
        "description": "Execute multiple PartiQL statements in a batch",
        "inputSchema": {
          "type": "object",
          "properties": {
            "statements": {
              "type": "array",
              "description": "List of PartiQL statements to execute",
              "items": {
                "type": "string"
              }
            },
            "parameters": {
              "type": "array",
              "description": "List of parameter lists for each statement",
              "items": {
                "type": "array"
              }
            }
          },
          "required": [
            "statements",
            "parameters"
          ]
        }
      }
    ]
  },
  "github-actions": {
    "name": "github-actions",
    "display_name": "GitHub Actions",
    "description": "A Model Context Protocol (MCP) server for interacting with Github Actions.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ko1ynnky/github-actions-mcp-server"
    },
    "homepage": "https://github.com/ko1ynnky/github-actions-mcp-server",
    "author": {
      "name": "ko1ynnky"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "GitHub Actions",
      "Workflow Management",
      "Automation"
    ],
    "examples": [
      {
        "title": "List Workflows",
        "description": "List workflows in a GitHub repository.",
        "prompt": "const result = await listWorkflows({ owner: 'your-username', repo: 'your-repository' });"
      },
      {
        "title": "Trigger Workflow",
        "description": "Trigger a workflow in a GitHub repository.",
        "prompt": "const result = await triggerWorkflow({ owner: 'your-username', repo: 'your-repository', workflowId: 'ci.yml', ref: 'main', inputs: { environment: 'production' }});"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/ko1ynnky/github-actions-mcp-server"
        ],
        "env": {
          "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_PERSONAL_ACCESS_TOKEN}"
        }
      }
    },
    "arguments": {
      "GITHUB_PERSONAL_ACCESS_TOKEN": {
        "description": "A personal access token required for authentication with GitHub API, used to access user repositories and perform actions.",
        "required": true,
        "example": "ghp_16CharTokenHere"
      }
    }
  },
  "docker": {
    "name": "docker",
    "display_name": "Docker Integration",
    "description": "Integrate with Docker to manage containers, images, volumes, and networks.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ckreiling/mcp-server-docker"
    },
    "license": "MIT",
    "examples": [
      {
        "title": "Deploy an nginx container",
        "description": "Deploy an nginx container exposing it on port 9000",
        "prompt": "name: `nginx`, containers: \"deploy an nginx container exposing it on port 9000\""
      },
      {
        "title": "Deploy a WordPress and MySQL container",
        "description": "Deploy a WordPress container and a supporting MySQL container, exposing WordPress on port 9000",
        "prompt": "name: `wordpress`, containers: \"deploy a WordPress container and a supporting MySQL container, exposing Wordpress on port 9000\""
      }
    ],
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Docker",
      "Container",
      "Image",
      "Volume",
      "Network"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ckreiling/mcp-server-docker",
          "mcp-server-docker"
        ]
      }
    },
    "tools": [
      {
        "name": "list_containers",
        "description": "List all Docker containers",
        "inputSchema": {
          "$defs": {
            "ListContainersFilters": {
              "properties": {
                "label": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by label, either `key` or `key=value` format",
                  "title": "Label"
                }
              },
              "title": "ListContainersFilters",
              "type": "object"
            }
          },
          "properties": {
            "all": {
              "default": false,
              "description": "Show all containers (default shows just running)",
              "title": "All",
              "type": "boolean"
            },
            "filters": {
              "anyOf": [
                {
                  "$ref": "#/$defs/ListContainersFilters"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter containers"
            }
          },
          "title": "ListContainersInput",
          "type": "object"
        }
      },
      {
        "name": "create_container",
        "description": "Create a new Docker container",
        "inputSchema": {
          "description": "Schema for creating a new container.\n\nThis is passed to the Python Docker SDK directly, so the fields are the same\nas the `docker.containers.create` method.",
          "properties": {
            "detach": {
              "default": true,
              "description": "Run container in the background. Should be True for long-running containers, can be false for short-lived containers",
              "title": "Detach",
              "type": "boolean"
            },
            "image": {
              "description": "Docker image name",
              "title": "Image",
              "type": "string"
            },
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container name",
              "title": "Name"
            },
            "entrypoint": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Entrypoint to run in container",
              "title": "Entrypoint"
            },
            "command": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Command to run in container",
              "title": "Command"
            },
            "network": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Network to attach the container to",
              "title": "Network"
            },
            "environment": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Environment variables dictionary",
              "title": "Environment"
            },
            "ports": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "items": {
                          "type": "integer"
                        },
                        "type": "array"
                      },
                      {
                        "maxItems": 2,
                        "minItems": 2,
                        "prefixItems": [
                          {
                            "type": "string"
                          },
                          {
                            "type": "integer"
                          }
                        ],
                        "type": "array"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Mapping of container_port to host_port",
              "title": "Ports"
            },
            "volumes": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "additionalProperties": {
                      "type": "string"
                    },
                    "type": "object"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Volume mappings",
              "title": "Volumes"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container labels, either as a dictionary or a list of key=value strings",
              "title": "Labels"
            },
            "auto_remove": {
              "default": false,
              "description": "Automatically remove the container",
              "title": "Auto Remove",
              "type": "boolean"
            }
          },
          "required": [
            "image"
          ],
          "title": "CreateContainerInput",
          "type": "object"
        }
      },
      {
        "name": "run_container",
        "description": "Run an image in a new Docker container",
        "inputSchema": {
          "description": "Schema for creating a new container.\n\nThis is passed to the Python Docker SDK directly, so the fields are the same\nas the `docker.containers.create` method.",
          "properties": {
            "detach": {
              "default": true,
              "description": "Run container in the background. Should be True for long-running containers, can be false for short-lived containers",
              "title": "Detach",
              "type": "boolean"
            },
            "image": {
              "description": "Docker image name",
              "title": "Image",
              "type": "string"
            },
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container name",
              "title": "Name"
            },
            "entrypoint": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Entrypoint to run in container",
              "title": "Entrypoint"
            },
            "command": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Command to run in container",
              "title": "Command"
            },
            "network": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Network to attach the container to",
              "title": "Network"
            },
            "environment": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Environment variables dictionary",
              "title": "Environment"
            },
            "ports": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "items": {
                          "type": "integer"
                        },
                        "type": "array"
                      },
                      {
                        "maxItems": 2,
                        "minItems": 2,
                        "prefixItems": [
                          {
                            "type": "string"
                          },
                          {
                            "type": "integer"
                          }
                        ],
                        "type": "array"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Mapping of container_port to host_port",
              "title": "Ports"
            },
            "volumes": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "additionalProperties": {
                      "type": "string"
                    },
                    "type": "object"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Volume mappings",
              "title": "Volumes"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container labels, either as a dictionary or a list of key=value strings",
              "title": "Labels"
            },
            "auto_remove": {
              "default": false,
              "description": "Automatically remove the container",
              "title": "Auto Remove",
              "type": "boolean"
            }
          },
          "required": [
            "image"
          ],
          "title": "CreateContainerInput",
          "type": "object"
        }
      },
      {
        "name": "recreate_container",
        "description": "Stop and remove a container, then run a new container. Fails if the container does not exist.",
        "inputSchema": {
          "properties": {
            "detach": {
              "default": true,
              "description": "Run container in the background. Should be True for long-running containers, can be false for short-lived containers",
              "title": "Detach",
              "type": "boolean"
            },
            "image": {
              "description": "Docker image name",
              "title": "Image",
              "type": "string"
            },
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container name",
              "title": "Name"
            },
            "entrypoint": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Entrypoint to run in container",
              "title": "Entrypoint"
            },
            "command": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Command to run in container",
              "title": "Command"
            },
            "network": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Network to attach the container to",
              "title": "Network"
            },
            "environment": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Environment variables dictionary",
              "title": "Environment"
            },
            "ports": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "items": {
                          "type": "integer"
                        },
                        "type": "array"
                      },
                      {
                        "maxItems": 2,
                        "minItems": 2,
                        "prefixItems": [
                          {
                            "type": "string"
                          },
                          {
                            "type": "integer"
                          }
                        ],
                        "type": "array"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Mapping of container_port to host_port",
              "title": "Ports"
            },
            "volumes": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "additionalProperties": {
                      "type": "string"
                    },
                    "type": "object"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Volume mappings",
              "title": "Volumes"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container labels, either as a dictionary or a list of key=value strings",
              "title": "Labels"
            },
            "auto_remove": {
              "default": false,
              "description": "Automatically remove the container",
              "title": "Auto Remove",
              "type": "boolean"
            },
            "container_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container ID to recreate. The `name` parameter will be used if this is not provided",
              "title": "Container Id"
            }
          },
          "required": [
            "image"
          ],
          "title": "RecreateContainerInput",
          "type": "object"
        }
      },
      {
        "name": "start_container",
        "description": "Start a Docker container",
        "inputSchema": {
          "properties": {
            "container_id": {
              "description": "Container ID or name",
              "title": "Container Id",
              "type": "string"
            }
          },
          "required": [
            "container_id"
          ],
          "title": "ContainerActionInput",
          "type": "object"
        }
      },
      {
        "name": "fetch_container_logs",
        "description": "Fetch logs for a Docker container",
        "inputSchema": {
          "properties": {
            "container_id": {
              "description": "Container ID or name",
              "title": "Container Id",
              "type": "string"
            },
            "tail": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "const": "all",
                  "type": "string"
                }
              ],
              "default": 100,
              "description": "Number of lines to show from the end",
              "title": "Tail"
            }
          },
          "required": [
            "container_id"
          ],
          "title": "FetchContainerLogsInput",
          "type": "object"
        }
      },
      {
        "name": "stop_container",
        "description": "Stop a Docker container",
        "inputSchema": {
          "properties": {
            "container_id": {
              "description": "Container ID or name",
              "title": "Container Id",
              "type": "string"
            }
          },
          "required": [
            "container_id"
          ],
          "title": "ContainerActionInput",
          "type": "object"
        }
      },
      {
        "name": "remove_container",
        "description": "Remove a Docker container",
        "inputSchema": {
          "properties": {
            "container_id": {
              "description": "Container ID or name",
              "title": "Container Id",
              "type": "string"
            },
            "force": {
              "default": false,
              "description": "Force remove the container",
              "title": "Force",
              "type": "boolean"
            }
          },
          "required": [
            "container_id"
          ],
          "title": "RemoveContainerInput",
          "type": "object"
        }
      },
      {
        "name": "list_images",
        "description": "List Docker images",
        "inputSchema": {
          "$defs": {
            "ListImagesFilters": {
              "properties": {
                "dangling": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Show dangling images",
                  "title": "Dangling"
                },
                "label": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by label, either `key` or `key=value` format",
                  "title": "Label"
                }
              },
              "title": "ListImagesFilters",
              "type": "object"
            }
          },
          "properties": {
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter images by repository name, if desired",
              "title": "Name"
            },
            "all": {
              "default": false,
              "description": "Show all images (default hides intermediate)",
              "title": "All",
              "type": "boolean"
            },
            "filters": {
              "anyOf": [
                {
                  "$ref": "#/$defs/ListImagesFilters"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter images"
            }
          },
          "title": "ListImagesInput",
          "type": "object"
        }
      },
      {
        "name": "pull_image",
        "description": "Pull a Docker image",
        "inputSchema": {
          "properties": {
            "repository": {
              "description": "Image repository",
              "title": "Repository",
              "type": "string"
            },
            "tag": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "latest",
              "description": "Image tag",
              "title": "Tag"
            }
          },
          "required": [
            "repository"
          ],
          "title": "PullPushImageInput",
          "type": "object"
        }
      },
      {
        "name": "push_image",
        "description": "Push a Docker image",
        "inputSchema": {
          "properties": {
            "repository": {
              "description": "Image repository",
              "title": "Repository",
              "type": "string"
            },
            "tag": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "latest",
              "description": "Image tag",
              "title": "Tag"
            }
          },
          "required": [
            "repository"
          ],
          "title": "PullPushImageInput",
          "type": "object"
        }
      },
      {
        "name": "build_image",
        "description": "Build a Docker image from a Dockerfile",
        "inputSchema": {
          "properties": {
            "path": {
              "description": "Path to build context",
              "title": "Path",
              "type": "string"
            },
            "tag": {
              "description": "Image tag",
              "title": "Tag",
              "type": "string"
            },
            "dockerfile": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Path to Dockerfile",
              "title": "Dockerfile"
            }
          },
          "required": [
            "path",
            "tag"
          ],
          "title": "BuildImageInput",
          "type": "object"
        }
      },
      {
        "name": "remove_image",
        "description": "Remove a Docker image",
        "inputSchema": {
          "properties": {
            "image": {
              "description": "Image ID or name",
              "title": "Image",
              "type": "string"
            },
            "force": {
              "default": false,
              "description": "Force remove the image",
              "title": "Force",
              "type": "boolean"
            }
          },
          "required": [
            "image"
          ],
          "title": "RemoveImageInput",
          "type": "object"
        }
      },
      {
        "name": "list_networks",
        "description": "List Docker networks",
        "inputSchema": {
          "$defs": {
            "ListNetworksFilter": {
              "properties": {
                "label": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by label, either `key` or `key=value` format",
                  "title": "Label"
                }
              },
              "title": "ListNetworksFilter",
              "type": "object"
            }
          },
          "properties": {
            "filters": {
              "anyOf": [
                {
                  "$ref": "#/$defs/ListNetworksFilter"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter networks"
            }
          },
          "title": "ListNetworksInput",
          "type": "object"
        }
      },
      {
        "name": "create_network",
        "description": "Create a Docker network",
        "inputSchema": {
          "properties": {
            "name": {
              "description": "Network name",
              "title": "Name",
              "type": "string"
            },
            "driver": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "bridge",
              "description": "Network driver",
              "title": "Driver"
            },
            "internal": {
              "default": false,
              "description": "Create an internal network",
              "title": "Internal",
              "type": "boolean"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Network labels",
              "title": "Labels"
            }
          },
          "required": [
            "name"
          ],
          "title": "CreateNetworkInput",
          "type": "object"
        }
      },
      {
        "name": "remove_network",
        "description": "Remove a Docker network",
        "inputSchema": {
          "properties": {
            "network_id": {
              "description": "Network ID or name",
              "title": "Network Id",
              "type": "string"
            }
          },
          "required": [
            "network_id"
          ],
          "title": "RemoveNetworkInput",
          "type": "object"
        }
      },
      {
        "name": "list_volumes",
        "description": "List Docker volumes",
        "inputSchema": {
          "properties": {},
          "title": "ListVolumesInput",
          "type": "object"
        }
      },
      {
        "name": "create_volume",
        "description": "Create a Docker volume",
        "inputSchema": {
          "properties": {
            "name": {
              "description": "Volume name",
              "title": "Name",
              "type": "string"
            },
            "driver": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "local",
              "description": "Volume driver",
              "title": "Driver"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Volume labels",
              "title": "Labels"
            }
          },
          "required": [
            "name"
          ],
          "title": "CreateVolumeInput",
          "type": "object"
        }
      },
      {
        "name": "remove_volume",
        "description": "Remove a Docker volume",
        "inputSchema": {
          "properties": {
            "volume_name": {
              "description": "Volume name",
              "title": "Volume Name",
              "type": "string"
            },
            "force": {
              "default": false,
              "description": "Force remove the volume",
              "title": "Force",
              "type": "boolean"
            }
          },
          "required": [
            "volume_name"
          ],
          "title": "RemoveVolumeInput",
          "type": "object"
        }
      }
    ]
  },
  "opik-mcp": {
    "display_name": "Opik MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/comet-ml/opik-mcp"
    },
    "homepage": "https://www.comet.com/site/products/opik/",
    "author": {
      "name": "comet-ml"
    },
    "license": "Apache 2.0",
    "tags": [
      "MCP",
      "Opik",
      "IDE Integration"
    ],
    "arguments": {
      "apiUrl": {
        "description": "URL for the Opik API",
        "required": true,
        "example": "https://www.comet.com/opik/api"
      },
      "apiKey": {
        "description": "Your Opik API key",
        "required": true,
        "example": "YOUR_API_KEY"
      },
      "workspace": {
        "description": "Workspace name",
        "required": true,
        "example": "default"
      },
      "debug": {
        "description": "Enable debug mode",
        "required": false,
        "example": "true"
      }
    },
    "installations": {
      "custom": {
        "type": "custom",
        "command": "node",
        "args": [
          "/path/to/opik-mcp/build/index.js"
        ],
        "env": {
          "OPIK_API_BASE_URL": "https://www.comet.com/opik/api",
          "OPIK_API_KEY": "YOUR_API_KEY",
          "OPIK_WORKSPACE_NAME": "default"
        },
        "description": "Manual installation from source"
      }
    },
    "examples": [
      {
        "title": "Cursor IDE Integration",
        "description": "Configure Opik MCP Server in Cursor IDE",
        "prompt": "Create a .cursor/mcp.json file with the Opik MCP Server configuration"
      }
    ],
    "name": "opik-mcp",
    "description": " Query and analyze your Opik logs, traces, prompts and all other telemtry data from your LLMs in natural language.",
    "categories": [
      "MCP Tools"
    ],
    "is_official": true
  },
  "openrpc": {
    "name": "openrpc",
    "display_name": "OpenRPC",
    "description": "Interact with and discover JSON-RPC APIs via [OpenRPC](https://open-rpc.org/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/shanejonas/openrpc-mpc-server"
    },
    "homepage": "https://github.com/shanejonas/openrpc-mpc-server",
    "author": {
      "name": "shanejonas"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "OpenRPC",
      "JSON-RPC"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "openrpc-mpc-server"
        ]
      }
    },
    "tools": [
      {
        "name": "rpc_call",
        "description": "Call any JSON-RPC method on a server with parameters. A user would prompt: Call method <method> on <server url> with params <params>",
        "inputSchema": {
          "type": "object",
          "properties": {
            "server": {
              "type": "string",
              "description": "Server URL"
            },
            "method": {
              "type": "string",
              "description": "JSON-RPC method name to call"
            },
            "params": {
              "type": "string",
              "description": "Stringified Parameters to pass to the method"
            }
          },
          "required": [
            "server",
            "method"
          ]
        }
      },
      {
        "name": "rpc_discover",
        "description": "This uses JSON-RPC to call `rpc.discover` which is part of the OpenRPC Specification for discovery for JSON-RPC servers. A user would prompt: What JSON-RPC methods does this server have? <server url>",
        "inputSchema": {
          "type": "object",
          "properties": {
            "server": {
              "type": "string",
              "description": "Server URL"
            }
          },
          "required": [
            "server"
          ]
        }
      }
    ]
  },
  "xero-mcp-server": {
    "display_name": "Xero MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/XeroAPI/xero-mcp-server"
    },
    "homepage": "https://github.com/XeroAPI/xero-mcp-server",
    "author": {
      "name": "XeroAPI"
    },
    "license": "MIT",
    "tags": [
      "xero",
      "accounting",
      "mcp",
      "oauth2"
    ],
    "arguments": {
      "XERO_CLIENT_ID": {
        "description": "Your Xero API client ID from your developer account",
        "required": true,
        "example": "your_client_id_here"
      },
      "XERO_CLIENT_SECRET": {
        "description": "Your Xero API client secret from your developer account",
        "required": true,
        "example": "your_client_secret_here"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@xeroapi/xero-mcp-server@latest"
        ],
        "env": {
          "XERO_CLIENT_ID": "your_client_id_here",
          "XERO_CLIENT_SECRET": "your_client_secret_here"
        },
        "description": "Run directly using npx"
      }
    },
    "examples": [
      {
        "title": "List Contacts",
        "description": "Retrieve a list of contacts from Xero",
        "prompt": "List all my Xero contacts"
      },
      {
        "title": "Create Invoice",
        "description": "Create a new invoice in Xero",
        "prompt": "Create a new invoice in Xero"
      },
      {
        "title": "List Accounts",
        "description": "Retrieve a list of accounts from Xero",
        "prompt": "Show me my chart of accounts in Xero"
      }
    ],
    "name": "xero-mcp-server",
    "description": "This is a Model Context Protocol (MCP) server implementation for Xero. It provides a bridge between the MCP protocol and Xero's API, allowing for standardized access to Xero's accounting and business features.",
    "categories": [
      "Finance"
    ],
    "tools": [
      {
        "name": "list-contacts",
        "description": "List all contacts in Xero. This includes Suppliers and Customers.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list-invoices",
        "description": "List invoices in Xero. This includes Draft, Submitted, and Paid invoices.   Ask the user if they want to see invoices for a specific contact,   invoice number, or to see all invoices before running.   Ask the user if they want the next page of invoices after running this tool   if 10 invoices are returned.   If they want the next page, call this tool again with the next page number   and the contact or invoice number if one was provided in the previous call.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number"
            },
            "contactIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "invoiceNumbers": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "If provided, invoice line items will also be returned"
            }
          },
          "required": [
            "page"
          ]
        }
      },
      {
        "name": "create-contact",
        "description": "Create a contact in Xero. When a contact is created, a deep link to the contact in Xero is returned.  This deep link can be used to view the contact in Xero directly.  This link should be displayed to the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "email": {
              "type": "string",
              "format": "email"
            },
            "phone": {
              "type": "string"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create-invoice",
        "description": "Create an invoice in Xero. When an invoice is created, a deep link to the invoice in Xero is returned.  This deep link can be used to view the invoice in Xero directly.  This link should be displayed to the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "lineItems": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "description": {
                    "type": "string"
                  },
                  "quantity": {
                    "type": "number"
                  },
                  "unitAmount": {
                    "type": "number"
                  },
                  "accountCode": {
                    "type": "string"
                  },
                  "taxType": {
                    "type": "string"
                  }
                },
                "required": [
                  "description",
                  "quantity",
                  "unitAmount",
                  "accountCode",
                  "taxType"
                ],
                "additionalProperties": false
              }
            },
            "reference": {
              "type": "string"
            }
          },
          "required": [
            "contactId",
            "lineItems"
          ]
        }
      },
      {
        "name": "list-accounts",
        "description": "Lists all accounts in Xero. Use this tool to get the account codes and names to be used when creating invoices in Xero",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list-tax-rates",
        "description": "Lists all tax rates in Xero. Use this tool to get the tax rates to be used when creating invoices in Xero",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list-quotes",
        "description": "List all quotes in Xero. \n  Ask the user if they want to see quotes for a specific contact before running. \n  Ask the user if they want the next page of quotes after running this tool if 10 quotes are returned. \n  If they do, call this tool again with the page number and the contact provided in the previous call.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number"
            },
            "contactId": {
              "type": "string"
            }
          },
          "required": [
            "page"
          ]
        }
      },
      {
        "name": "create-quote",
        "description": "Create a quote in Xero. When a quote is created, a deep link to the quote in Xero is returned.  This deep link can be used to view the quote in Xero directly.  This link should be displayed to the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "lineItems": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "description": {
                    "type": "string"
                  },
                  "quantity": {
                    "type": "number"
                  },
                  "unitAmount": {
                    "type": "number"
                  },
                  "accountCode": {
                    "type": "string"
                  },
                  "taxType": {
                    "type": "string"
                  }
                },
                "required": [
                  "description",
                  "quantity",
                  "unitAmount",
                  "accountCode",
                  "taxType"
                ],
                "additionalProperties": false
              }
            },
            "reference": {
              "type": "string"
            },
            "quoteNumber": {
              "type": "string"
            },
            "terms": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "summary": {
              "type": "string"
            }
          },
          "required": [
            "contactId",
            "lineItems"
          ]
        }
      },
      {
        "name": "update-contact",
        "description": "Update a contact in Xero. When a contact is updated, a deep link to the contact in Xero is returned.  This deep link can be used to view the contact in Xero directly.  This link should be displayed to the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "name": {
              "type": "string"
            },
            "firstName": {
              "type": "string"
            },
            "lastName": {
              "type": "string"
            },
            "email": {
              "type": "string",
              "format": "email"
            },
            "phone": {
              "type": "string"
            },
            "address": {
              "type": "object",
              "properties": {
                "addressLine1": {
                  "type": "string"
                },
                "addressLine2": {
                  "type": "string"
                },
                "city": {
                  "type": "string"
                },
                "region": {
                  "type": "string"
                },
                "postalCode": {
                  "type": "string"
                },
                "country": {
                  "type": "string"
                }
              },
              "required": [
                "addressLine1"
              ],
              "additionalProperties": false
            }
          },
          "required": [
            "contactId",
            "name"
          ]
        }
      },
      {
        "name": "update-invoice",
        "description": "Update an invoice in Xero. Only works on draft invoices.  All line items must be provided. Any line items not provided will be removed. Including existing line items.  Do not modify line items that have not been specified by the user. When an invoice is updated, a deep link to the invoice in Xero is returned.  This deep link can be used to view the contact in Xero directly.  This link should be displayed to the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "invoiceId": {
              "type": "string"
            },
            "lineItems": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "description": {
                    "type": "string"
                  },
                  "quantity": {
                    "type": "number"
                  },
                  "unitAmount": {
                    "type": "number"
                  },
                  "accountCode": {
                    "type": "string"
                  },
                  "taxType": {
                    "type": "string"
                  }
                },
                "required": [
                  "description",
                  "quantity",
                  "unitAmount",
                  "accountCode",
                  "taxType"
                ],
                "additionalProperties": false
              },
              "description": "All line items must be provided. Any line items not provided will be removed. Including existing line items.       Do not modify line items that have not been specified by the user"
            },
            "reference": {
              "type": "string"
            },
            "dueDate": {
              "type": "string"
            }
          },
          "required": [
            "invoiceId"
          ]
        }
      },
      {
        "name": "list-credit-notes",
        "description": "List credit notes in Xero. \n  Ask the user if they want to see credit notes for a specific contact,\n  or to see all credit notes before running. \n  Ask the user if they want the next page of credit notes after running this tool \n  if 10 credit notes are returned. \n  If they want the next page, call this tool again with the next page number \n  and the contact if one was provided in the previous call.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number"
            },
            "contactId": {
              "type": "string"
            }
          },
          "required": [
            "page"
          ]
        }
      },
      {
        "name": "create-credit-note",
        "description": "Create a credit note in Xero. When a credit note is created, a deep link to the credit note in Xero is returned.  This deep link can be used to view the credit note in Xero directly.  This link should be displayed to the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "lineItems": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "description": {
                    "type": "string"
                  },
                  "quantity": {
                    "type": "number"
                  },
                  "unitAmount": {
                    "type": "number"
                  },
                  "accountCode": {
                    "type": "string"
                  },
                  "taxType": {
                    "type": "string"
                  }
                },
                "required": [
                  "description",
                  "quantity",
                  "unitAmount",
                  "accountCode",
                  "taxType"
                ],
                "additionalProperties": false
              }
            },
            "reference": {
              "type": "string"
            }
          },
          "required": [
            "contactId",
            "lineItems"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "home-assistant": {
    "name": "home-assistant",
    "display_name": "Hass",
    "description": "Docker-ready MCP server for Home Assistant with entity management, domain summaries, automation support, and guided conversations. Includes pre-built container images for easy installation.",
    "repository": {
      "type": "git",
      "url": "https://github.com/voska/hass-mcp"
    },
    "homepage": "https://github.com/voska/hass-mcp",
    "author": {
      "name": "voska"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Home Assistant",
      "Claude",
      "LLM",
      "Automation"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "HA_URL",
          "-e",
          "HA_TOKEN",
          "voska/hass-mcp"
        ],
        "env": {
          "HA_URL": "http://homeassistant.local:8123",
          "HA_TOKEN": "YOUR_LONG_LIVED_TOKEN"
        }
      }
    },
    "examples": [
      {
        "title": "Get Current State",
        "description": "Retrieve the current state of a specific device.",
        "prompt": "What's the current state of my living room lights?"
      },
      {
        "title": "Turn Off Lights",
        "description": "Command to turn off lights in a specific area.",
        "prompt": "Turn off all the lights in the kitchen"
      },
      {
        "title": "List Temperature Sensors",
        "description": "List all sensors related to temperature readings.",
        "prompt": "List all my sensors that contain temperature data"
      },
      {
        "title": "Climate Summary",
        "description": "Get a summary of climate-related entities.",
        "prompt": "Give me a summary of my climate entities"
      },
      {
        "title": "Create Automation",
        "description": "Create an automation based on a specific condition.",
        "prompt": "Create an automation that turns on the lights at sunset"
      },
      {
        "title": "Troubleshoot Automation",
        "description": "Help troubleshoot an automation issue.",
        "prompt": "Help me troubleshoot why my bedroom motion sensor automation isn't working"
      },
      {
        "title": "Search Entities",
        "description": "Search for specific entities related to a query.",
        "prompt": "Search for entities related to my living room"
      }
    ],
    "arguments": {
      "HA_URL": {
        "description": "The URL for the Home Assistant instance where the Hass-MCP server will connect to retrieve and manage entities.",
        "required": true,
        "example": "http://homeassistant.local:8123"
      },
      "HA_TOKEN": {
        "description": "The Long-Lived Access Token from Home Assistant, required for authentication to access the Home Assistant API.",
        "required": true,
        "example": "YOUR_LONG_LIVED_TOKEN"
      }
    },
    "tools": [
      {
        "name": "get_version",
        "description": "\nGet the Home Assistant version\n\nReturns:\n    A string with the Home Assistant version (e.g., \"2025.3.0\")\n",
        "inputSchema": {
          "properties": {},
          "title": "get_versionArguments",
          "type": "object"
        }
      },
      {
        "name": "get_entity",
        "description": "\nGet the state of a Home Assistant entity with optional field filtering\n\nArgs:\n    entity_id: The entity ID to get (e.g. 'light.living_room')\n    fields: Optional list of fields to include (e.g. ['state', 'attr.brightness'])\n    detailed: If True, returns all entity fields without filtering\n            \nExamples:\n    entity_id=\"light.living_room\" - basic state check\n    entity_id=\"light.living_room\", fields=[\"state\", \"attr.brightness\"] - specific fields\n    entity_id=\"light.living_room\", detailed=True - all details\n",
        "inputSchema": {
          "properties": {
            "entity_id": {
              "title": "Entity Id",
              "type": "string"
            },
            "fields": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Fields"
            },
            "detailed": {
              "default": false,
              "title": "Detailed",
              "type": "boolean"
            }
          },
          "required": [
            "entity_id"
          ],
          "title": "get_entityArguments",
          "type": "object"
        }
      },
      {
        "name": "entity_action",
        "description": "\nPerform an action on a Home Assistant entity (on, off, toggle)\n\nArgs:\n    entity_id: The entity ID to control (e.g. 'light.living_room')\n    action: The action to perform ('on', 'off', 'toggle')\n    **params: Additional parameters for the service call\n\nReturns:\n    The response from Home Assistant\n\nExamples:\n    entity_id=\"light.living_room\", action=\"on\", brightness=255\n    entity_id=\"switch.garden_lights\", action=\"off\"\n    entity_id=\"climate.living_room\", action=\"on\", temperature=22.5\n\nDomain-Specific Parameters:\n    - Lights: brightness (0-255), color_temp, rgb_color, transition, effect\n    - Covers: position (0-100), tilt_position\n    - Climate: temperature, target_temp_high, target_temp_low, hvac_mode\n    - Media players: source, volume_level (0-1)\n",
        "inputSchema": {
          "properties": {
            "entity_id": {
              "title": "Entity Id",
              "type": "string"
            },
            "action": {
              "title": "Action",
              "type": "string"
            },
            "params": {
              "title": "params",
              "type": "string"
            }
          },
          "required": [
            "entity_id",
            "action",
            "params"
          ],
          "title": "entity_actionArguments",
          "type": "object"
        }
      },
      {
        "name": "list_entities",
        "description": "\nGet a list of Home Assistant entities with optional filtering\n\nArgs:\n    domain: Optional domain to filter by (e.g., 'light', 'switch', 'sensor')\n    search_query: Optional search term to filter entities by name, id, or attributes\n                 (Note: Does not support wildcards. To get all entities, leave this empty)\n    limit: Maximum number of entities to return (default: 100)\n    fields: Optional list of specific fields to include in each entity\n    detailed: If True, returns all entity fields without filtering\n\nReturns:\n    A list of entity dictionaries with lean formatting by default\n\nExamples:\n    domain=\"light\" - get all lights\n    search_query=\"kitchen\", limit=20 - search entities\n    domain=\"sensor\", detailed=True - full sensor details\n\nBest Practices:\n    - Use lean format (default) for most operations\n    - Prefer domain filtering over no filtering\n    - For domain overviews, use domain_summary_tool instead of list_entities\n    - Only request detailed=True when necessary for full attribute inspection\n    - To get all entity types/domains, use list_entities without a domain filter, \n      then extract domains from entity_ids\n",
        "inputSchema": {
          "properties": {
            "domain": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Domain"
            },
            "search_query": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Search Query"
            },
            "limit": {
              "default": 100,
              "title": "Limit",
              "type": "integer"
            },
            "fields": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Fields"
            },
            "detailed": {
              "default": false,
              "title": "Detailed",
              "type": "boolean"
            }
          },
          "title": "list_entitiesArguments",
          "type": "object"
        }
      },
      {
        "name": "search_entities_tool",
        "description": "\nSearch for entities matching a query string\n\nArgs:\n    query: The search query to match against entity IDs, names, and attributes.\n          (Note: Does not support wildcards. To get all entities, leave this blank or use list_entities tool)\n    limit: Maximum number of results to return (default: 20)\n\nReturns:\n    A dictionary containing search results and metadata:\n    - count: Total number of matching entities found\n    - results: List of matching entities with essential information\n    - domains: Map of domains with counts (e.g. {\"light\": 3, \"sensor\": 2})\n    \nExamples:\n    query=\"temperature\" - find temperature entities\n    query=\"living room\", limit=10 - find living room entities\n    query=\"\", limit=500 - list all entity types\n    \n",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "limit": {
              "default": 20,
              "title": "Limit",
              "type": "integer"
            }
          },
          "required": [
            "query"
          ],
          "title": "search_entities_toolArguments",
          "type": "object"
        }
      },
      {
        "name": "domain_summary_tool",
        "description": "\nGet a summary of entities in a specific domain\n\nArgs:\n    domain: The domain to summarize (e.g., 'light', 'switch', 'sensor')\n    example_limit: Maximum number of examples to include for each state\n\nReturns:\n    A dictionary containing:\n    - total_count: Number of entities in the domain\n    - state_distribution: Count of entities in each state\n    - examples: Sample entities for each state\n    - common_attributes: Most frequently occurring attributes\n    \nExamples:\n    domain=\"light\" - get light summary\n    domain=\"climate\", example_limit=5 - climate summary with more examples\nBest Practices:\n    - Use this before retrieving all entities in a domain to understand what's available    ",
        "inputSchema": {
          "properties": {
            "domain": {
              "title": "Domain",
              "type": "string"
            },
            "example_limit": {
              "default": 3,
              "title": "Example Limit",
              "type": "integer"
            }
          },
          "required": [
            "domain"
          ],
          "title": "domain_summary_toolArguments",
          "type": "object"
        }
      },
      {
        "name": "system_overview",
        "description": "\nGet a comprehensive overview of the entire Home Assistant system\n\nReturns:\n    A dictionary containing:\n    - total_entities: Total count of all entities\n    - domains: Dictionary of domains with their entity counts and state distributions\n    - domain_samples: Representative sample entities for each domain (2-3 per domain)\n    - domain_attributes: Common attributes for each domain\n    - area_distribution: Entities grouped by area (if available)\n    \nExamples:\n    Returns domain counts, sample entities, and common attributes\nBest Practices:\n    - Use this as the first call when exploring an unfamiliar Home Assistant instance\n    - Perfect for building context about the structure of the smart home\n    - After getting an overview, use domain_summary_tool to dig deeper into specific domains\n",
        "inputSchema": {
          "properties": {},
          "title": "system_overviewArguments",
          "type": "object"
        }
      },
      {
        "name": "list_automations",
        "description": "\nGet a list of all automations from Home Assistant\n\nThis function retrieves all automations configured in Home Assistant,\nincluding their IDs, entity IDs, state, and display names.\n\nReturns:\n    A list of automation dictionaries, each containing id, entity_id, \n    state, and alias (friendly name) fields.\n    \nExamples:\n    Returns all automation objects with state and friendly names\n\n",
        "inputSchema": {
          "properties": {},
          "title": "list_automationsArguments",
          "type": "object"
        }
      },
      {
        "name": "restart_ha",
        "description": "\nRestart Home Assistant\n\n\u26a0\ufe0f WARNING: Temporarily disrupts all Home Assistant operations\n\nReturns:\n    Result of restart operation\n",
        "inputSchema": {
          "properties": {},
          "title": "restart_haArguments",
          "type": "object"
        }
      },
      {
        "name": "call_service_tool",
        "description": "\nCall any Home Assistant service (low-level API access)\n\nArgs:\n    domain: The domain of the service (e.g., 'light', 'switch', 'automation')\n    service: The service to call (e.g., 'turn_on', 'turn_off', 'toggle')\n    data: Optional data to pass to the service (e.g., {'entity_id': 'light.living_room'})\n\nReturns:\n    The response from Home Assistant (usually empty for successful calls)\n\nExamples:\n    domain='light', service='turn_on', data={'entity_id': 'light.x', 'brightness': 255}\n    domain='automation', service='reload'\n    domain='fan', service='set_percentage', data={'entity_id': 'fan.x', 'percentage': 50}\n\n",
        "inputSchema": {
          "properties": {
            "domain": {
              "title": "Domain",
              "type": "string"
            },
            "service": {
              "title": "Service",
              "type": "string"
            },
            "data": {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Data"
            }
          },
          "required": [
            "domain",
            "service"
          ],
          "title": "call_service_toolArguments",
          "type": "object"
        }
      },
      {
        "name": "get_history",
        "description": "\nGet the history of an entity's state changes\n\nArgs:\n    entity_id: The entity ID to get history for\n    hours: Number of hours of history to retrieve (default: 24)\n\nReturns:\n    A dictionary containing:\n    - entity_id: The entity ID requested\n    - states: List of state objects with timestamps\n    - count: Number of state changes found\n    - first_changed: Timestamp of earliest state change\n    - last_changed: Timestamp of most recent state change\n    \nExamples:\n    entity_id=\"light.living_room\" - get 24h history\n    entity_id=\"sensor.temperature\", hours=168 - get 7 day history\nBest Practices:\n    - Keep hours reasonable (24-72) for token efficiency\n    - Use for entities with discrete state changes rather than continuously changing sensors\n    - Consider the state distribution rather than every individual state    \n",
        "inputSchema": {
          "properties": {
            "entity_id": {
              "title": "Entity Id",
              "type": "string"
            },
            "hours": {
              "default": 24,
              "title": "Hours",
              "type": "integer"
            }
          },
          "required": [
            "entity_id"
          ],
          "title": "get_historyArguments",
          "type": "object"
        }
      },
      {
        "name": "get_error_log",
        "description": "\nGet the Home Assistant error log for troubleshooting\n\nReturns:\n    A dictionary containing:\n    - log_text: The full error log text\n    - error_count: Number of ERROR entries found\n    - warning_count: Number of WARNING entries found\n    - integration_mentions: Map of integration names to mention counts\n    - error: Error message if retrieval failed\n    \nExamples:\n    Returns errors, warnings count and integration mentions\nBest Practices:\n    - Use this tool when troubleshooting specific Home Assistant errors\n    - Look for patterns in repeated errors\n    - Pay attention to timestamps to correlate errors with events\n    - Focus on integrations with many mentions in the log    \n",
        "inputSchema": {
          "properties": {},
          "title": "get_error_logArguments",
          "type": "object"
        }
      }
    ]
  },
  "mcp-neo4j-memory": {
    "display_name": "Neo4j MCP (Memory)",
    "repository": {
      "type": "git",
      "url": "https://github.com/neo4j-contrib/mcp-neo4j"
    },
    "homepage": "https://github.com/neo4j-contrib/mcp-neo4j",
    "author": {
      "name": "neo4j-contrib"
    },
    "license": "MIT",
    "tags": [
      "neo4j",
      "mcp",
      "knowledge graph"
    ],
    "arguments": {
      "NEO4J_URI": {
        "description": "Neo4j database URL",
        "required": true,
        "example": "neo4j+s://<username>:<password>@<instance>.databases.neo4j.com:7687"
      },
      "NEO4J_USERNAME": {
        "description": "Neo4j username",
        "required": true,
        "example": "<username>"
      },
      "NEO4J_PASSWORD": {
        "description": "Neo4j password",
        "required": true,
        "example": "<password>"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-neo4j-memory",
          "--db-url",
          "${NEO4J_URI}",
          "--username",
          "${NEO4J_USERNAME}",
          "--password",
          "${NEO4J_PASSWORD}"
        ],
        "description": "Clone the repository to access multiple Neo4j MCP servers",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Database Schema Query",
        "description": "Get information about what's in the graph database",
        "prompt": "What is in this graph?"
      },
      {
        "title": "Data Visualization",
        "description": "Generate charts from graph data",
        "prompt": "Render a chart from the top products sold by frequency, total and average volume"
      },
      {
        "title": "Instance Management",
        "description": "List Neo4j Aura instances",
        "prompt": "List my instances"
      },
      {
        "title": "Instance Creation",
        "description": "Create a new Neo4j Aura instance",
        "prompt": "Create a new instance named mcp-test for Aura Professional with 4GB and Graph Data Science enabled"
      },
      {
        "title": "Knowledge Storage",
        "description": "Store information in the knowledge graph",
        "prompt": "Store the fact that I worked on the Neo4j MCP Servers today with Andreas and Oskar"
      }
    ],
    "name": "mcp-neo4j-memory",
    "description": "Neo4j graph database server (schema + read/write-cypher) and separate graph database backed memory",
    "categories": [
      "Databases"
    ],
    "is_official": true
  },
  "kagimcp": {
    "display_name": "Kagi MCP server",
    "repository": {
      "type": "git",
      "url": "https://github.com/kagisearch/kagimcp"
    },
    "homepage": "https://github.com/kagisearch/kagimcp",
    "author": {
      "name": "kagisearch"
    },
    "license": "MIT",
    "tags": [
      "search",
      "summarizer"
    ],
    "arguments": {
      "KAGI_API_KEY": {
        "description": "Your Kagi API key",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      },
      "KAGI_SUMMARIZER_ENGINE": {
        "description": "Summarizer engine choice (defaults to 'cecil')",
        "required": false,
        "example": "daphne"
      },
      "FASTMCP_LOG_LEVEL": {
        "description": "Level of logging",
        "required": false,
        "example": "ERROR"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "kagimcp"
        ],
        "env": {
          "KAGI_API_KEY": "YOUR_API_KEY_HERE",
          "KAGI_SUMMARIZER_ENGINE": "YOUR_ENGINE_CHOICE_HERE"
        },
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Search Example",
        "description": "Use Kagi search to answer a factual question",
        "prompt": "Who was time's 2024 person of the year?"
      },
      {
        "title": "Summarizer Example",
        "description": "Use Kagi to summarize a video",
        "prompt": "summarize this video: https://www.youtube.com/watch?v=jNQXAC9IVRw"
      }
    ],
    "name": "kagimcp",
    "description": "<a href=\"https://glama.ai/mcp/servers/xabrrs4bka\">",
    "categories": [
      "Analytics"
    ],
    "tools": [
      {
        "name": "kagi_search_fetch",
        "description": "Fetch web results based on one or more queries using the Kagi Search API. Use for general search and when the user explicitly tells you to 'fetch' results/information. Results are from all queries given. They are numbered continuously, so that a user may be able to refer to a result by a specific number.",
        "inputSchema": {
          "properties": {
            "queries": {
              "description": "One or more concise, keyword-focused search queries. Include essential context within each query for standalone use.",
              "items": {
                "type": "string"
              },
              "title": "Queries",
              "type": "array"
            }
          },
          "required": [
            "queries"
          ],
          "title": "kagi_search_fetchArguments",
          "type": "object"
        }
      },
      {
        "name": "kagi_summarizer",
        "description": "Summarize content from a URL using the Kagi Summarizer API. The Summarizer can summarize any document type (text webpage, video, audio, etc.)",
        "inputSchema": {
          "properties": {
            "url": {
              "description": "A URL to a document to summarize.",
              "title": "Url",
              "type": "string"
            },
            "summary_type": {
              "default": "summary",
              "description": "Type of summary to produce. Options are 'summary' for paragraph prose and 'takeaway' for a bulleted list of key points.",
              "enum": [
                "summary",
                "takeaway"
              ],
              "title": "Summary Type",
              "type": "string"
            },
            "target_language": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Desired output language using language codes (e.g., 'EN' for English). If not specified, the document's original language influences the output.",
              "title": "Target Language"
            }
          },
          "required": [
            "url"
          ],
          "title": "kagi_summarizerArguments",
          "type": "object"
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "agentkit": {
    "display_name": "Chargebee Model Context Protocol (MCP) Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/chargebee/agentkit"
    },
    "homepage": "https://github.com/chargebee/agentkit",
    "author": {
      "name": "chargebee"
    },
    "license": "MIT",
    "tags": [
      "MCP",
      "Chargebee",
      "AI",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@chargebee/mcp@latest"
        ],
        "recommended": true,
        "description": "Run the Chargebee MCP server using Node.js npx"
      }
    },
    "examples": [
      {
        "title": "Search Chargebee Documentation",
        "description": "Use the documentation search tool to retrieve detailed information",
        "prompt": "Search for information about Chargebee subscription APIs"
      },
      {
        "title": "Generate Code Snippets",
        "description": "Get context-aware code snippets for Chargebee integration",
        "prompt": "Create a code sample for implementing a subscription creation flow with Chargebee"
      }
    ],
    "name": "agentkit",
    "description": "MCP Server that connects AI agents to Chargebee platform.",
    "categories": [
      "Dev Tools"
    ],
    "tools": [
      {
        "name": "chargebee_documentation_search",
        "description": "\nDo not use this tool for code generation. For code generation use \"chargebee_code_planner\" tool. \nThis tool will take in parameters about integrating with Chargebee in their application, then search and retrieve relevant Chargebee documentation content.\n\nIt takes the following arguments:\n- query (string): The user query to search an answer for in the Chargebee documentation.\n- language (enum): The programming language for the documentation. Check the user's application language.\n- userRequest (string): User's original request to you.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The user query to search an answer for in the Chargebee documentation."
            },
            "userRequest": {
              "type": "string",
              "description": "User's original request to you."
            },
            "language": {
              "type": "string",
              "enum": [
                "node",
                "python",
                "curl",
                "java",
                "go",
                "ruby",
                "php",
                "dotnet"
              ],
              "description": "The programming language for the documentation. Check the user's application language."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "chargebee_code_planner",
        "description": "\nAlways use this tool to get the accurate integeration code guide for Chargebee.\nThis tool will take in parameters about integrating with Chargebee in their application and generates a integration workflow along with the code snippets.\n\nIt takes the following arguments:\n- goal (string): What is the user's goal?\n- language (enum): Programming language the code to be generated in. Check the user's application language.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal": {
              "type": "string",
              "description": "What is the user's goal?"
            },
            "language": {
              "type": "string",
              "enum": [
                "node",
                "python",
                "curl",
                "java",
                "go",
                "ruby",
                "php",
                "dotnet"
              ],
              "description": "Programming language the code to be generated in. Check the user's application language."
            }
          },
          "required": [
            "goal"
          ]
        }
      }
    ],
    "prompts": [],
    "resources": [],
    "is_official": true
  },
  "ns-travel-information": {
    "name": "ns-travel-information",
    "display_name": "NS Travel Information",
    "description": "Access Dutch Railways (NS) real-time train travel information and disruptions through the official NS API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/r-huijts/ns-mcp-server"
    },
    "homepage": "https://github.com/r-huijts/ns-mcp-server",
    "author": {
      "name": "r-huijts"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "NS",
      "Train",
      "Travel",
      "Information"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "ns-mcp-server"
        ],
        "env": {
          "NS_API_KEY": "${NS_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Check train status",
        "description": "Ask if the 8:15 train from Almere to Amsterdam is running on time.",
        "prompt": "Is my usual 8:15 train from Almere to Amsterdam running on time?"
      },
      {
        "title": "Inquire about delays",
        "description": "Find out if there are any delays on a specific route.",
        "prompt": "Are there any delays on the Rotterdam-Den Haag route today?"
      },
      {
        "title": "Alternative routes",
        "description": "Seek alternative routes in case of maintenance on the direct line.",
        "prompt": "What's the best alternative route to Utrecht if there's maintenance on the direct line?"
      },
      {
        "title": "Get ticket price",
        "description": "Ask for ticket prices for travel between cities.",
        "prompt": "How much does a first-class ticket from Amsterdam to Rotterdam cost?"
      }
    ],
    "arguments": {
      "NS_API_KEY": {
        "description": "Your NS API key, required for authenticating API requests to access NS travel information.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "get_disruptions",
        "description": "Get comprehensive information about current and planned disruptions on the Dutch railway network. Returns details about maintenance work, unexpected disruptions, alternative transport options, impact on travel times, and relevant advice. Can filter for active disruptions and specific disruption types.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "isActive": {
              "type": "boolean",
              "description": "Filter to only return active disruptions"
            },
            "type": {
              "type": "string",
              "description": "Type of disruptions to return (e.g., MAINTENANCE, DISRUPTION)",
              "enum": [
                "MAINTENANCE",
                "DISRUPTION"
              ]
            }
          }
        }
      },
      {
        "name": "get_travel_advice",
        "description": "Get detailed travel routes between two train stations, including transfers, real-time updates, platform information, and journey duration. Can plan trips for immediate departure or for a specific future time, with options to optimize for arrival time. Returns multiple route options with status and crowding information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fromStation": {
              "type": "string",
              "description": "Name or code of departure station"
            },
            "toStation": {
              "type": "string",
              "description": "Name or code of destination station"
            },
            "dateTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Datetime that the user want to depart from his origin or or arrive at his destination"
            },
            "searchForArrival": {
              "type": "boolean",
              "description": "If true, dateTime is treated as desired arrival time"
            }
          },
          "required": [
            "fromStation",
            "toStation"
          ]
        }
      },
      {
        "name": "get_departures",
        "description": "Get real-time departure information for trains from a specific station, including platform numbers, delays, route details, and any relevant travel notes. Returns a list of upcoming departures with timing, destination, and status information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "station": {
              "type": "string",
              "description": "NS Station code for the station (e.g., ASD for Amsterdam Centraal). Required if uicCode is not provided"
            },
            "uicCode": {
              "type": "string",
              "description": "UIC code for the station. Required if station code is not provided"
            },
            "dateTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Only supported for departures at foreign stations. Defaults to server time (Europe/Amsterdam)"
            },
            "maxJourneys": {
              "type": "number",
              "description": "Number of departures to return",
              "minimum": 1,
              "maximum": 100,
              "default": 40
            },
            "lang": {
              "type": "string",
              "description": "Language for localizing the departures list. Only a small subset of text is translated, mainly notes. Defaults to Dutch",
              "enum": [
                "nl",
                "en"
              ],
              "default": "nl"
            }
          },
          "oneOf": [
            {
              "required": [
                "station"
              ]
            },
            {
              "required": [
                "uicCode"
              ]
            }
          ]
        }
      },
      {
        "name": "get_ovfiets",
        "description": "Get OV-fiets availability at a train station",
        "inputSchema": {
          "type": "object",
          "properties": {
            "stationCode": {
              "type": "string",
              "description": "Station code to check OV-fiets availability for (e.g., ASD for Amsterdam Centraal)"
            }
          },
          "required": [
            "stationCode"
          ]
        }
      },
      {
        "name": "get_station_info",
        "description": "Get detailed information about a train station",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Station name or code to search for"
            },
            "includeNonPlannableStations": {
              "type": "boolean",
              "description": "Include stations where trains do not stop regularly",
              "default": false
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return",
              "minimum": 1,
              "maximum": 50,
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_current_time_in_rfc3339",
        "description": "Get the current server time (Europe/Amsterdam timezone) in RFC3339 format. This can be used as input for other tools that require date-time parameters.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_arrivals",
        "description": "Get real-time arrival information for trains at a specific station, including platform numbers, delays, origin stations, and any relevant travel notes. Returns a list of upcoming arrivals with timing, origin, and status information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "station": {
              "type": "string",
              "description": "NS Station code for the station (e.g., ASD for Amsterdam Centraal). Required if uicCode is not provided"
            },
            "uicCode": {
              "type": "string",
              "description": "UIC code for the station. Required if station code is not provided"
            },
            "dateTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Only supported for arrivals at foreign stations. Defaults to server time (Europe/Amsterdam)"
            },
            "maxJourneys": {
              "type": "number",
              "description": "Number of arrivals to return",
              "minimum": 1,
              "maximum": 100,
              "default": 40
            },
            "lang": {
              "type": "string",
              "description": "Language for localizing the arrivals list. Only a small subset of text is translated, mainly notes. Defaults to Dutch",
              "enum": [
                "nl",
                "en"
              ],
              "default": "nl"
            }
          },
          "oneOf": [
            {
              "required": [
                "station"
              ]
            },
            {
              "required": [
                "uicCode"
              ]
            }
          ]
        }
      },
      {
        "name": "get_prices",
        "description": "Get price information for domestic train journeys, including different travel classes, ticket types, and discounts. Returns detailed pricing information with conditions and validity.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fromStation": {
              "type": "string",
              "description": "UicCode or station code of the origin station"
            },
            "toStation": {
              "type": "string",
              "description": "UicCode or station code of the destination station"
            },
            "travelClass": {
              "type": "string",
              "description": "Travel class to return the price for",
              "enum": [
                "FIRST_CLASS",
                "SECOND_CLASS"
              ]
            },
            "travelType": {
              "type": "string",
              "description": "Return the price for a single or return trip",
              "enum": [
                "single",
                "return"
              ],
              "default": "single"
            },
            "isJointJourney": {
              "type": "boolean",
              "description": "Set to true to return the price including joint journey discount",
              "default": false
            },
            "adults": {
              "type": "integer",
              "description": "Number of adults to return the price for",
              "minimum": 1,
              "default": 1
            },
            "children": {
              "type": "integer",
              "description": "Number of children to return the price for",
              "minimum": 0,
              "default": 0
            },
            "routeId": {
              "type": "string",
              "description": "Specific identifier for the route to take between the two stations. This routeId is returned in the /api/v3/trips call."
            },
            "plannedDepartureTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Used to find the correct route if multiple routes are possible."
            },
            "plannedArrivalTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Used to find the correct route if multiple routes are possible."
            }
          },
          "required": [
            "fromStation",
            "toStation"
          ]
        }
      }
    ]
  },
  "unity-catalog": {
    "name": "unity-catalog",
    "display_name": "Unity Catalog",
    "description": "An MCP server that enables LLMs to interact with Unity Catalog AI, supporting CRUD operations on Unity Catalog Functions and executing them as MCP tools.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ognis1205/mcp-server-unitycatalog"
    },
    "homepage": "https://github.com/ognis1205/mcp-server-unitycatalog",
    "author": {
      "name": "ognis1205"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Unity Catalog",
      "API",
      "Functions"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ognis1205/mcp-server-unitycatalog",
          "mcp-server-unitycatalog",
          "--uc_server",
          "${UC_SERVER}",
          "--uc_catalog",
          "${UC_CATALOG}",
          "--uc_schema",
          "${UC_SCHEMA}"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/unitycatalog",
          "--uc_server",
          "${UC_SERVER}",
          "--uc_catalog",
          "${UC_CATALOG}",
          "--uc_schema",
          "${UC_SCHEMA}"
        ]
      }
    },
    "arguments": {
      "UC_SERVER": {
        "description": "The base URL of the Unity Catalog server.",
        "required": true,
        "example": "https://my-unity-catalog.com"
      },
      "UC_CATALOG": {
        "description": "The name of the Unity Catalog catalog.",
        "required": true,
        "example": "my_catalog"
      },
      "UC_SCHEMA": {
        "description": "The name of the schema within a Unity Catalog catalog.",
        "required": true,
        "example": "my_schema"
      }
    }
  },
  "typesense": {
    "name": "typesense",
    "display_name": "Typesense",
    "description": "A Model Context Protocol (MCP) server implementation that provides AI models with access to Typesense search capabilities. This server enables LLMs to discover, search, and analyze data stored in Typesense collections.",
    "repository": {
      "type": "git",
      "url": "https://github.com/suhail-ak-s/mcp-typesense-server"
    },
    "homepage": "https://github.com/suhail-ak-s/mcp-typesense-server",
    "author": {
      "name": "suhail-ak-s"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Typesense",
      "Server",
      "Search"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "typesense-mcp-server",
          "--host",
          "${TYPESENSE_HOST}",
          "--port",
          "8108",
          "--protocol",
          "http",
          "--api-key",
          "${API_KEY}"
        ]
      }
    },
    "examples": [
      {
        "title": "Example Usage with Claude Desktop",
        "description": "Configuration for using Typesense MCP Server with Claude Desktop.",
        "prompt": "{\"mcpServers\": {\"typesense\": {\"command\": \"npx\",\"args\": [\"-y\",\"typesense-mcp-server\",\"--host\", \"your-typesense-host\",\"--port\", \"8108\",\"--protocol\", \"http\",\"--api-key\", \"your-api-key\"]}}}"
      }
    ],
    "arguments": {
      "TYPESENSE_HOST": {
        "description": "The host for the Typesense server. This is the address where your Typesense server is running.",
        "required": true,
        "example": "localhost"
      },
      "API_KEY": {
        "description": "The API key for accessing the Typesense server. This is needed for authentication when making requests to the server.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "typesense_query",
        "description": "Search for relevant documents in the TypeSense database based on the user's query.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query entered by the user."
            },
            "collection": {
              "type": "string",
              "description": "The name of the TypeSense collection to search within."
            },
            "query_by": {
              "type": "string",
              "description": "Comma-separated fields to search in the collection, e.g., 'title,content'."
            },
            "filter_by": {
              "type": "string",
              "description": "Optional filtering criteria, e.g., 'category:Chatbot'."
            },
            "sort_by": {
              "type": "string",
              "description": "Sorting criteria, e.g., 'created_at:desc'."
            },
            "limit": {
              "type": "integer",
              "description": "The maximum number of results to return.",
              "default": 10
            }
          },
          "required": [
            "query",
            "collection",
            "query_by"
          ]
        }
      },
      {
        "name": "typesense_get_document",
        "description": "Retrieve a specific document by ID from a Typesense collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "The name of the TypeSense collection"
            },
            "document_id": {
              "type": "string",
              "description": "The ID of the document to retrieve"
            }
          },
          "required": [
            "collection",
            "document_id"
          ]
        }
      },
      {
        "name": "typesense_collection_stats",
        "description": "Get statistics about a Typesense collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "The name of the TypeSense collection"
            }
          },
          "required": [
            "collection"
          ]
        }
      }
    ]
  },
  "chatsum": {
    "name": "chatsum",
    "display_name": "Chat Summary",
    "description": "Query and Summarize chat messages with LLM. by [mcpso](https://mcp.so/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/mcpso/mcp-server-chatsum"
    },
    "homepage": "https://github.com/mcpso/mcp-server-chatsum",
    "author": {
      "name": "idoubi",
      "url": "https://bento.me/idoubi"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "chat",
      "summary"
    ],
    "examples": [
      {
        "title": "Summarize Chat Messages",
        "description": "Use this prompt to summarize chat messages based on given parameters.",
        "prompt": "Summarize these messages: [...]"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/mcpso/mcp-server-chatsum"
        ],
        "env": {
          "CHAT_DB_PATH": "path-to/mcp-server-chatsum/chatbot/data/chat.db"
        }
      }
    },
    "arguments": {
      "CHAT_DB_PATH": {
        "description": "Path to your chat database file that the server will use to store and retrieve chat messages.",
        "required": true,
        "example": "path-to/mcp-server-chatsum/chatbot/data/chat.db"
      }
    },
    "tools": [
      {
        "name": "query_chat_messages",
        "description": "query chat messages with given parameters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "room_names": {
              "type": "array",
              "description": "chat room names",
              "items": {
                "type": "string",
                "description": "chat room name"
              }
            },
            "talker_names": {
              "type": "array",
              "description": "talker names",
              "items": {
                "type": "string",
                "description": "talker name"
              }
            },
            "limit": {
              "type": "number",
              "description": "chat messages limit",
              "default": 100
            }
          },
          "required": []
        }
      }
    ]
  },
  "descope": {
    "name": "descope",
    "display_name": "Descope",
    "description": "An MCP server to integrate with [Descope](https://descope.com/) to search audit logs, manage users, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/descope-sample-apps/descope-mcp-server"
    },
    "homepage": "https://github.com/descope-sample-apps/descope-mcp-server",
    "author": {
      "name": "Descope",
      "url": "https://descope.com"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Descope",
      "API",
      "Server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/descope-sample-apps/descope-mcp-server"
        ],
        "env": {
          "DESCOPE_PROJECT_ID": "${DESCOPE_PROJECT_ID}",
          "DESCOPE_MANAGEMENT_KEY": "${DESCOPE_MANAGEMENT_KEY}"
        }
      }
    },
    "arguments": {
      "DESCOPE_PROJECT_ID": {
        "description": "Your Descope Project ID",
        "required": true,
        "example": "12345-abcde-67890-fghij"
      },
      "DESCOPE_MANAGEMENT_KEY": {
        "description": "Your Descope Management Key",
        "required": true,
        "example": "sk_test_xxxxxxxxxxxxxxxxxxxx"
      }
    }
  },
  "integration-app": {
    "display_name": "Integration App MCP Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/integration-app/mcp-server"
    },
    "license": "[NOT GIVEN]",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@integration-app/mcp-server"
        ],
        "package": "@integration-app/mcp-server",
        "env": {
          "INTEGRATION_APP_TOKEN": "<your-integration-app-token>",
          "INTEGRATION_KEY": "<integration-key>"
        }
      }
    },
    "arguments": {
      "INTEGRATION_APP_TOKEN": {
        "description": "Token for accessing Integration App API",
        "required": true,
        "example": "your-integration-app-token"
      },
      "INTEGRATION_KEY": {
        "description": "Key of the integration you want to use tools for",
        "required": true,
        "example": "your-integration-key"
      }
    },
    "homepage": "https://integration.app",
    "author": {
      "name": "integration-app"
    },
    "tags": [
      "integration",
      "tools",
      "mcp"
    ],
    "name": "mcp-server",
    "description": "This is an implementation of the [Model Context Protocol (MCP) server](https://modelcontextprotocol.org/) that exposes tools powered by [Integration App](https://integration.app).",
    "categories": [
      "MCP Tools"
    ],
    "is_official": true
  },
  "mcp-jetbrains": {
    "display_name": "JetBrains MCP Proxy Server",
    "repository": {
      "type": "git",
      "url": "https://github.com/JetBrains/mcp-jetbrains"
    },
    "license": "Apache-2.0",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@jetbrains/mcp-proxy"
        ],
        "package": "@jetbrains/mcp-proxy",
        "description": "Install via npm package",
        "recommended": true
      }
    },
    "homepage": "https://github.com/JetBrains/mcp-jetbrains",
    "author": {
      "name": "JetBrains"
    },
    "tags": [
      "jetbrains",
      "ide",
      "proxy"
    ],
    "arguments": {
      "IDE_PORT": {
        "description": "Port of IDE's built-in webserver",
        "required": false,
        "example": "<port of IDE's built-in webserver>"
      },
      "HOST": {
        "description": "Host/address of IDE's built-in webserver (defaults to 127.0.0.1)",
        "required": false,
        "example": "<host/address of IDE's built-in webserver>"
      },
      "LOG_ENABLED": {
        "description": "Enable logging",
        "required": false,
        "example": "true"
      }
    },
    "name": "mcp-jetbrains",
    "description": "The server proxies requests from client to JetBrains IDE.",
    "categories": [
      "Dev Tools"
    ],
    "tools": [],
    "prompts": [],
    "resources": [],
    "is_official": true
  }
}